
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Car
 * 
 */
export type Car = $Result.DefaultSelection<Prisma.$CarPayload>
/**
 * Model CarLicenseHistory
 * 
 */
export type CarLicenseHistory = $Result.DefaultSelection<Prisma.$CarLicenseHistoryPayload>
/**
 * Model Ride
 * 
 */
export type Ride = $Result.DefaultSelection<Prisma.$RidePayload>
/**
 * Model RideInterest
 * 
 */
export type RideInterest = $Result.DefaultSelection<Prisma.$RideInterestPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model ChatMember
 * 
 */
export type ChatMember = $Result.DefaultSelection<Prisma.$ChatMemberPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model AppConfig
 * 
 */
export type AppConfig = $Result.DefaultSelection<Prisma.$AppConfigPayload>
/**
 * Model UserStats
 * 
 */
export type UserStats = $Result.DefaultSelection<Prisma.$UserStatsPayload>
/**
 * Model PromoCode
 * 
 */
export type PromoCode = $Result.DefaultSelection<Prisma.$PromoCodePayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model AdminLastVisit
 * 
 */
export type AdminLastVisit = $Result.DefaultSelection<Prisma.$AdminLastVisitPayload>
/**
 * Model SavedRoute
 * 
 */
export type SavedRoute = $Result.DefaultSelection<Prisma.$SavedRoutePayload>
/**
 * Model ScheduledRide
 * 
 */
export type ScheduledRide = $Result.DefaultSelection<Prisma.$ScheduledRidePayload>
/**
 * Model RideComment
 * 
 */
export type RideComment = $Result.DefaultSelection<Prisma.$RideCommentPayload>
/**
 * Model GroupBookingInvitation
 * 
 */
export type GroupBookingInvitation = $Result.DefaultSelection<Prisma.$GroupBookingInvitationPayload>
/**
 * Model spatial_ref_sys
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type spatial_ref_sys = $Result.DefaultSelection<Prisma.$spatial_ref_sysPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const VerificationStatus: {
  NOT_SUBMITTED: 'NOT_SUBMITTED',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const RideStatus: {
  UPCOMING: 'UPCOMING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type RideStatus = (typeof RideStatus)[keyof typeof RideStatus]


export const BookingStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const OfferStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type OfferStatus = (typeof OfferStatus)[keyof typeof OfferStatus]


export const ReportStatus: {
  PENDING: 'PENDING',
  RESOLVED: 'RESOLVED',
  DISMISSED: 'DISMISSED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]

}

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type RideStatus = $Enums.RideStatus

export const RideStatus: typeof $Enums.RideStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type OfferStatus = $Enums.OfferStatus

export const OfferStatus: typeof $Enums.OfferStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.car`: Exposes CRUD operations for the **Car** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cars
    * const cars = await prisma.car.findMany()
    * ```
    */
  get car(): Prisma.CarDelegate<ExtArgs>;

  /**
   * `prisma.carLicenseHistory`: Exposes CRUD operations for the **CarLicenseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CarLicenseHistories
    * const carLicenseHistories = await prisma.carLicenseHistory.findMany()
    * ```
    */
  get carLicenseHistory(): Prisma.CarLicenseHistoryDelegate<ExtArgs>;

  /**
   * `prisma.ride`: Exposes CRUD operations for the **Ride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rides
    * const rides = await prisma.ride.findMany()
    * ```
    */
  get ride(): Prisma.RideDelegate<ExtArgs>;

  /**
   * `prisma.rideInterest`: Exposes CRUD operations for the **RideInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RideInterests
    * const rideInterests = await prisma.rideInterest.findMany()
    * ```
    */
  get rideInterest(): Prisma.RideInterestDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs>;

  /**
   * `prisma.chatMember`: Exposes CRUD operations for the **ChatMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMembers
    * const chatMembers = await prisma.chatMember.findMany()
    * ```
    */
  get chatMember(): Prisma.ChatMemberDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs>;

  /**
   * `prisma.appConfig`: Exposes CRUD operations for the **AppConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppConfigs
    * const appConfigs = await prisma.appConfig.findMany()
    * ```
    */
  get appConfig(): Prisma.AppConfigDelegate<ExtArgs>;

  /**
   * `prisma.userStats`: Exposes CRUD operations for the **UserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStats
    * const userStats = await prisma.userStats.findMany()
    * ```
    */
  get userStats(): Prisma.UserStatsDelegate<ExtArgs>;

  /**
   * `prisma.promoCode`: Exposes CRUD operations for the **PromoCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoCodes
    * const promoCodes = await prisma.promoCode.findMany()
    * ```
    */
  get promoCode(): Prisma.PromoCodeDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.adminLastVisit`: Exposes CRUD operations for the **AdminLastVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminLastVisits
    * const adminLastVisits = await prisma.adminLastVisit.findMany()
    * ```
    */
  get adminLastVisit(): Prisma.AdminLastVisitDelegate<ExtArgs>;

  /**
   * `prisma.savedRoute`: Exposes CRUD operations for the **SavedRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedRoutes
    * const savedRoutes = await prisma.savedRoute.findMany()
    * ```
    */
  get savedRoute(): Prisma.SavedRouteDelegate<ExtArgs>;

  /**
   * `prisma.scheduledRide`: Exposes CRUD operations for the **ScheduledRide** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledRides
    * const scheduledRides = await prisma.scheduledRide.findMany()
    * ```
    */
  get scheduledRide(): Prisma.ScheduledRideDelegate<ExtArgs>;

  /**
   * `prisma.rideComment`: Exposes CRUD operations for the **RideComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RideComments
    * const rideComments = await prisma.rideComment.findMany()
    * ```
    */
  get rideComment(): Prisma.RideCommentDelegate<ExtArgs>;

  /**
   * `prisma.groupBookingInvitation`: Exposes CRUD operations for the **GroupBookingInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupBookingInvitations
    * const groupBookingInvitations = await prisma.groupBookingInvitation.findMany()
    * ```
    */
  get groupBookingInvitation(): Prisma.GroupBookingInvitationDelegate<ExtArgs>;

  /**
   * `prisma.spatial_ref_sys`: Exposes CRUD operations for the **spatial_ref_sys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spatial_ref_sys
    * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
    * ```
    */
  get spatial_ref_sys(): Prisma.spatial_ref_sysDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Car: 'Car',
    CarLicenseHistory: 'CarLicenseHistory',
    Ride: 'Ride',
    RideInterest: 'RideInterest',
    Booking: 'Booking',
    Offer: 'Offer',
    Chat: 'Chat',
    ChatMember: 'ChatMember',
    Message: 'Message',
    Notification: 'Notification',
    Feedback: 'Feedback',
    Badge: 'Badge',
    UserBadge: 'UserBadge',
    Referral: 'Referral',
    AppConfig: 'AppConfig',
    UserStats: 'UserStats',
    PromoCode: 'PromoCode',
    Report: 'Report',
    AdminLastVisit: 'AdminLastVisit',
    SavedRoute: 'SavedRoute',
    ScheduledRide: 'ScheduledRide',
    RideComment: 'RideComment',
    GroupBookingInvitation: 'GroupBookingInvitation',
    spatial_ref_sys: 'spatial_ref_sys'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "car" | "carLicenseHistory" | "ride" | "rideInterest" | "booking" | "offer" | "chat" | "chatMember" | "message" | "notification" | "feedback" | "badge" | "userBadge" | "referral" | "appConfig" | "userStats" | "promoCode" | "report" | "adminLastVisit" | "savedRoute" | "scheduledRide" | "rideComment" | "groupBookingInvitation" | "spatial_ref_sys"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Car: {
        payload: Prisma.$CarPayload<ExtArgs>
        fields: Prisma.CarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findFirst: {
            args: Prisma.CarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          findMany: {
            args: Prisma.CarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>[]
          }
          create: {
            args: Prisma.CarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          createMany: {
            args: Prisma.CarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>[]
          }
          delete: {
            args: Prisma.CarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          update: {
            args: Prisma.CarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          deleteMany: {
            args: Prisma.CarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarPayload>
          }
          aggregate: {
            args: Prisma.CarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCar>
          }
          groupBy: {
            args: Prisma.CarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarCountArgs<ExtArgs>
            result: $Utils.Optional<CarCountAggregateOutputType> | number
          }
        }
      }
      CarLicenseHistory: {
        payload: Prisma.$CarLicenseHistoryPayload<ExtArgs>
        fields: Prisma.CarLicenseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CarLicenseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CarLicenseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>
          }
          findFirst: {
            args: Prisma.CarLicenseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CarLicenseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>
          }
          findMany: {
            args: Prisma.CarLicenseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>[]
          }
          create: {
            args: Prisma.CarLicenseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>
          }
          createMany: {
            args: Prisma.CarLicenseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CarLicenseHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>[]
          }
          delete: {
            args: Prisma.CarLicenseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>
          }
          update: {
            args: Prisma.CarLicenseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CarLicenseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CarLicenseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CarLicenseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CarLicenseHistoryPayload>
          }
          aggregate: {
            args: Prisma.CarLicenseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCarLicenseHistory>
          }
          groupBy: {
            args: Prisma.CarLicenseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CarLicenseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CarLicenseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CarLicenseHistoryCountAggregateOutputType> | number
          }
        }
      }
      Ride: {
        payload: Prisma.$RidePayload<ExtArgs>
        fields: Prisma.RideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          findFirst: {
            args: Prisma.RideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          findMany: {
            args: Prisma.RideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>[]
          }
          create: {
            args: Prisma.RideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          createMany: {
            args: Prisma.RideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>[]
          }
          delete: {
            args: Prisma.RideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          update: {
            args: Prisma.RideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          deleteMany: {
            args: Prisma.RideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          aggregate: {
            args: Prisma.RideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRide>
          }
          groupBy: {
            args: Prisma.RideGroupByArgs<ExtArgs>
            result: $Utils.Optional<RideGroupByOutputType>[]
          }
          count: {
            args: Prisma.RideCountArgs<ExtArgs>
            result: $Utils.Optional<RideCountAggregateOutputType> | number
          }
        }
      }
      RideInterest: {
        payload: Prisma.$RideInterestPayload<ExtArgs>
        fields: Prisma.RideInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RideInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RideInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>
          }
          findFirst: {
            args: Prisma.RideInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RideInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>
          }
          findMany: {
            args: Prisma.RideInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>[]
          }
          create: {
            args: Prisma.RideInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>
          }
          createMany: {
            args: Prisma.RideInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RideInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>[]
          }
          delete: {
            args: Prisma.RideInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>
          }
          update: {
            args: Prisma.RideInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>
          }
          deleteMany: {
            args: Prisma.RideInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RideInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RideInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideInterestPayload>
          }
          aggregate: {
            args: Prisma.RideInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRideInterest>
          }
          groupBy: {
            args: Prisma.RideInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RideInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RideInterestCountArgs<ExtArgs>
            result: $Utils.Optional<RideInterestCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      ChatMember: {
        payload: Prisma.$ChatMemberPayload<ExtArgs>
        fields: Prisma.ChatMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          findFirst: {
            args: Prisma.ChatMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          findMany: {
            args: Prisma.ChatMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>[]
          }
          create: {
            args: Prisma.ChatMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          createMany: {
            args: Prisma.ChatMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>[]
          }
          delete: {
            args: Prisma.ChatMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          update: {
            args: Prisma.ChatMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          deleteMany: {
            args: Prisma.ChatMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMemberPayload>
          }
          aggregate: {
            args: Prisma.ChatMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMember>
          }
          groupBy: {
            args: Prisma.ChatMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMemberCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      AppConfig: {
        payload: Prisma.$AppConfigPayload<ExtArgs>
        fields: Prisma.AppConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findFirst: {
            args: Prisma.AppConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          findMany: {
            args: Prisma.AppConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          create: {
            args: Prisma.AppConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          createMany: {
            args: Prisma.AppConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>[]
          }
          delete: {
            args: Prisma.AppConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          update: {
            args: Prisma.AppConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          deleteMany: {
            args: Prisma.AppConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppConfigPayload>
          }
          aggregate: {
            args: Prisma.AppConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppConfig>
          }
          groupBy: {
            args: Prisma.AppConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppConfigCountArgs<ExtArgs>
            result: $Utils.Optional<AppConfigCountAggregateOutputType> | number
          }
        }
      }
      UserStats: {
        payload: Prisma.$UserStatsPayload<ExtArgs>
        fields: Prisma.UserStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findFirst: {
            args: Prisma.UserStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          findMany: {
            args: Prisma.UserStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          create: {
            args: Prisma.UserStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          createMany: {
            args: Prisma.UserStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
          }
          delete: {
            args: Prisma.UserStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          update: {
            args: Prisma.UserStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          deleteMany: {
            args: Prisma.UserStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStatsPayload>
          }
          aggregate: {
            args: Prisma.UserStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStats>
          }
          groupBy: {
            args: Prisma.UserStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStatsCountArgs<ExtArgs>
            result: $Utils.Optional<UserStatsCountAggregateOutputType> | number
          }
        }
      }
      PromoCode: {
        payload: Prisma.$PromoCodePayload<ExtArgs>
        fields: Prisma.PromoCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findFirst: {
            args: Prisma.PromoCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          findMany: {
            args: Prisma.PromoCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          create: {
            args: Prisma.PromoCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          createMany: {
            args: Prisma.PromoCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>[]
          }
          delete: {
            args: Prisma.PromoCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          update: {
            args: Prisma.PromoCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          deleteMany: {
            args: Prisma.PromoCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromoCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoCodePayload>
          }
          aggregate: {
            args: Prisma.PromoCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoCode>
          }
          groupBy: {
            args: Prisma.PromoCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoCodeCountArgs<ExtArgs>
            result: $Utils.Optional<PromoCodeCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      AdminLastVisit: {
        payload: Prisma.$AdminLastVisitPayload<ExtArgs>
        fields: Prisma.AdminLastVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminLastVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminLastVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>
          }
          findFirst: {
            args: Prisma.AdminLastVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminLastVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>
          }
          findMany: {
            args: Prisma.AdminLastVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>[]
          }
          create: {
            args: Prisma.AdminLastVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>
          }
          createMany: {
            args: Prisma.AdminLastVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminLastVisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>[]
          }
          delete: {
            args: Prisma.AdminLastVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>
          }
          update: {
            args: Prisma.AdminLastVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>
          }
          deleteMany: {
            args: Prisma.AdminLastVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminLastVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminLastVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminLastVisitPayload>
          }
          aggregate: {
            args: Prisma.AdminLastVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminLastVisit>
          }
          groupBy: {
            args: Prisma.AdminLastVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminLastVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminLastVisitCountArgs<ExtArgs>
            result: $Utils.Optional<AdminLastVisitCountAggregateOutputType> | number
          }
        }
      }
      SavedRoute: {
        payload: Prisma.$SavedRoutePayload<ExtArgs>
        fields: Prisma.SavedRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>
          }
          findFirst: {
            args: Prisma.SavedRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>
          }
          findMany: {
            args: Prisma.SavedRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>[]
          }
          create: {
            args: Prisma.SavedRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>
          }
          createMany: {
            args: Prisma.SavedRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>[]
          }
          delete: {
            args: Prisma.SavedRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>
          }
          update: {
            args: Prisma.SavedRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>
          }
          deleteMany: {
            args: Prisma.SavedRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedRoutePayload>
          }
          aggregate: {
            args: Prisma.SavedRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedRoute>
          }
          groupBy: {
            args: Prisma.SavedRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedRouteCountArgs<ExtArgs>
            result: $Utils.Optional<SavedRouteCountAggregateOutputType> | number
          }
        }
      }
      ScheduledRide: {
        payload: Prisma.$ScheduledRidePayload<ExtArgs>
        fields: Prisma.ScheduledRideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledRideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledRideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>
          }
          findFirst: {
            args: Prisma.ScheduledRideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledRideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>
          }
          findMany: {
            args: Prisma.ScheduledRideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>[]
          }
          create: {
            args: Prisma.ScheduledRideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>
          }
          createMany: {
            args: Prisma.ScheduledRideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduledRideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>[]
          }
          delete: {
            args: Prisma.ScheduledRideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>
          }
          update: {
            args: Prisma.ScheduledRideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>
          }
          deleteMany: {
            args: Prisma.ScheduledRideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledRideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledRideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledRidePayload>
          }
          aggregate: {
            args: Prisma.ScheduledRideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledRide>
          }
          groupBy: {
            args: Prisma.ScheduledRideGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledRideGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledRideCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledRideCountAggregateOutputType> | number
          }
        }
      }
      RideComment: {
        payload: Prisma.$RideCommentPayload<ExtArgs>
        fields: Prisma.RideCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RideCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RideCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>
          }
          findFirst: {
            args: Prisma.RideCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RideCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>
          }
          findMany: {
            args: Prisma.RideCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>[]
          }
          create: {
            args: Prisma.RideCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>
          }
          createMany: {
            args: Prisma.RideCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RideCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>[]
          }
          delete: {
            args: Prisma.RideCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>
          }
          update: {
            args: Prisma.RideCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>
          }
          deleteMany: {
            args: Prisma.RideCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RideCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RideCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideCommentPayload>
          }
          aggregate: {
            args: Prisma.RideCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRideComment>
          }
          groupBy: {
            args: Prisma.RideCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RideCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RideCommentCountArgs<ExtArgs>
            result: $Utils.Optional<RideCommentCountAggregateOutputType> | number
          }
        }
      }
      GroupBookingInvitation: {
        payload: Prisma.$GroupBookingInvitationPayload<ExtArgs>
        fields: Prisma.GroupBookingInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupBookingInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupBookingInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>
          }
          findFirst: {
            args: Prisma.GroupBookingInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupBookingInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>
          }
          findMany: {
            args: Prisma.GroupBookingInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>[]
          }
          create: {
            args: Prisma.GroupBookingInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>
          }
          createMany: {
            args: Prisma.GroupBookingInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupBookingInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>[]
          }
          delete: {
            args: Prisma.GroupBookingInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>
          }
          update: {
            args: Prisma.GroupBookingInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>
          }
          deleteMany: {
            args: Prisma.GroupBookingInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupBookingInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupBookingInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupBookingInvitationPayload>
          }
          aggregate: {
            args: Prisma.GroupBookingInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupBookingInvitation>
          }
          groupBy: {
            args: Prisma.GroupBookingInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupBookingInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupBookingInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<GroupBookingInvitationCountAggregateOutputType> | number
          }
        }
      }
      spatial_ref_sys: {
        payload: Prisma.$spatial_ref_sysPayload<ExtArgs>
        fields: Prisma.spatial_ref_sysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.spatial_ref_sysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findFirst: {
            args: Prisma.spatial_ref_sysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findMany: {
            args: Prisma.spatial_ref_sysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          create: {
            args: Prisma.spatial_ref_sysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          createMany: {
            args: Prisma.spatial_ref_sysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          delete: {
            args: Prisma.spatial_ref_sysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          update: {
            args: Prisma.spatial_ref_sysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          deleteMany: {
            args: Prisma.spatial_ref_sysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.spatial_ref_sysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.spatial_ref_sysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          aggregate: {
            args: Prisma.Spatial_ref_sysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpatial_ref_sys>
          }
          groupBy: {
            args: Prisma.spatial_ref_sysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysGroupByOutputType>[]
          }
          count: {
            args: Prisma.spatial_ref_sysCountArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    lastVisits: number
    bookings: number
    initiatedInvitations: number
    chats: number
    feedbacksGiven: number
    feedbacksReceived: number
    messages: number
    notifications: number
    offers: number
    promoCodes: number
    referralsMade: number
    reportsReceived: number
    reportsMade: number
    rides: number
    comments: number
    interests: number
    savedRoutes: number
    scheduledRides: number
    badges: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastVisits?: boolean | UserCountOutputTypeCountLastVisitsArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    initiatedInvitations?: boolean | UserCountOutputTypeCountInitiatedInvitationsArgs
    chats?: boolean | UserCountOutputTypeCountChatsArgs
    feedbacksGiven?: boolean | UserCountOutputTypeCountFeedbacksGivenArgs
    feedbacksReceived?: boolean | UserCountOutputTypeCountFeedbacksReceivedArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    offers?: boolean | UserCountOutputTypeCountOffersArgs
    promoCodes?: boolean | UserCountOutputTypeCountPromoCodesArgs
    referralsMade?: boolean | UserCountOutputTypeCountReferralsMadeArgs
    reportsReceived?: boolean | UserCountOutputTypeCountReportsReceivedArgs
    reportsMade?: boolean | UserCountOutputTypeCountReportsMadeArgs
    rides?: boolean | UserCountOutputTypeCountRidesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    interests?: boolean | UserCountOutputTypeCountInterestsArgs
    savedRoutes?: boolean | UserCountOutputTypeCountSavedRoutesArgs
    scheduledRides?: boolean | UserCountOutputTypeCountScheduledRidesArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLastVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLastVisitWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInitiatedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupBookingInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPromoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideInterestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedRouteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduledRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledRideWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type CarCountOutputType
   */

  export type CarCountOutputType = {
    licenseHistory: number
    rides: number
  }

  export type CarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    licenseHistory?: boolean | CarCountOutputTypeCountLicenseHistoryArgs
    rides?: boolean | CarCountOutputTypeCountRidesArgs
  }

  // Custom InputTypes
  /**
   * CarCountOutputType without action
   */
  export type CarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarCountOutputType
     */
    select?: CarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CarCountOutputType without action
   */
  export type CarCountOutputTypeCountLicenseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarLicenseHistoryWhereInput
  }

  /**
   * CarCountOutputType without action
   */
  export type CarCountOutputTypeCountRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
  }


  /**
   * Count Type RideCountOutputType
   */

  export type RideCountOutputType = {
    bookings: number
    feedbacks: number
    offers: number
    reports: number
    comments: number
    interests: number
    groupInvitations: number
  }

  export type RideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | RideCountOutputTypeCountBookingsArgs
    feedbacks?: boolean | RideCountOutputTypeCountFeedbacksArgs
    offers?: boolean | RideCountOutputTypeCountOffersArgs
    reports?: boolean | RideCountOutputTypeCountReportsArgs
    comments?: boolean | RideCountOutputTypeCountCommentsArgs
    interests?: boolean | RideCountOutputTypeCountInterestsArgs
    groupInvitations?: boolean | RideCountOutputTypeCountGroupInvitationsArgs
  }

  // Custom InputTypes
  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideCountOutputType
     */
    select?: RideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideCommentWhereInput
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideInterestWhereInput
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountGroupInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupBookingInvitationWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    members: number
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChatCountOutputTypeCountMembersArgs
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMemberWhereInput
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    users: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BadgeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type ScheduledRideCountOutputType
   */

  export type ScheduledRideCountOutputType = {
    createdRides: number
  }

  export type ScheduledRideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdRides?: boolean | ScheduledRideCountOutputTypeCountCreatedRidesArgs
  }

  // Custom InputTypes
  /**
   * ScheduledRideCountOutputType without action
   */
  export type ScheduledRideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRideCountOutputType
     */
    select?: ScheduledRideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduledRideCountOutputType without action
   */
  export type ScheduledRideCountOutputTypeCountCreatedRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
  }


  /**
   * Count Type RideCommentCountOutputType
   */

  export type RideCommentCountOutputType = {
    replies: number
  }

  export type RideCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | RideCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * RideCommentCountOutputType without action
   */
  export type RideCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideCommentCountOutputType
     */
    select?: RideCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RideCommentCountOutputType without action
   */
  export type RideCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideCommentWhereInput
  }


  /**
   * Count Type GroupBookingInvitationCountOutputType
   */

  export type GroupBookingInvitationCountOutputType = {
    bookings: number
  }

  export type GroupBookingInvitationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | GroupBookingInvitationCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * GroupBookingInvitationCountOutputType without action
   */
  export type GroupBookingInvitationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitationCountOutputType
     */
    select?: GroupBookingInvitationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupBookingInvitationCountOutputType without action
   */
  export type GroupBookingInvitationCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    completedRides: number | null
    rideSearchWindowDays: number | null
    rating: number | null
    currentLat: number | null
    currentLng: number | null
    referralsCount: number | null
    homeLat: number | null
    homeLng: number | null
    workLat: number | null
    workLng: number | null
  }

  export type UserSumAggregateOutputType = {
    completedRides: number | null
    rideSearchWindowDays: number | null
    rating: number | null
    currentLat: number | null
    currentLng: number | null
    referralsCount: number | null
    homeLat: number | null
    homeLng: number | null
    workLat: number | null
    workLng: number | null
  }

  export type UserMinAggregateOutputType = {
    name: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    gender: string | null
    isVerified: boolean | null
    password: string | null
    updatedAt: Date | null
    id: string | null
    birthDate: Date | null
    city: string | null
    completedRides: number | null
    genderPreference: string | null
    rideSearchWindowDays: number | null
    isPremium: boolean | null
    joinDate: Date | null
    profileImage: string | null
    rating: number | null
    currentLat: number | null
    currentLng: number | null
    drivingLicenseUrl: string | null
    idBackImageUrl: string | null
    idFrontImageUrl: string | null
    autoRenew: boolean | null
    darkMode: boolean | null
    hasSeenOnboarding: boolean | null
    idVerificationStatus: $Enums.VerificationStatus | null
    nextFreeRideAt: Date | null
    passwordResetExpires: Date | null
    passwordResetToken: string | null
    preferredLanguage: string | null
    premiumEndDate: Date | null
    premiumStartDate: Date | null
    referralCode: string | null
    profileImageLocked: boolean | null
    role: string | null
    emailVerificationExpires: Date | null
    emailVerificationToken: string | null
    isEmailVerified: boolean | null
    hasUsedFreeTrial: boolean | null
    isEligibleForReward: boolean | null
    referralsCount: number | null
    driverLicenseExpiryDate: Date | null
    homeAddress: string | null
    homeLat: number | null
    homeLng: number | null
    workAddress: string | null
    workLat: number | null
    workLng: number | null
  }

  export type UserMaxAggregateOutputType = {
    name: string | null
    email: string | null
    phone: string | null
    createdAt: Date | null
    gender: string | null
    isVerified: boolean | null
    password: string | null
    updatedAt: Date | null
    id: string | null
    birthDate: Date | null
    city: string | null
    completedRides: number | null
    genderPreference: string | null
    rideSearchWindowDays: number | null
    isPremium: boolean | null
    joinDate: Date | null
    profileImage: string | null
    rating: number | null
    currentLat: number | null
    currentLng: number | null
    drivingLicenseUrl: string | null
    idBackImageUrl: string | null
    idFrontImageUrl: string | null
    autoRenew: boolean | null
    darkMode: boolean | null
    hasSeenOnboarding: boolean | null
    idVerificationStatus: $Enums.VerificationStatus | null
    nextFreeRideAt: Date | null
    passwordResetExpires: Date | null
    passwordResetToken: string | null
    preferredLanguage: string | null
    premiumEndDate: Date | null
    premiumStartDate: Date | null
    referralCode: string | null
    profileImageLocked: boolean | null
    role: string | null
    emailVerificationExpires: Date | null
    emailVerificationToken: string | null
    isEmailVerified: boolean | null
    hasUsedFreeTrial: boolean | null
    isEligibleForReward: boolean | null
    referralsCount: number | null
    driverLicenseExpiryDate: Date | null
    homeAddress: string | null
    homeLat: number | null
    homeLng: number | null
    workAddress: string | null
    workLat: number | null
    workLng: number | null
  }

  export type UserCountAggregateOutputType = {
    name: number
    email: number
    phone: number
    createdAt: number
    gender: number
    isVerified: number
    password: number
    updatedAt: number
    id: number
    birthDate: number
    city: number
    completedRides: number
    genderPreference: number
    rideSearchWindowDays: number
    isPremium: number
    joinDate: number
    profileImage: number
    rating: number
    currentLat: number
    currentLng: number
    drivingLicenseUrl: number
    idBackImageUrl: number
    idFrontImageUrl: number
    autoRenew: number
    darkMode: number
    hasSeenOnboarding: number
    idVerificationStatus: number
    nextFreeRideAt: number
    passwordResetExpires: number
    passwordResetToken: number
    preferredLanguage: number
    premiumEndDate: number
    premiumStartDate: number
    referralCode: number
    profileImageLocked: number
    role: number
    emailVerificationExpires: number
    emailVerificationToken: number
    isEmailVerified: number
    hasUsedFreeTrial: number
    isEligibleForReward: number
    referralsCount: number
    driverLicenseExpiryDate: number
    homeAddress: number
    homeLat: number
    homeLng: number
    workAddress: number
    workLat: number
    workLng: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    completedRides?: true
    rideSearchWindowDays?: true
    rating?: true
    currentLat?: true
    currentLng?: true
    referralsCount?: true
    homeLat?: true
    homeLng?: true
    workLat?: true
    workLng?: true
  }

  export type UserSumAggregateInputType = {
    completedRides?: true
    rideSearchWindowDays?: true
    rating?: true
    currentLat?: true
    currentLng?: true
    referralsCount?: true
    homeLat?: true
    homeLng?: true
    workLat?: true
    workLng?: true
  }

  export type UserMinAggregateInputType = {
    name?: true
    email?: true
    phone?: true
    createdAt?: true
    gender?: true
    isVerified?: true
    password?: true
    updatedAt?: true
    id?: true
    birthDate?: true
    city?: true
    completedRides?: true
    genderPreference?: true
    rideSearchWindowDays?: true
    isPremium?: true
    joinDate?: true
    profileImage?: true
    rating?: true
    currentLat?: true
    currentLng?: true
    drivingLicenseUrl?: true
    idBackImageUrl?: true
    idFrontImageUrl?: true
    autoRenew?: true
    darkMode?: true
    hasSeenOnboarding?: true
    idVerificationStatus?: true
    nextFreeRideAt?: true
    passwordResetExpires?: true
    passwordResetToken?: true
    preferredLanguage?: true
    premiumEndDate?: true
    premiumStartDate?: true
    referralCode?: true
    profileImageLocked?: true
    role?: true
    emailVerificationExpires?: true
    emailVerificationToken?: true
    isEmailVerified?: true
    hasUsedFreeTrial?: true
    isEligibleForReward?: true
    referralsCount?: true
    driverLicenseExpiryDate?: true
    homeAddress?: true
    homeLat?: true
    homeLng?: true
    workAddress?: true
    workLat?: true
    workLng?: true
  }

  export type UserMaxAggregateInputType = {
    name?: true
    email?: true
    phone?: true
    createdAt?: true
    gender?: true
    isVerified?: true
    password?: true
    updatedAt?: true
    id?: true
    birthDate?: true
    city?: true
    completedRides?: true
    genderPreference?: true
    rideSearchWindowDays?: true
    isPremium?: true
    joinDate?: true
    profileImage?: true
    rating?: true
    currentLat?: true
    currentLng?: true
    drivingLicenseUrl?: true
    idBackImageUrl?: true
    idFrontImageUrl?: true
    autoRenew?: true
    darkMode?: true
    hasSeenOnboarding?: true
    idVerificationStatus?: true
    nextFreeRideAt?: true
    passwordResetExpires?: true
    passwordResetToken?: true
    preferredLanguage?: true
    premiumEndDate?: true
    premiumStartDate?: true
    referralCode?: true
    profileImageLocked?: true
    role?: true
    emailVerificationExpires?: true
    emailVerificationToken?: true
    isEmailVerified?: true
    hasUsedFreeTrial?: true
    isEligibleForReward?: true
    referralsCount?: true
    driverLicenseExpiryDate?: true
    homeAddress?: true
    homeLat?: true
    homeLng?: true
    workAddress?: true
    workLat?: true
    workLng?: true
  }

  export type UserCountAggregateInputType = {
    name?: true
    email?: true
    phone?: true
    createdAt?: true
    gender?: true
    isVerified?: true
    password?: true
    updatedAt?: true
    id?: true
    birthDate?: true
    city?: true
    completedRides?: true
    genderPreference?: true
    rideSearchWindowDays?: true
    isPremium?: true
    joinDate?: true
    profileImage?: true
    rating?: true
    currentLat?: true
    currentLng?: true
    drivingLicenseUrl?: true
    idBackImageUrl?: true
    idFrontImageUrl?: true
    autoRenew?: true
    darkMode?: true
    hasSeenOnboarding?: true
    idVerificationStatus?: true
    nextFreeRideAt?: true
    passwordResetExpires?: true
    passwordResetToken?: true
    preferredLanguage?: true
    premiumEndDate?: true
    premiumStartDate?: true
    referralCode?: true
    profileImageLocked?: true
    role?: true
    emailVerificationExpires?: true
    emailVerificationToken?: true
    isEmailVerified?: true
    hasUsedFreeTrial?: true
    isEligibleForReward?: true
    referralsCount?: true
    driverLicenseExpiryDate?: true
    homeAddress?: true
    homeLat?: true
    homeLng?: true
    workAddress?: true
    workLat?: true
    workLng?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    name: string
    email: string
    phone: string
    createdAt: Date
    gender: string | null
    isVerified: boolean
    password: string
    updatedAt: Date
    id: string
    birthDate: Date | null
    city: string | null
    completedRides: number
    genderPreference: string
    rideSearchWindowDays: number
    isPremium: boolean
    joinDate: Date
    profileImage: string | null
    rating: number
    currentLat: number | null
    currentLng: number | null
    drivingLicenseUrl: string | null
    idBackImageUrl: string | null
    idFrontImageUrl: string | null
    autoRenew: boolean
    darkMode: boolean
    hasSeenOnboarding: boolean
    idVerificationStatus: $Enums.VerificationStatus
    nextFreeRideAt: Date | null
    passwordResetExpires: Date | null
    passwordResetToken: string | null
    preferredLanguage: string
    premiumEndDate: Date | null
    premiumStartDate: Date | null
    referralCode: string | null
    profileImageLocked: boolean
    role: string
    emailVerificationExpires: Date | null
    emailVerificationToken: string | null
    isEmailVerified: boolean
    hasUsedFreeTrial: boolean
    isEligibleForReward: boolean
    referralsCount: number
    driverLicenseExpiryDate: Date | null
    homeAddress: string | null
    homeLat: number | null
    homeLng: number | null
    workAddress: string | null
    workLat: number | null
    workLng: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    gender?: boolean
    isVerified?: boolean
    password?: boolean
    updatedAt?: boolean
    id?: boolean
    birthDate?: boolean
    city?: boolean
    completedRides?: boolean
    genderPreference?: boolean
    rideSearchWindowDays?: boolean
    isPremium?: boolean
    joinDate?: boolean
    profileImage?: boolean
    rating?: boolean
    currentLat?: boolean
    currentLng?: boolean
    drivingLicenseUrl?: boolean
    idBackImageUrl?: boolean
    idFrontImageUrl?: boolean
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: boolean
    nextFreeRideAt?: boolean
    passwordResetExpires?: boolean
    passwordResetToken?: boolean
    preferredLanguage?: boolean
    premiumEndDate?: boolean
    premiumStartDate?: boolean
    referralCode?: boolean
    profileImageLocked?: boolean
    role?: boolean
    emailVerificationExpires?: boolean
    emailVerificationToken?: boolean
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: boolean
    driverLicenseExpiryDate?: boolean
    homeAddress?: boolean
    homeLat?: boolean
    homeLng?: boolean
    workAddress?: boolean
    workLat?: boolean
    workLng?: boolean
    lastVisits?: boolean | User$lastVisitsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    initiatedInvitations?: boolean | User$initiatedInvitationsArgs<ExtArgs>
    car?: boolean | User$carArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    feedbacksGiven?: boolean | User$feedbacksGivenArgs<ExtArgs>
    feedbacksReceived?: boolean | User$feedbacksReceivedArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    offers?: boolean | User$offersArgs<ExtArgs>
    promoCodes?: boolean | User$promoCodesArgs<ExtArgs>
    referralReceived?: boolean | User$referralReceivedArgs<ExtArgs>
    referralsMade?: boolean | User$referralsMadeArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    rides?: boolean | User$ridesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    interests?: boolean | User$interestsArgs<ExtArgs>
    savedRoutes?: boolean | User$savedRoutesArgs<ExtArgs>
    scheduledRides?: boolean | User$scheduledRidesArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    stats?: boolean | User$statsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    gender?: boolean
    isVerified?: boolean
    password?: boolean
    updatedAt?: boolean
    id?: boolean
    birthDate?: boolean
    city?: boolean
    completedRides?: boolean
    genderPreference?: boolean
    rideSearchWindowDays?: boolean
    isPremium?: boolean
    joinDate?: boolean
    profileImage?: boolean
    rating?: boolean
    currentLat?: boolean
    currentLng?: boolean
    drivingLicenseUrl?: boolean
    idBackImageUrl?: boolean
    idFrontImageUrl?: boolean
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: boolean
    nextFreeRideAt?: boolean
    passwordResetExpires?: boolean
    passwordResetToken?: boolean
    preferredLanguage?: boolean
    premiumEndDate?: boolean
    premiumStartDate?: boolean
    referralCode?: boolean
    profileImageLocked?: boolean
    role?: boolean
    emailVerificationExpires?: boolean
    emailVerificationToken?: boolean
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: boolean
    driverLicenseExpiryDate?: boolean
    homeAddress?: boolean
    homeLat?: boolean
    homeLng?: boolean
    workAddress?: boolean
    workLat?: boolean
    workLng?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    name?: boolean
    email?: boolean
    phone?: boolean
    createdAt?: boolean
    gender?: boolean
    isVerified?: boolean
    password?: boolean
    updatedAt?: boolean
    id?: boolean
    birthDate?: boolean
    city?: boolean
    completedRides?: boolean
    genderPreference?: boolean
    rideSearchWindowDays?: boolean
    isPremium?: boolean
    joinDate?: boolean
    profileImage?: boolean
    rating?: boolean
    currentLat?: boolean
    currentLng?: boolean
    drivingLicenseUrl?: boolean
    idBackImageUrl?: boolean
    idFrontImageUrl?: boolean
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: boolean
    nextFreeRideAt?: boolean
    passwordResetExpires?: boolean
    passwordResetToken?: boolean
    preferredLanguage?: boolean
    premiumEndDate?: boolean
    premiumStartDate?: boolean
    referralCode?: boolean
    profileImageLocked?: boolean
    role?: boolean
    emailVerificationExpires?: boolean
    emailVerificationToken?: boolean
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: boolean
    driverLicenseExpiryDate?: boolean
    homeAddress?: boolean
    homeLat?: boolean
    homeLng?: boolean
    workAddress?: boolean
    workLat?: boolean
    workLng?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastVisits?: boolean | User$lastVisitsArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    initiatedInvitations?: boolean | User$initiatedInvitationsArgs<ExtArgs>
    car?: boolean | User$carArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    feedbacksGiven?: boolean | User$feedbacksGivenArgs<ExtArgs>
    feedbacksReceived?: boolean | User$feedbacksReceivedArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    offers?: boolean | User$offersArgs<ExtArgs>
    promoCodes?: boolean | User$promoCodesArgs<ExtArgs>
    referralReceived?: boolean | User$referralReceivedArgs<ExtArgs>
    referralsMade?: boolean | User$referralsMadeArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    rides?: boolean | User$ridesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    interests?: boolean | User$interestsArgs<ExtArgs>
    savedRoutes?: boolean | User$savedRoutesArgs<ExtArgs>
    scheduledRides?: boolean | User$scheduledRidesArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    stats?: boolean | User$statsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      lastVisits: Prisma.$AdminLastVisitPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      initiatedInvitations: Prisma.$GroupBookingInvitationPayload<ExtArgs>[]
      car: Prisma.$CarPayload<ExtArgs> | null
      chats: Prisma.$ChatMemberPayload<ExtArgs>[]
      feedbacksGiven: Prisma.$FeedbackPayload<ExtArgs>[]
      feedbacksReceived: Prisma.$FeedbackPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      promoCodes: Prisma.$PromoCodePayload<ExtArgs>[]
      referralReceived: Prisma.$ReferralPayload<ExtArgs> | null
      referralsMade: Prisma.$ReferralPayload<ExtArgs>[]
      reportsReceived: Prisma.$ReportPayload<ExtArgs>[]
      reportsMade: Prisma.$ReportPayload<ExtArgs>[]
      rides: Prisma.$RidePayload<ExtArgs>[]
      comments: Prisma.$RideCommentPayload<ExtArgs>[]
      interests: Prisma.$RideInterestPayload<ExtArgs>[]
      savedRoutes: Prisma.$SavedRoutePayload<ExtArgs>[]
      scheduledRides: Prisma.$ScheduledRidePayload<ExtArgs>[]
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
      stats: Prisma.$UserStatsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      email: string
      phone: string
      createdAt: Date
      gender: string | null
      isVerified: boolean
      password: string
      updatedAt: Date
      id: string
      birthDate: Date | null
      city: string | null
      completedRides: number
      genderPreference: string
      rideSearchWindowDays: number
      isPremium: boolean
      joinDate: Date
      profileImage: string | null
      rating: number
      currentLat: number | null
      currentLng: number | null
      drivingLicenseUrl: string | null
      idBackImageUrl: string | null
      idFrontImageUrl: string | null
      autoRenew: boolean
      darkMode: boolean
      hasSeenOnboarding: boolean
      idVerificationStatus: $Enums.VerificationStatus
      nextFreeRideAt: Date | null
      passwordResetExpires: Date | null
      passwordResetToken: string | null
      preferredLanguage: string
      premiumEndDate: Date | null
      premiumStartDate: Date | null
      referralCode: string | null
      profileImageLocked: boolean
      role: string
      emailVerificationExpires: Date | null
      emailVerificationToken: string | null
      isEmailVerified: boolean
      hasUsedFreeTrial: boolean
      isEligibleForReward: boolean
      referralsCount: number
      driverLicenseExpiryDate: Date | null
      homeAddress: string | null
      homeLat: number | null
      homeLng: number | null
      workAddress: string | null
      workLat: number | null
      workLng: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const userWithNameOnly = await prisma.user.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `name`
     * const userWithNameOnly = await prisma.user.createManyAndReturn({ 
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lastVisits<T extends User$lastVisitsArgs<ExtArgs> = {}>(args?: Subset<T, User$lastVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "findMany"> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    initiatedInvitations<T extends User$initiatedInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$initiatedInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    car<T extends User$carArgs<ExtArgs> = {}>(args?: Subset<T, User$carArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chats<T extends User$chatsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findMany"> | Null>
    feedbacksGiven<T extends User$feedbacksGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    feedbacksReceived<T extends User$feedbacksReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    offers<T extends User$offersArgs<ExtArgs> = {}>(args?: Subset<T, User$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany"> | Null>
    promoCodes<T extends User$promoCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$promoCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany"> | Null>
    referralReceived<T extends User$referralReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$referralReceivedArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    referralsMade<T extends User$referralsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany"> | Null>
    reportsReceived<T extends User$reportsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    reportsMade<T extends User$reportsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    rides<T extends User$ridesArgs<ExtArgs> = {}>(args?: Subset<T, User$ridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findMany"> | Null>
    interests<T extends User$interestsArgs<ExtArgs> = {}>(args?: Subset<T, User$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "findMany"> | Null>
    savedRoutes<T extends User$savedRoutesArgs<ExtArgs> = {}>(args?: Subset<T, User$savedRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "findMany"> | Null>
    scheduledRides<T extends User$scheduledRidesArgs<ExtArgs> = {}>(args?: Subset<T, User$scheduledRidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    stats<T extends User$statsArgs<ExtArgs> = {}>(args?: Subset<T, User$statsArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly password: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly id: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly city: FieldRef<"User", 'String'>
    readonly completedRides: FieldRef<"User", 'Int'>
    readonly genderPreference: FieldRef<"User", 'String'>
    readonly rideSearchWindowDays: FieldRef<"User", 'Int'>
    readonly isPremium: FieldRef<"User", 'Boolean'>
    readonly joinDate: FieldRef<"User", 'DateTime'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly rating: FieldRef<"User", 'Float'>
    readonly currentLat: FieldRef<"User", 'Float'>
    readonly currentLng: FieldRef<"User", 'Float'>
    readonly drivingLicenseUrl: FieldRef<"User", 'String'>
    readonly idBackImageUrl: FieldRef<"User", 'String'>
    readonly idFrontImageUrl: FieldRef<"User", 'String'>
    readonly autoRenew: FieldRef<"User", 'Boolean'>
    readonly darkMode: FieldRef<"User", 'Boolean'>
    readonly hasSeenOnboarding: FieldRef<"User", 'Boolean'>
    readonly idVerificationStatus: FieldRef<"User", 'VerificationStatus'>
    readonly nextFreeRideAt: FieldRef<"User", 'DateTime'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly preferredLanguage: FieldRef<"User", 'String'>
    readonly premiumEndDate: FieldRef<"User", 'DateTime'>
    readonly premiumStartDate: FieldRef<"User", 'DateTime'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly profileImageLocked: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly emailVerificationExpires: FieldRef<"User", 'DateTime'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly hasUsedFreeTrial: FieldRef<"User", 'Boolean'>
    readonly isEligibleForReward: FieldRef<"User", 'Boolean'>
    readonly referralsCount: FieldRef<"User", 'Int'>
    readonly driverLicenseExpiryDate: FieldRef<"User", 'DateTime'>
    readonly homeAddress: FieldRef<"User", 'String'>
    readonly homeLat: FieldRef<"User", 'Float'>
    readonly homeLng: FieldRef<"User", 'Float'>
    readonly workAddress: FieldRef<"User", 'String'>
    readonly workLat: FieldRef<"User", 'Float'>
    readonly workLng: FieldRef<"User", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.lastVisits
   */
  export type User$lastVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    where?: AdminLastVisitWhereInput
    orderBy?: AdminLastVisitOrderByWithRelationInput | AdminLastVisitOrderByWithRelationInput[]
    cursor?: AdminLastVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminLastVisitScalarFieldEnum | AdminLastVisitScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.initiatedInvitations
   */
  export type User$initiatedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    where?: GroupBookingInvitationWhereInput
    orderBy?: GroupBookingInvitationOrderByWithRelationInput | GroupBookingInvitationOrderByWithRelationInput[]
    cursor?: GroupBookingInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupBookingInvitationScalarFieldEnum | GroupBookingInvitationScalarFieldEnum[]
  }

  /**
   * User.car
   */
  export type User$carArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    where?: CarWhereInput
  }

  /**
   * User.chats
   */
  export type User$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    where?: ChatMemberWhereInput
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    cursor?: ChatMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * User.feedbacksGiven
   */
  export type User$feedbacksGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.feedbacksReceived
   */
  export type User$feedbacksReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.offers
   */
  export type User$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * User.promoCodes
   */
  export type User$promoCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    cursor?: PromoCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * User.referralReceived
   */
  export type User$referralReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
  }

  /**
   * User.referralsMade
   */
  export type User$referralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.reportsReceived
   */
  export type User$reportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.reportsMade
   */
  export type User$reportsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.rides
   */
  export type User$ridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    cursor?: RideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    where?: RideCommentWhereInput
    orderBy?: RideCommentOrderByWithRelationInput | RideCommentOrderByWithRelationInput[]
    cursor?: RideCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideCommentScalarFieldEnum | RideCommentScalarFieldEnum[]
  }

  /**
   * User.interests
   */
  export type User$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    where?: RideInterestWhereInput
    orderBy?: RideInterestOrderByWithRelationInput | RideInterestOrderByWithRelationInput[]
    cursor?: RideInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideInterestScalarFieldEnum | RideInterestScalarFieldEnum[]
  }

  /**
   * User.savedRoutes
   */
  export type User$savedRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    where?: SavedRouteWhereInput
    orderBy?: SavedRouteOrderByWithRelationInput | SavedRouteOrderByWithRelationInput[]
    cursor?: SavedRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedRouteScalarFieldEnum | SavedRouteScalarFieldEnum[]
  }

  /**
   * User.scheduledRides
   */
  export type User$scheduledRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    where?: ScheduledRideWhereInput
    orderBy?: ScheduledRideOrderByWithRelationInput | ScheduledRideOrderByWithRelationInput[]
    cursor?: ScheduledRideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledRideScalarFieldEnum | ScheduledRideScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.stats
   */
  export type User$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    where?: UserStatsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Car
   */

  export type AggregateCar = {
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  export type CarAvgAggregateOutputType = {
    year: number | null
  }

  export type CarSumAggregateOutputType = {
    year: number | null
  }

  export type CarMinAggregateOutputType = {
    id: string | null
    brand: string | null
    model: string | null
    year: number | null
    color: string | null
    plate: string | null
    licensePhoto: string | null
    isVerified: boolean | null
    userId: string | null
    createdAt: Date | null
    verificationStatus: $Enums.VerificationStatus | null
    licenseExpiryDate: Date | null
  }

  export type CarMaxAggregateOutputType = {
    id: string | null
    brand: string | null
    model: string | null
    year: number | null
    color: string | null
    plate: string | null
    licensePhoto: string | null
    isVerified: boolean | null
    userId: string | null
    createdAt: Date | null
    verificationStatus: $Enums.VerificationStatus | null
    licenseExpiryDate: Date | null
  }

  export type CarCountAggregateOutputType = {
    id: number
    brand: number
    model: number
    year: number
    color: number
    plate: number
    licensePhoto: number
    isVerified: number
    userId: number
    createdAt: number
    verificationStatus: number
    licenseExpiryDate: number
    _all: number
  }


  export type CarAvgAggregateInputType = {
    year?: true
  }

  export type CarSumAggregateInputType = {
    year?: true
  }

  export type CarMinAggregateInputType = {
    id?: true
    brand?: true
    model?: true
    year?: true
    color?: true
    plate?: true
    licensePhoto?: true
    isVerified?: true
    userId?: true
    createdAt?: true
    verificationStatus?: true
    licenseExpiryDate?: true
  }

  export type CarMaxAggregateInputType = {
    id?: true
    brand?: true
    model?: true
    year?: true
    color?: true
    plate?: true
    licensePhoto?: true
    isVerified?: true
    userId?: true
    createdAt?: true
    verificationStatus?: true
    licenseExpiryDate?: true
  }

  export type CarCountAggregateInputType = {
    id?: true
    brand?: true
    model?: true
    year?: true
    color?: true
    plate?: true
    licensePhoto?: true
    isVerified?: true
    userId?: true
    createdAt?: true
    verificationStatus?: true
    licenseExpiryDate?: true
    _all?: true
  }

  export type CarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Car to aggregate.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cars
    **/
    _count?: true | CarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarMaxAggregateInputType
  }

  export type GetCarAggregateType<T extends CarAggregateArgs> = {
        [P in keyof T & keyof AggregateCar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCar[P]>
      : GetScalarType<T[P], AggregateCar[P]>
  }




  export type CarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarWhereInput
    orderBy?: CarOrderByWithAggregationInput | CarOrderByWithAggregationInput[]
    by: CarScalarFieldEnum[] | CarScalarFieldEnum
    having?: CarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarCountAggregateInputType | true
    _avg?: CarAvgAggregateInputType
    _sum?: CarSumAggregateInputType
    _min?: CarMinAggregateInputType
    _max?: CarMaxAggregateInputType
  }

  export type CarGroupByOutputType = {
    id: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto: string | null
    isVerified: boolean
    userId: string
    createdAt: Date
    verificationStatus: $Enums.VerificationStatus
    licenseExpiryDate: Date | null
    _count: CarCountAggregateOutputType | null
    _avg: CarAvgAggregateOutputType | null
    _sum: CarSumAggregateOutputType | null
    _min: CarMinAggregateOutputType | null
    _max: CarMaxAggregateOutputType | null
  }

  type GetCarGroupByPayload<T extends CarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarGroupByOutputType[P]>
            : GetScalarType<T[P], CarGroupByOutputType[P]>
        }
      >
    >


  export type CarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    color?: boolean
    plate?: boolean
    licensePhoto?: boolean
    isVerified?: boolean
    userId?: boolean
    createdAt?: boolean
    verificationStatus?: boolean
    licenseExpiryDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    licenseHistory?: boolean | Car$licenseHistoryArgs<ExtArgs>
    rides?: boolean | Car$ridesArgs<ExtArgs>
    _count?: boolean | CarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["car"]>

  export type CarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    color?: boolean
    plate?: boolean
    licensePhoto?: boolean
    isVerified?: boolean
    userId?: boolean
    createdAt?: boolean
    verificationStatus?: boolean
    licenseExpiryDate?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["car"]>

  export type CarSelectScalar = {
    id?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    color?: boolean
    plate?: boolean
    licensePhoto?: boolean
    isVerified?: boolean
    userId?: boolean
    createdAt?: boolean
    verificationStatus?: boolean
    licenseExpiryDate?: boolean
  }

  export type CarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    licenseHistory?: boolean | Car$licenseHistoryArgs<ExtArgs>
    rides?: boolean | Car$ridesArgs<ExtArgs>
    _count?: boolean | CarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Car"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      licenseHistory: Prisma.$CarLicenseHistoryPayload<ExtArgs>[]
      rides: Prisma.$RidePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      brand: string
      model: string
      year: number
      color: string
      plate: string
      licensePhoto: string | null
      isVerified: boolean
      userId: string
      createdAt: Date
      verificationStatus: $Enums.VerificationStatus
      licenseExpiryDate: Date | null
    }, ExtArgs["result"]["car"]>
    composites: {}
  }

  type CarGetPayload<S extends boolean | null | undefined | CarDefaultArgs> = $Result.GetResult<Prisma.$CarPayload, S>

  type CarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CarCountAggregateInputType | true
    }

  export interface CarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Car'], meta: { name: 'Car' } }
    /**
     * Find zero or one Car that matches the filter.
     * @param {CarFindUniqueArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarFindUniqueArgs>(args: SelectSubset<T, CarFindUniqueArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Car that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CarFindUniqueOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarFindUniqueOrThrowArgs>(args: SelectSubset<T, CarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Car that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarFindFirstArgs>(args?: SelectSubset<T, CarFindFirstArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Car that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindFirstOrThrowArgs} args - Arguments to find a Car
     * @example
     * // Get one Car
     * const car = await prisma.car.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarFindFirstOrThrowArgs>(args?: SelectSubset<T, CarFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cars
     * const cars = await prisma.car.findMany()
     * 
     * // Get first 10 Cars
     * const cars = await prisma.car.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carWithIdOnly = await prisma.car.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarFindManyArgs>(args?: SelectSubset<T, CarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Car.
     * @param {CarCreateArgs} args - Arguments to create a Car.
     * @example
     * // Create one Car
     * const Car = await prisma.car.create({
     *   data: {
     *     // ... data to create a Car
     *   }
     * })
     * 
     */
    create<T extends CarCreateArgs>(args: SelectSubset<T, CarCreateArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cars.
     * @param {CarCreateManyArgs} args - Arguments to create many Cars.
     * @example
     * // Create many Cars
     * const car = await prisma.car.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarCreateManyArgs>(args?: SelectSubset<T, CarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cars and returns the data saved in the database.
     * @param {CarCreateManyAndReturnArgs} args - Arguments to create many Cars.
     * @example
     * // Create many Cars
     * const car = await prisma.car.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cars and only return the `id`
     * const carWithIdOnly = await prisma.car.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarCreateManyAndReturnArgs>(args?: SelectSubset<T, CarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Car.
     * @param {CarDeleteArgs} args - Arguments to delete one Car.
     * @example
     * // Delete one Car
     * const Car = await prisma.car.delete({
     *   where: {
     *     // ... filter to delete one Car
     *   }
     * })
     * 
     */
    delete<T extends CarDeleteArgs>(args: SelectSubset<T, CarDeleteArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Car.
     * @param {CarUpdateArgs} args - Arguments to update one Car.
     * @example
     * // Update one Car
     * const car = await prisma.car.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarUpdateArgs>(args: SelectSubset<T, CarUpdateArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cars.
     * @param {CarDeleteManyArgs} args - Arguments to filter Cars to delete.
     * @example
     * // Delete a few Cars
     * const { count } = await prisma.car.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarDeleteManyArgs>(args?: SelectSubset<T, CarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cars
     * const car = await prisma.car.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarUpdateManyArgs>(args: SelectSubset<T, CarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Car.
     * @param {CarUpsertArgs} args - Arguments to update or create a Car.
     * @example
     * // Update or create a Car
     * const car = await prisma.car.upsert({
     *   create: {
     *     // ... data to create a Car
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Car we want to update
     *   }
     * })
     */
    upsert<T extends CarUpsertArgs>(args: SelectSubset<T, CarUpsertArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarCountArgs} args - Arguments to filter Cars to count.
     * @example
     * // Count the number of Cars
     * const count = await prisma.car.count({
     *   where: {
     *     // ... the filter for the Cars we want to count
     *   }
     * })
    **/
    count<T extends CarCountArgs>(
      args?: Subset<T, CarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarAggregateArgs>(args: Subset<T, CarAggregateArgs>): Prisma.PrismaPromise<GetCarAggregateType<T>>

    /**
     * Group by Car.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarGroupByArgs['orderBy'] }
        : { orderBy?: CarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Car model
   */
  readonly fields: CarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Car.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    licenseHistory<T extends Car$licenseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Car$licenseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    rides<T extends Car$ridesArgs<ExtArgs> = {}>(args?: Subset<T, Car$ridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Car model
   */ 
  interface CarFieldRefs {
    readonly id: FieldRef<"Car", 'String'>
    readonly brand: FieldRef<"Car", 'String'>
    readonly model: FieldRef<"Car", 'String'>
    readonly year: FieldRef<"Car", 'Int'>
    readonly color: FieldRef<"Car", 'String'>
    readonly plate: FieldRef<"Car", 'String'>
    readonly licensePhoto: FieldRef<"Car", 'String'>
    readonly isVerified: FieldRef<"Car", 'Boolean'>
    readonly userId: FieldRef<"Car", 'String'>
    readonly createdAt: FieldRef<"Car", 'DateTime'>
    readonly verificationStatus: FieldRef<"Car", 'VerificationStatus'>
    readonly licenseExpiryDate: FieldRef<"Car", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Car findUnique
   */
  export type CarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car findUniqueOrThrow
   */
  export type CarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car findFirst
   */
  export type CarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car findFirstOrThrow
   */
  export type CarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Car to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cars.
     */
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car findMany
   */
  export type CarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter, which Cars to fetch.
     */
    where?: CarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cars to fetch.
     */
    orderBy?: CarOrderByWithRelationInput | CarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cars.
     */
    cursor?: CarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cars.
     */
    skip?: number
    distinct?: CarScalarFieldEnum | CarScalarFieldEnum[]
  }

  /**
   * Car create
   */
  export type CarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The data needed to create a Car.
     */
    data: XOR<CarCreateInput, CarUncheckedCreateInput>
  }

  /**
   * Car createMany
   */
  export type CarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cars.
     */
    data: CarCreateManyInput | CarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Car createManyAndReturn
   */
  export type CarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cars.
     */
    data: CarCreateManyInput | CarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Car update
   */
  export type CarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The data needed to update a Car.
     */
    data: XOR<CarUpdateInput, CarUncheckedUpdateInput>
    /**
     * Choose, which Car to update.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car updateMany
   */
  export type CarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cars.
     */
    data: XOR<CarUpdateManyMutationInput, CarUncheckedUpdateManyInput>
    /**
     * Filter which Cars to update
     */
    where?: CarWhereInput
  }

  /**
   * Car upsert
   */
  export type CarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * The filter to search for the Car to update in case it exists.
     */
    where: CarWhereUniqueInput
    /**
     * In case the Car found by the `where` argument doesn't exist, create a new Car with this data.
     */
    create: XOR<CarCreateInput, CarUncheckedCreateInput>
    /**
     * In case the Car was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarUpdateInput, CarUncheckedUpdateInput>
  }

  /**
   * Car delete
   */
  export type CarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    /**
     * Filter which Car to delete.
     */
    where: CarWhereUniqueInput
  }

  /**
   * Car deleteMany
   */
  export type CarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cars to delete
     */
    where?: CarWhereInput
  }

  /**
   * Car.licenseHistory
   */
  export type Car$licenseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    where?: CarLicenseHistoryWhereInput
    orderBy?: CarLicenseHistoryOrderByWithRelationInput | CarLicenseHistoryOrderByWithRelationInput[]
    cursor?: CarLicenseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CarLicenseHistoryScalarFieldEnum | CarLicenseHistoryScalarFieldEnum[]
  }

  /**
   * Car.rides
   */
  export type Car$ridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    cursor?: RideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Car without action
   */
  export type CarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
  }


  /**
   * Model CarLicenseHistory
   */

  export type AggregateCarLicenseHistory = {
    _count: CarLicenseHistoryCountAggregateOutputType | null
    _min: CarLicenseHistoryMinAggregateOutputType | null
    _max: CarLicenseHistoryMaxAggregateOutputType | null
  }

  export type CarLicenseHistoryMinAggregateOutputType = {
    id: string | null
    photoUrl: string | null
    status: $Enums.VerificationStatus | null
    notes: string | null
    createdAt: Date | null
    carId: string | null
  }

  export type CarLicenseHistoryMaxAggregateOutputType = {
    id: string | null
    photoUrl: string | null
    status: $Enums.VerificationStatus | null
    notes: string | null
    createdAt: Date | null
    carId: string | null
  }

  export type CarLicenseHistoryCountAggregateOutputType = {
    id: number
    photoUrl: number
    status: number
    notes: number
    createdAt: number
    carId: number
    _all: number
  }


  export type CarLicenseHistoryMinAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    notes?: true
    createdAt?: true
    carId?: true
  }

  export type CarLicenseHistoryMaxAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    notes?: true
    createdAt?: true
    carId?: true
  }

  export type CarLicenseHistoryCountAggregateInputType = {
    id?: true
    photoUrl?: true
    status?: true
    notes?: true
    createdAt?: true
    carId?: true
    _all?: true
  }

  export type CarLicenseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarLicenseHistory to aggregate.
     */
    where?: CarLicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarLicenseHistories to fetch.
     */
    orderBy?: CarLicenseHistoryOrderByWithRelationInput | CarLicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CarLicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarLicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarLicenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CarLicenseHistories
    **/
    _count?: true | CarLicenseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarLicenseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarLicenseHistoryMaxAggregateInputType
  }

  export type GetCarLicenseHistoryAggregateType<T extends CarLicenseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCarLicenseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarLicenseHistory[P]>
      : GetScalarType<T[P], AggregateCarLicenseHistory[P]>
  }




  export type CarLicenseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CarLicenseHistoryWhereInput
    orderBy?: CarLicenseHistoryOrderByWithAggregationInput | CarLicenseHistoryOrderByWithAggregationInput[]
    by: CarLicenseHistoryScalarFieldEnum[] | CarLicenseHistoryScalarFieldEnum
    having?: CarLicenseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarLicenseHistoryCountAggregateInputType | true
    _min?: CarLicenseHistoryMinAggregateInputType
    _max?: CarLicenseHistoryMaxAggregateInputType
  }

  export type CarLicenseHistoryGroupByOutputType = {
    id: string
    photoUrl: string
    status: $Enums.VerificationStatus
    notes: string | null
    createdAt: Date
    carId: string
    _count: CarLicenseHistoryCountAggregateOutputType | null
    _min: CarLicenseHistoryMinAggregateOutputType | null
    _max: CarLicenseHistoryMaxAggregateOutputType | null
  }

  type GetCarLicenseHistoryGroupByPayload<T extends CarLicenseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CarLicenseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarLicenseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarLicenseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CarLicenseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CarLicenseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    photoUrl?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    carId?: boolean
    car?: boolean | CarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carLicenseHistory"]>

  export type CarLicenseHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    photoUrl?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    carId?: boolean
    car?: boolean | CarDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["carLicenseHistory"]>

  export type CarLicenseHistorySelectScalar = {
    id?: boolean
    photoUrl?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    carId?: boolean
  }

  export type CarLicenseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    car?: boolean | CarDefaultArgs<ExtArgs>
  }
  export type CarLicenseHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    car?: boolean | CarDefaultArgs<ExtArgs>
  }

  export type $CarLicenseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CarLicenseHistory"
    objects: {
      car: Prisma.$CarPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      photoUrl: string
      status: $Enums.VerificationStatus
      notes: string | null
      createdAt: Date
      carId: string
    }, ExtArgs["result"]["carLicenseHistory"]>
    composites: {}
  }

  type CarLicenseHistoryGetPayload<S extends boolean | null | undefined | CarLicenseHistoryDefaultArgs> = $Result.GetResult<Prisma.$CarLicenseHistoryPayload, S>

  type CarLicenseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CarLicenseHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CarLicenseHistoryCountAggregateInputType | true
    }

  export interface CarLicenseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CarLicenseHistory'], meta: { name: 'CarLicenseHistory' } }
    /**
     * Find zero or one CarLicenseHistory that matches the filter.
     * @param {CarLicenseHistoryFindUniqueArgs} args - Arguments to find a CarLicenseHistory
     * @example
     * // Get one CarLicenseHistory
     * const carLicenseHistory = await prisma.carLicenseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CarLicenseHistoryFindUniqueArgs>(args: SelectSubset<T, CarLicenseHistoryFindUniqueArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CarLicenseHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CarLicenseHistoryFindUniqueOrThrowArgs} args - Arguments to find a CarLicenseHistory
     * @example
     * // Get one CarLicenseHistory
     * const carLicenseHistory = await prisma.carLicenseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CarLicenseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CarLicenseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CarLicenseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarLicenseHistoryFindFirstArgs} args - Arguments to find a CarLicenseHistory
     * @example
     * // Get one CarLicenseHistory
     * const carLicenseHistory = await prisma.carLicenseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CarLicenseHistoryFindFirstArgs>(args?: SelectSubset<T, CarLicenseHistoryFindFirstArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CarLicenseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarLicenseHistoryFindFirstOrThrowArgs} args - Arguments to find a CarLicenseHistory
     * @example
     * // Get one CarLicenseHistory
     * const carLicenseHistory = await prisma.carLicenseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CarLicenseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CarLicenseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CarLicenseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarLicenseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CarLicenseHistories
     * const carLicenseHistories = await prisma.carLicenseHistory.findMany()
     * 
     * // Get first 10 CarLicenseHistories
     * const carLicenseHistories = await prisma.carLicenseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carLicenseHistoryWithIdOnly = await prisma.carLicenseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CarLicenseHistoryFindManyArgs>(args?: SelectSubset<T, CarLicenseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CarLicenseHistory.
     * @param {CarLicenseHistoryCreateArgs} args - Arguments to create a CarLicenseHistory.
     * @example
     * // Create one CarLicenseHistory
     * const CarLicenseHistory = await prisma.carLicenseHistory.create({
     *   data: {
     *     // ... data to create a CarLicenseHistory
     *   }
     * })
     * 
     */
    create<T extends CarLicenseHistoryCreateArgs>(args: SelectSubset<T, CarLicenseHistoryCreateArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CarLicenseHistories.
     * @param {CarLicenseHistoryCreateManyArgs} args - Arguments to create many CarLicenseHistories.
     * @example
     * // Create many CarLicenseHistories
     * const carLicenseHistory = await prisma.carLicenseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CarLicenseHistoryCreateManyArgs>(args?: SelectSubset<T, CarLicenseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CarLicenseHistories and returns the data saved in the database.
     * @param {CarLicenseHistoryCreateManyAndReturnArgs} args - Arguments to create many CarLicenseHistories.
     * @example
     * // Create many CarLicenseHistories
     * const carLicenseHistory = await prisma.carLicenseHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CarLicenseHistories and only return the `id`
     * const carLicenseHistoryWithIdOnly = await prisma.carLicenseHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CarLicenseHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CarLicenseHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CarLicenseHistory.
     * @param {CarLicenseHistoryDeleteArgs} args - Arguments to delete one CarLicenseHistory.
     * @example
     * // Delete one CarLicenseHistory
     * const CarLicenseHistory = await prisma.carLicenseHistory.delete({
     *   where: {
     *     // ... filter to delete one CarLicenseHistory
     *   }
     * })
     * 
     */
    delete<T extends CarLicenseHistoryDeleteArgs>(args: SelectSubset<T, CarLicenseHistoryDeleteArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CarLicenseHistory.
     * @param {CarLicenseHistoryUpdateArgs} args - Arguments to update one CarLicenseHistory.
     * @example
     * // Update one CarLicenseHistory
     * const carLicenseHistory = await prisma.carLicenseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CarLicenseHistoryUpdateArgs>(args: SelectSubset<T, CarLicenseHistoryUpdateArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CarLicenseHistories.
     * @param {CarLicenseHistoryDeleteManyArgs} args - Arguments to filter CarLicenseHistories to delete.
     * @example
     * // Delete a few CarLicenseHistories
     * const { count } = await prisma.carLicenseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CarLicenseHistoryDeleteManyArgs>(args?: SelectSubset<T, CarLicenseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CarLicenseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarLicenseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CarLicenseHistories
     * const carLicenseHistory = await prisma.carLicenseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CarLicenseHistoryUpdateManyArgs>(args: SelectSubset<T, CarLicenseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CarLicenseHistory.
     * @param {CarLicenseHistoryUpsertArgs} args - Arguments to update or create a CarLicenseHistory.
     * @example
     * // Update or create a CarLicenseHistory
     * const carLicenseHistory = await prisma.carLicenseHistory.upsert({
     *   create: {
     *     // ... data to create a CarLicenseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CarLicenseHistory we want to update
     *   }
     * })
     */
    upsert<T extends CarLicenseHistoryUpsertArgs>(args: SelectSubset<T, CarLicenseHistoryUpsertArgs<ExtArgs>>): Prisma__CarLicenseHistoryClient<$Result.GetResult<Prisma.$CarLicenseHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CarLicenseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarLicenseHistoryCountArgs} args - Arguments to filter CarLicenseHistories to count.
     * @example
     * // Count the number of CarLicenseHistories
     * const count = await prisma.carLicenseHistory.count({
     *   where: {
     *     // ... the filter for the CarLicenseHistories we want to count
     *   }
     * })
    **/
    count<T extends CarLicenseHistoryCountArgs>(
      args?: Subset<T, CarLicenseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarLicenseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CarLicenseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarLicenseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarLicenseHistoryAggregateArgs>(args: Subset<T, CarLicenseHistoryAggregateArgs>): Prisma.PrismaPromise<GetCarLicenseHistoryAggregateType<T>>

    /**
     * Group by CarLicenseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarLicenseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarLicenseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarLicenseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CarLicenseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarLicenseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarLicenseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CarLicenseHistory model
   */
  readonly fields: CarLicenseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CarLicenseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CarLicenseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    car<T extends CarDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CarDefaultArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CarLicenseHistory model
   */ 
  interface CarLicenseHistoryFieldRefs {
    readonly id: FieldRef<"CarLicenseHistory", 'String'>
    readonly photoUrl: FieldRef<"CarLicenseHistory", 'String'>
    readonly status: FieldRef<"CarLicenseHistory", 'VerificationStatus'>
    readonly notes: FieldRef<"CarLicenseHistory", 'String'>
    readonly createdAt: FieldRef<"CarLicenseHistory", 'DateTime'>
    readonly carId: FieldRef<"CarLicenseHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CarLicenseHistory findUnique
   */
  export type CarLicenseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CarLicenseHistory to fetch.
     */
    where: CarLicenseHistoryWhereUniqueInput
  }

  /**
   * CarLicenseHistory findUniqueOrThrow
   */
  export type CarLicenseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CarLicenseHistory to fetch.
     */
    where: CarLicenseHistoryWhereUniqueInput
  }

  /**
   * CarLicenseHistory findFirst
   */
  export type CarLicenseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CarLicenseHistory to fetch.
     */
    where?: CarLicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarLicenseHistories to fetch.
     */
    orderBy?: CarLicenseHistoryOrderByWithRelationInput | CarLicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarLicenseHistories.
     */
    cursor?: CarLicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarLicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarLicenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarLicenseHistories.
     */
    distinct?: CarLicenseHistoryScalarFieldEnum | CarLicenseHistoryScalarFieldEnum[]
  }

  /**
   * CarLicenseHistory findFirstOrThrow
   */
  export type CarLicenseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CarLicenseHistory to fetch.
     */
    where?: CarLicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarLicenseHistories to fetch.
     */
    orderBy?: CarLicenseHistoryOrderByWithRelationInput | CarLicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CarLicenseHistories.
     */
    cursor?: CarLicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarLicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarLicenseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CarLicenseHistories.
     */
    distinct?: CarLicenseHistoryScalarFieldEnum | CarLicenseHistoryScalarFieldEnum[]
  }

  /**
   * CarLicenseHistory findMany
   */
  export type CarLicenseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CarLicenseHistories to fetch.
     */
    where?: CarLicenseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CarLicenseHistories to fetch.
     */
    orderBy?: CarLicenseHistoryOrderByWithRelationInput | CarLicenseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CarLicenseHistories.
     */
    cursor?: CarLicenseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CarLicenseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CarLicenseHistories.
     */
    skip?: number
    distinct?: CarLicenseHistoryScalarFieldEnum | CarLicenseHistoryScalarFieldEnum[]
  }

  /**
   * CarLicenseHistory create
   */
  export type CarLicenseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CarLicenseHistory.
     */
    data: XOR<CarLicenseHistoryCreateInput, CarLicenseHistoryUncheckedCreateInput>
  }

  /**
   * CarLicenseHistory createMany
   */
  export type CarLicenseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CarLicenseHistories.
     */
    data: CarLicenseHistoryCreateManyInput | CarLicenseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CarLicenseHistory createManyAndReturn
   */
  export type CarLicenseHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CarLicenseHistories.
     */
    data: CarLicenseHistoryCreateManyInput | CarLicenseHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CarLicenseHistory update
   */
  export type CarLicenseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CarLicenseHistory.
     */
    data: XOR<CarLicenseHistoryUpdateInput, CarLicenseHistoryUncheckedUpdateInput>
    /**
     * Choose, which CarLicenseHistory to update.
     */
    where: CarLicenseHistoryWhereUniqueInput
  }

  /**
   * CarLicenseHistory updateMany
   */
  export type CarLicenseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CarLicenseHistories.
     */
    data: XOR<CarLicenseHistoryUpdateManyMutationInput, CarLicenseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CarLicenseHistories to update
     */
    where?: CarLicenseHistoryWhereInput
  }

  /**
   * CarLicenseHistory upsert
   */
  export type CarLicenseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CarLicenseHistory to update in case it exists.
     */
    where: CarLicenseHistoryWhereUniqueInput
    /**
     * In case the CarLicenseHistory found by the `where` argument doesn't exist, create a new CarLicenseHistory with this data.
     */
    create: XOR<CarLicenseHistoryCreateInput, CarLicenseHistoryUncheckedCreateInput>
    /**
     * In case the CarLicenseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CarLicenseHistoryUpdateInput, CarLicenseHistoryUncheckedUpdateInput>
  }

  /**
   * CarLicenseHistory delete
   */
  export type CarLicenseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
    /**
     * Filter which CarLicenseHistory to delete.
     */
    where: CarLicenseHistoryWhereUniqueInput
  }

  /**
   * CarLicenseHistory deleteMany
   */
  export type CarLicenseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CarLicenseHistories to delete
     */
    where?: CarLicenseHistoryWhereInput
  }

  /**
   * CarLicenseHistory without action
   */
  export type CarLicenseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CarLicenseHistory
     */
    select?: CarLicenseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarLicenseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Ride
   */

  export type AggregateRide = {
    _count: RideCountAggregateOutputType | null
    _avg: RideAvgAggregateOutputType | null
    _sum: RideSumAggregateOutputType | null
    _min: RideMinAggregateOutputType | null
    _max: RideMaxAggregateOutputType | null
  }

  export type RideAvgAggregateOutputType = {
    seats: number | null
    price: number | null
    receiptPrice: number | null
    etaMinutes: number | null
    destinationLat: number | null
    destinationLng: number | null
    originLat: number | null
    originLng: number | null
  }

  export type RideSumAggregateOutputType = {
    seats: number | null
    price: number | null
    receiptPrice: number | null
    etaMinutes: number | null
    destinationLat: number | null
    destinationLng: number | null
    originLat: number | null
    originLng: number | null
  }

  export type RideMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    carId: string | null
    carInfo: string | null
    serviceType: string | null
    seats: number | null
    price: number | null
    receiptPrice: number | null
    renterScreenshotUrl: string | null
    additionalInfo: string | null
    createdAt: Date | null
    startedAt: Date | null
    arrivedAt: Date | null
    time: Date | null
    isTimeArranged: boolean | null
    etaMinutes: number | null
    destination: string | null
    origin: string | null
    fromCity: string | null
    fromSuburb: string | null
    toCity: string | null
    toSuburb: string | null
    fromCityNorm: string | null
    fromSuburbNorm: string | null
    toCityNorm: string | null
    toSuburbNorm: string | null
    rideType: string | null
    isRequest: boolean | null
    isVerified: boolean | null
    isAnonymous: boolean | null
    status: $Enums.RideStatus | null
    allowedGender: string | null
    destinationLat: number | null
    destinationLng: number | null
    originLat: number | null
    originLng: number | null
    polyline: string | null
    scheduledRideId: string | null
  }

  export type RideMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    carId: string | null
    carInfo: string | null
    serviceType: string | null
    seats: number | null
    price: number | null
    receiptPrice: number | null
    renterScreenshotUrl: string | null
    additionalInfo: string | null
    createdAt: Date | null
    startedAt: Date | null
    arrivedAt: Date | null
    time: Date | null
    isTimeArranged: boolean | null
    etaMinutes: number | null
    destination: string | null
    origin: string | null
    fromCity: string | null
    fromSuburb: string | null
    toCity: string | null
    toSuburb: string | null
    fromCityNorm: string | null
    fromSuburbNorm: string | null
    toCityNorm: string | null
    toSuburbNorm: string | null
    rideType: string | null
    isRequest: boolean | null
    isVerified: boolean | null
    isAnonymous: boolean | null
    status: $Enums.RideStatus | null
    allowedGender: string | null
    destinationLat: number | null
    destinationLng: number | null
    originLat: number | null
    originLng: number | null
    polyline: string | null
    scheduledRideId: string | null
  }

  export type RideCountAggregateOutputType = {
    id: number
    driverId: number
    carId: number
    carInfo: number
    serviceType: number
    seats: number
    price: number
    receiptPrice: number
    renterScreenshotUrl: number
    additionalInfo: number
    createdAt: number
    startedAt: number
    arrivedAt: number
    time: number
    isTimeArranged: number
    etaMinutes: number
    destination: number
    origin: number
    fromCity: number
    fromSuburb: number
    toCity: number
    toSuburb: number
    fromCityNorm: number
    fromSuburbNorm: number
    toCityNorm: number
    toSuburbNorm: number
    rideType: number
    isRequest: number
    isVerified: number
    isAnonymous: number
    status: number
    allowedGender: number
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline: number
    scheduledRideId: number
    _all: number
  }


  export type RideAvgAggregateInputType = {
    seats?: true
    price?: true
    receiptPrice?: true
    etaMinutes?: true
    destinationLat?: true
    destinationLng?: true
    originLat?: true
    originLng?: true
  }

  export type RideSumAggregateInputType = {
    seats?: true
    price?: true
    receiptPrice?: true
    etaMinutes?: true
    destinationLat?: true
    destinationLng?: true
    originLat?: true
    originLng?: true
  }

  export type RideMinAggregateInputType = {
    id?: true
    driverId?: true
    carId?: true
    carInfo?: true
    serviceType?: true
    seats?: true
    price?: true
    receiptPrice?: true
    renterScreenshotUrl?: true
    additionalInfo?: true
    createdAt?: true
    startedAt?: true
    arrivedAt?: true
    time?: true
    isTimeArranged?: true
    etaMinutes?: true
    destination?: true
    origin?: true
    fromCity?: true
    fromSuburb?: true
    toCity?: true
    toSuburb?: true
    fromCityNorm?: true
    fromSuburbNorm?: true
    toCityNorm?: true
    toSuburbNorm?: true
    rideType?: true
    isRequest?: true
    isVerified?: true
    isAnonymous?: true
    status?: true
    allowedGender?: true
    destinationLat?: true
    destinationLng?: true
    originLat?: true
    originLng?: true
    polyline?: true
    scheduledRideId?: true
  }

  export type RideMaxAggregateInputType = {
    id?: true
    driverId?: true
    carId?: true
    carInfo?: true
    serviceType?: true
    seats?: true
    price?: true
    receiptPrice?: true
    renterScreenshotUrl?: true
    additionalInfo?: true
    createdAt?: true
    startedAt?: true
    arrivedAt?: true
    time?: true
    isTimeArranged?: true
    etaMinutes?: true
    destination?: true
    origin?: true
    fromCity?: true
    fromSuburb?: true
    toCity?: true
    toSuburb?: true
    fromCityNorm?: true
    fromSuburbNorm?: true
    toCityNorm?: true
    toSuburbNorm?: true
    rideType?: true
    isRequest?: true
    isVerified?: true
    isAnonymous?: true
    status?: true
    allowedGender?: true
    destinationLat?: true
    destinationLng?: true
    originLat?: true
    originLng?: true
    polyline?: true
    scheduledRideId?: true
  }

  export type RideCountAggregateInputType = {
    id?: true
    driverId?: true
    carId?: true
    carInfo?: true
    serviceType?: true
    seats?: true
    price?: true
    receiptPrice?: true
    renterScreenshotUrl?: true
    additionalInfo?: true
    createdAt?: true
    startedAt?: true
    arrivedAt?: true
    time?: true
    isTimeArranged?: true
    etaMinutes?: true
    destination?: true
    origin?: true
    fromCity?: true
    fromSuburb?: true
    toCity?: true
    toSuburb?: true
    fromCityNorm?: true
    fromSuburbNorm?: true
    toCityNorm?: true
    toSuburbNorm?: true
    rideType?: true
    isRequest?: true
    isVerified?: true
    isAnonymous?: true
    status?: true
    allowedGender?: true
    destinationLat?: true
    destinationLng?: true
    originLat?: true
    originLng?: true
    polyline?: true
    scheduledRideId?: true
    _all?: true
  }

  export type RideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ride to aggregate.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rides
    **/
    _count?: true | RideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RideMaxAggregateInputType
  }

  export type GetRideAggregateType<T extends RideAggregateArgs> = {
        [P in keyof T & keyof AggregateRide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRide[P]>
      : GetScalarType<T[P], AggregateRide[P]>
  }




  export type RideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
    orderBy?: RideOrderByWithAggregationInput | RideOrderByWithAggregationInput[]
    by: RideScalarFieldEnum[] | RideScalarFieldEnum
    having?: RideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RideCountAggregateInputType | true
    _avg?: RideAvgAggregateInputType
    _sum?: RideSumAggregateInputType
    _min?: RideMinAggregateInputType
    _max?: RideMaxAggregateInputType
  }

  export type RideGroupByOutputType = {
    id: string
    driverId: string
    carId: string | null
    carInfo: string | null
    serviceType: string | null
    seats: number
    price: number
    receiptPrice: number | null
    renterScreenshotUrl: string | null
    additionalInfo: string | null
    createdAt: Date
    startedAt: Date | null
    arrivedAt: Date | null
    time: Date
    isTimeArranged: boolean
    etaMinutes: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm: string | null
    fromSuburbNorm: string | null
    toCityNorm: string | null
    toSuburbNorm: string | null
    rideType: string
    isRequest: boolean
    isVerified: boolean
    isAnonymous: boolean
    status: $Enums.RideStatus
    allowedGender: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline: string | null
    scheduledRideId: string | null
    _count: RideCountAggregateOutputType | null
    _avg: RideAvgAggregateOutputType | null
    _sum: RideSumAggregateOutputType | null
    _min: RideMinAggregateOutputType | null
    _max: RideMaxAggregateOutputType | null
  }

  type GetRideGroupByPayload<T extends RideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RideGroupByOutputType[P]>
            : GetScalarType<T[P], RideGroupByOutputType[P]>
        }
      >
    >


  export type RideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    carId?: boolean
    carInfo?: boolean
    serviceType?: boolean
    seats?: boolean
    price?: boolean
    receiptPrice?: boolean
    renterScreenshotUrl?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    startedAt?: boolean
    arrivedAt?: boolean
    time?: boolean
    isTimeArranged?: boolean
    etaMinutes?: boolean
    destination?: boolean
    origin?: boolean
    fromCity?: boolean
    fromSuburb?: boolean
    toCity?: boolean
    toSuburb?: boolean
    fromCityNorm?: boolean
    fromSuburbNorm?: boolean
    toCityNorm?: boolean
    toSuburbNorm?: boolean
    rideType?: boolean
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: boolean
    allowedGender?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    originLat?: boolean
    originLng?: boolean
    polyline?: boolean
    scheduledRideId?: boolean
    bookings?: boolean | Ride$bookingsArgs<ExtArgs>
    chat?: boolean | Ride$chatArgs<ExtArgs>
    feedbacks?: boolean | Ride$feedbacksArgs<ExtArgs>
    offers?: boolean | Ride$offersArgs<ExtArgs>
    reports?: boolean | Ride$reportsArgs<ExtArgs>
    car?: boolean | Ride$carArgs<ExtArgs>
    driver?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Ride$commentsArgs<ExtArgs>
    scheduledRide?: boolean | Ride$scheduledRideArgs<ExtArgs>
    interests?: boolean | Ride$interestsArgs<ExtArgs>
    groupInvitations?: boolean | Ride$groupInvitationsArgs<ExtArgs>
    _count?: boolean | RideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ride"]>

  export type RideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    carId?: boolean
    carInfo?: boolean
    serviceType?: boolean
    seats?: boolean
    price?: boolean
    receiptPrice?: boolean
    renterScreenshotUrl?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    startedAt?: boolean
    arrivedAt?: boolean
    time?: boolean
    isTimeArranged?: boolean
    etaMinutes?: boolean
    destination?: boolean
    origin?: boolean
    fromCity?: boolean
    fromSuburb?: boolean
    toCity?: boolean
    toSuburb?: boolean
    fromCityNorm?: boolean
    fromSuburbNorm?: boolean
    toCityNorm?: boolean
    toSuburbNorm?: boolean
    rideType?: boolean
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: boolean
    allowedGender?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    originLat?: boolean
    originLng?: boolean
    polyline?: boolean
    scheduledRideId?: boolean
    car?: boolean | Ride$carArgs<ExtArgs>
    driver?: boolean | UserDefaultArgs<ExtArgs>
    scheduledRide?: boolean | Ride$scheduledRideArgs<ExtArgs>
  }, ExtArgs["result"]["ride"]>

  export type RideSelectScalar = {
    id?: boolean
    driverId?: boolean
    carId?: boolean
    carInfo?: boolean
    serviceType?: boolean
    seats?: boolean
    price?: boolean
    receiptPrice?: boolean
    renterScreenshotUrl?: boolean
    additionalInfo?: boolean
    createdAt?: boolean
    startedAt?: boolean
    arrivedAt?: boolean
    time?: boolean
    isTimeArranged?: boolean
    etaMinutes?: boolean
    destination?: boolean
    origin?: boolean
    fromCity?: boolean
    fromSuburb?: boolean
    toCity?: boolean
    toSuburb?: boolean
    fromCityNorm?: boolean
    fromSuburbNorm?: boolean
    toCityNorm?: boolean
    toSuburbNorm?: boolean
    rideType?: boolean
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: boolean
    allowedGender?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    originLat?: boolean
    originLng?: boolean
    polyline?: boolean
    scheduledRideId?: boolean
  }

  export type RideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Ride$bookingsArgs<ExtArgs>
    chat?: boolean | Ride$chatArgs<ExtArgs>
    feedbacks?: boolean | Ride$feedbacksArgs<ExtArgs>
    offers?: boolean | Ride$offersArgs<ExtArgs>
    reports?: boolean | Ride$reportsArgs<ExtArgs>
    car?: boolean | Ride$carArgs<ExtArgs>
    driver?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Ride$commentsArgs<ExtArgs>
    scheduledRide?: boolean | Ride$scheduledRideArgs<ExtArgs>
    interests?: boolean | Ride$interestsArgs<ExtArgs>
    groupInvitations?: boolean | Ride$groupInvitationsArgs<ExtArgs>
    _count?: boolean | RideCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    car?: boolean | Ride$carArgs<ExtArgs>
    driver?: boolean | UserDefaultArgs<ExtArgs>
    scheduledRide?: boolean | Ride$scheduledRideArgs<ExtArgs>
  }

  export type $RidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ride"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      chat: Prisma.$ChatPayload<ExtArgs> | null
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      offers: Prisma.$OfferPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      car: Prisma.$CarPayload<ExtArgs> | null
      driver: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$RideCommentPayload<ExtArgs>[]
      scheduledRide: Prisma.$ScheduledRidePayload<ExtArgs> | null
      interests: Prisma.$RideInterestPayload<ExtArgs>[]
      groupInvitations: Prisma.$GroupBookingInvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      carId: string | null
      carInfo: string | null
      serviceType: string | null
      seats: number
      price: number
      receiptPrice: number | null
      renterScreenshotUrl: string | null
      additionalInfo: string | null
      createdAt: Date
      startedAt: Date | null
      arrivedAt: Date | null
      time: Date
      isTimeArranged: boolean
      etaMinutes: number | null
      destination: string
      origin: string
      fromCity: string
      fromSuburb: string
      toCity: string
      toSuburb: string
      fromCityNorm: string | null
      fromSuburbNorm: string | null
      toCityNorm: string | null
      toSuburbNorm: string | null
      rideType: string
      isRequest: boolean
      isVerified: boolean
      isAnonymous: boolean
      status: $Enums.RideStatus
      allowedGender: string
      destinationLat: number
      destinationLng: number
      originLat: number
      originLng: number
      polyline: string | null
      scheduledRideId: string | null
    }, ExtArgs["result"]["ride"]>
    composites: {}
  }

  type RideGetPayload<S extends boolean | null | undefined | RideDefaultArgs> = $Result.GetResult<Prisma.$RidePayload, S>

  type RideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RideCountAggregateInputType | true
    }

  export interface RideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ride'], meta: { name: 'Ride' } }
    /**
     * Find zero or one Ride that matches the filter.
     * @param {RideFindUniqueArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RideFindUniqueArgs>(args: SelectSubset<T, RideFindUniqueArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ride that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RideFindUniqueOrThrowArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RideFindUniqueOrThrowArgs>(args: SelectSubset<T, RideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideFindFirstArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RideFindFirstArgs>(args?: SelectSubset<T, RideFindFirstArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideFindFirstOrThrowArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RideFindFirstOrThrowArgs>(args?: SelectSubset<T, RideFindFirstOrThrowArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rides
     * const rides = await prisma.ride.findMany()
     * 
     * // Get first 10 Rides
     * const rides = await prisma.ride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rideWithIdOnly = await prisma.ride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RideFindManyArgs>(args?: SelectSubset<T, RideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ride.
     * @param {RideCreateArgs} args - Arguments to create a Ride.
     * @example
     * // Create one Ride
     * const Ride = await prisma.ride.create({
     *   data: {
     *     // ... data to create a Ride
     *   }
     * })
     * 
     */
    create<T extends RideCreateArgs>(args: SelectSubset<T, RideCreateArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rides.
     * @param {RideCreateManyArgs} args - Arguments to create many Rides.
     * @example
     * // Create many Rides
     * const ride = await prisma.ride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RideCreateManyArgs>(args?: SelectSubset<T, RideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rides and returns the data saved in the database.
     * @param {RideCreateManyAndReturnArgs} args - Arguments to create many Rides.
     * @example
     * // Create many Rides
     * const ride = await prisma.ride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rides and only return the `id`
     * const rideWithIdOnly = await prisma.ride.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RideCreateManyAndReturnArgs>(args?: SelectSubset<T, RideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ride.
     * @param {RideDeleteArgs} args - Arguments to delete one Ride.
     * @example
     * // Delete one Ride
     * const Ride = await prisma.ride.delete({
     *   where: {
     *     // ... filter to delete one Ride
     *   }
     * })
     * 
     */
    delete<T extends RideDeleteArgs>(args: SelectSubset<T, RideDeleteArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ride.
     * @param {RideUpdateArgs} args - Arguments to update one Ride.
     * @example
     * // Update one Ride
     * const ride = await prisma.ride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RideUpdateArgs>(args: SelectSubset<T, RideUpdateArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rides.
     * @param {RideDeleteManyArgs} args - Arguments to filter Rides to delete.
     * @example
     * // Delete a few Rides
     * const { count } = await prisma.ride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RideDeleteManyArgs>(args?: SelectSubset<T, RideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rides
     * const ride = await prisma.ride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RideUpdateManyArgs>(args: SelectSubset<T, RideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ride.
     * @param {RideUpsertArgs} args - Arguments to update or create a Ride.
     * @example
     * // Update or create a Ride
     * const ride = await prisma.ride.upsert({
     *   create: {
     *     // ... data to create a Ride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ride we want to update
     *   }
     * })
     */
    upsert<T extends RideUpsertArgs>(args: SelectSubset<T, RideUpsertArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCountArgs} args - Arguments to filter Rides to count.
     * @example
     * // Count the number of Rides
     * const count = await prisma.ride.count({
     *   where: {
     *     // ... the filter for the Rides we want to count
     *   }
     * })
    **/
    count<T extends RideCountArgs>(
      args?: Subset<T, RideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RideAggregateArgs>(args: Subset<T, RideAggregateArgs>): Prisma.PrismaPromise<GetRideAggregateType<T>>

    /**
     * Group by Ride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RideGroupByArgs['orderBy'] }
        : { orderBy?: RideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ride model
   */
  readonly fields: RideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Ride$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Ride$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    chat<T extends Ride$chatArgs<ExtArgs> = {}>(args?: Subset<T, Ride$chatArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    feedbacks<T extends Ride$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, Ride$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    offers<T extends Ride$offersArgs<ExtArgs> = {}>(args?: Subset<T, Ride$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Ride$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Ride$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    car<T extends Ride$carArgs<ExtArgs> = {}>(args?: Subset<T, Ride$carArgs<ExtArgs>>): Prisma__CarClient<$Result.GetResult<Prisma.$CarPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    driver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends Ride$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Ride$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findMany"> | Null>
    scheduledRide<T extends Ride$scheduledRideArgs<ExtArgs> = {}>(args?: Subset<T, Ride$scheduledRideArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    interests<T extends Ride$interestsArgs<ExtArgs> = {}>(args?: Subset<T, Ride$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "findMany"> | Null>
    groupInvitations<T extends Ride$groupInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, Ride$groupInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ride model
   */ 
  interface RideFieldRefs {
    readonly id: FieldRef<"Ride", 'String'>
    readonly driverId: FieldRef<"Ride", 'String'>
    readonly carId: FieldRef<"Ride", 'String'>
    readonly carInfo: FieldRef<"Ride", 'String'>
    readonly serviceType: FieldRef<"Ride", 'String'>
    readonly seats: FieldRef<"Ride", 'Int'>
    readonly price: FieldRef<"Ride", 'Float'>
    readonly receiptPrice: FieldRef<"Ride", 'Float'>
    readonly renterScreenshotUrl: FieldRef<"Ride", 'String'>
    readonly additionalInfo: FieldRef<"Ride", 'String'>
    readonly createdAt: FieldRef<"Ride", 'DateTime'>
    readonly startedAt: FieldRef<"Ride", 'DateTime'>
    readonly arrivedAt: FieldRef<"Ride", 'DateTime'>
    readonly time: FieldRef<"Ride", 'DateTime'>
    readonly isTimeArranged: FieldRef<"Ride", 'Boolean'>
    readonly etaMinutes: FieldRef<"Ride", 'Int'>
    readonly destination: FieldRef<"Ride", 'String'>
    readonly origin: FieldRef<"Ride", 'String'>
    readonly fromCity: FieldRef<"Ride", 'String'>
    readonly fromSuburb: FieldRef<"Ride", 'String'>
    readonly toCity: FieldRef<"Ride", 'String'>
    readonly toSuburb: FieldRef<"Ride", 'String'>
    readonly fromCityNorm: FieldRef<"Ride", 'String'>
    readonly fromSuburbNorm: FieldRef<"Ride", 'String'>
    readonly toCityNorm: FieldRef<"Ride", 'String'>
    readonly toSuburbNorm: FieldRef<"Ride", 'String'>
    readonly rideType: FieldRef<"Ride", 'String'>
    readonly isRequest: FieldRef<"Ride", 'Boolean'>
    readonly isVerified: FieldRef<"Ride", 'Boolean'>
    readonly isAnonymous: FieldRef<"Ride", 'Boolean'>
    readonly status: FieldRef<"Ride", 'RideStatus'>
    readonly allowedGender: FieldRef<"Ride", 'String'>
    readonly destinationLat: FieldRef<"Ride", 'Float'>
    readonly destinationLng: FieldRef<"Ride", 'Float'>
    readonly originLat: FieldRef<"Ride", 'Float'>
    readonly originLng: FieldRef<"Ride", 'Float'>
    readonly polyline: FieldRef<"Ride", 'String'>
    readonly scheduledRideId: FieldRef<"Ride", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ride findUnique
   */
  export type RideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride findUniqueOrThrow
   */
  export type RideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride findFirst
   */
  export type RideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rides.
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rides.
     */
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Ride findFirstOrThrow
   */
  export type RideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rides.
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rides.
     */
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Ride findMany
   */
  export type RideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Rides to fetch.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rides.
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Ride create
   */
  export type RideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * The data needed to create a Ride.
     */
    data: XOR<RideCreateInput, RideUncheckedCreateInput>
  }

  /**
   * Ride createMany
   */
  export type RideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rides.
     */
    data: RideCreateManyInput | RideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ride createManyAndReturn
   */
  export type RideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rides.
     */
    data: RideCreateManyInput | RideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ride update
   */
  export type RideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * The data needed to update a Ride.
     */
    data: XOR<RideUpdateInput, RideUncheckedUpdateInput>
    /**
     * Choose, which Ride to update.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride updateMany
   */
  export type RideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rides.
     */
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyInput>
    /**
     * Filter which Rides to update
     */
    where?: RideWhereInput
  }

  /**
   * Ride upsert
   */
  export type RideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * The filter to search for the Ride to update in case it exists.
     */
    where: RideWhereUniqueInput
    /**
     * In case the Ride found by the `where` argument doesn't exist, create a new Ride with this data.
     */
    create: XOR<RideCreateInput, RideUncheckedCreateInput>
    /**
     * In case the Ride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RideUpdateInput, RideUncheckedUpdateInput>
  }

  /**
   * Ride delete
   */
  export type RideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter which Ride to delete.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride deleteMany
   */
  export type RideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rides to delete
     */
    where?: RideWhereInput
  }

  /**
   * Ride.bookings
   */
  export type Ride$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Ride.chat
   */
  export type Ride$chatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
  }

  /**
   * Ride.feedbacks
   */
  export type Ride$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Ride.offers
   */
  export type Ride$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    cursor?: OfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Ride.reports
   */
  export type Ride$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Ride.car
   */
  export type Ride$carArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Car
     */
    select?: CarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CarInclude<ExtArgs> | null
    where?: CarWhereInput
  }

  /**
   * Ride.comments
   */
  export type Ride$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    where?: RideCommentWhereInput
    orderBy?: RideCommentOrderByWithRelationInput | RideCommentOrderByWithRelationInput[]
    cursor?: RideCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideCommentScalarFieldEnum | RideCommentScalarFieldEnum[]
  }

  /**
   * Ride.scheduledRide
   */
  export type Ride$scheduledRideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    where?: ScheduledRideWhereInput
  }

  /**
   * Ride.interests
   */
  export type Ride$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    where?: RideInterestWhereInput
    orderBy?: RideInterestOrderByWithRelationInput | RideInterestOrderByWithRelationInput[]
    cursor?: RideInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideInterestScalarFieldEnum | RideInterestScalarFieldEnum[]
  }

  /**
   * Ride.groupInvitations
   */
  export type Ride$groupInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    where?: GroupBookingInvitationWhereInput
    orderBy?: GroupBookingInvitationOrderByWithRelationInput | GroupBookingInvitationOrderByWithRelationInput[]
    cursor?: GroupBookingInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupBookingInvitationScalarFieldEnum | GroupBookingInvitationScalarFieldEnum[]
  }

  /**
   * Ride without action
   */
  export type RideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
  }


  /**
   * Model RideInterest
   */

  export type AggregateRideInterest = {
    _count: RideInterestCountAggregateOutputType | null
    _min: RideInterestMinAggregateOutputType | null
    _max: RideInterestMaxAggregateOutputType | null
  }

  export type RideInterestMinAggregateOutputType = {
    id: string | null
    rideId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type RideInterestMaxAggregateOutputType = {
    id: string | null
    rideId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type RideInterestCountAggregateOutputType = {
    id: number
    rideId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type RideInterestMinAggregateInputType = {
    id?: true
    rideId?: true
    userId?: true
    createdAt?: true
  }

  export type RideInterestMaxAggregateInputType = {
    id?: true
    rideId?: true
    userId?: true
    createdAt?: true
  }

  export type RideInterestCountAggregateInputType = {
    id?: true
    rideId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type RideInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RideInterest to aggregate.
     */
    where?: RideInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideInterests to fetch.
     */
    orderBy?: RideInterestOrderByWithRelationInput | RideInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RideInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RideInterests
    **/
    _count?: true | RideInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RideInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RideInterestMaxAggregateInputType
  }

  export type GetRideInterestAggregateType<T extends RideInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateRideInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRideInterest[P]>
      : GetScalarType<T[P], AggregateRideInterest[P]>
  }




  export type RideInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideInterestWhereInput
    orderBy?: RideInterestOrderByWithAggregationInput | RideInterestOrderByWithAggregationInput[]
    by: RideInterestScalarFieldEnum[] | RideInterestScalarFieldEnum
    having?: RideInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RideInterestCountAggregateInputType | true
    _min?: RideInterestMinAggregateInputType
    _max?: RideInterestMaxAggregateInputType
  }

  export type RideInterestGroupByOutputType = {
    id: string
    rideId: string
    userId: string
    createdAt: Date
    _count: RideInterestCountAggregateOutputType | null
    _min: RideInterestMinAggregateOutputType | null
    _max: RideInterestMaxAggregateOutputType | null
  }

  type GetRideInterestGroupByPayload<T extends RideInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RideInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RideInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RideInterestGroupByOutputType[P]>
            : GetScalarType<T[P], RideInterestGroupByOutputType[P]>
        }
      >
    >


  export type RideInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rideInterest"]>

  export type RideInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rideInterest"]>

  export type RideInterestSelectScalar = {
    id?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type RideInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RideInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RideInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RideInterest"
    objects: {
      ride: Prisma.$RidePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rideId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["rideInterest"]>
    composites: {}
  }

  type RideInterestGetPayload<S extends boolean | null | undefined | RideInterestDefaultArgs> = $Result.GetResult<Prisma.$RideInterestPayload, S>

  type RideInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RideInterestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RideInterestCountAggregateInputType | true
    }

  export interface RideInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RideInterest'], meta: { name: 'RideInterest' } }
    /**
     * Find zero or one RideInterest that matches the filter.
     * @param {RideInterestFindUniqueArgs} args - Arguments to find a RideInterest
     * @example
     * // Get one RideInterest
     * const rideInterest = await prisma.rideInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RideInterestFindUniqueArgs>(args: SelectSubset<T, RideInterestFindUniqueArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RideInterest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RideInterestFindUniqueOrThrowArgs} args - Arguments to find a RideInterest
     * @example
     * // Get one RideInterest
     * const rideInterest = await prisma.rideInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RideInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, RideInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RideInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideInterestFindFirstArgs} args - Arguments to find a RideInterest
     * @example
     * // Get one RideInterest
     * const rideInterest = await prisma.rideInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RideInterestFindFirstArgs>(args?: SelectSubset<T, RideInterestFindFirstArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RideInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideInterestFindFirstOrThrowArgs} args - Arguments to find a RideInterest
     * @example
     * // Get one RideInterest
     * const rideInterest = await prisma.rideInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RideInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, RideInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RideInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RideInterests
     * const rideInterests = await prisma.rideInterest.findMany()
     * 
     * // Get first 10 RideInterests
     * const rideInterests = await prisma.rideInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rideInterestWithIdOnly = await prisma.rideInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RideInterestFindManyArgs>(args?: SelectSubset<T, RideInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RideInterest.
     * @param {RideInterestCreateArgs} args - Arguments to create a RideInterest.
     * @example
     * // Create one RideInterest
     * const RideInterest = await prisma.rideInterest.create({
     *   data: {
     *     // ... data to create a RideInterest
     *   }
     * })
     * 
     */
    create<T extends RideInterestCreateArgs>(args: SelectSubset<T, RideInterestCreateArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RideInterests.
     * @param {RideInterestCreateManyArgs} args - Arguments to create many RideInterests.
     * @example
     * // Create many RideInterests
     * const rideInterest = await prisma.rideInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RideInterestCreateManyArgs>(args?: SelectSubset<T, RideInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RideInterests and returns the data saved in the database.
     * @param {RideInterestCreateManyAndReturnArgs} args - Arguments to create many RideInterests.
     * @example
     * // Create many RideInterests
     * const rideInterest = await prisma.rideInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RideInterests and only return the `id`
     * const rideInterestWithIdOnly = await prisma.rideInterest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RideInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, RideInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RideInterest.
     * @param {RideInterestDeleteArgs} args - Arguments to delete one RideInterest.
     * @example
     * // Delete one RideInterest
     * const RideInterest = await prisma.rideInterest.delete({
     *   where: {
     *     // ... filter to delete one RideInterest
     *   }
     * })
     * 
     */
    delete<T extends RideInterestDeleteArgs>(args: SelectSubset<T, RideInterestDeleteArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RideInterest.
     * @param {RideInterestUpdateArgs} args - Arguments to update one RideInterest.
     * @example
     * // Update one RideInterest
     * const rideInterest = await prisma.rideInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RideInterestUpdateArgs>(args: SelectSubset<T, RideInterestUpdateArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RideInterests.
     * @param {RideInterestDeleteManyArgs} args - Arguments to filter RideInterests to delete.
     * @example
     * // Delete a few RideInterests
     * const { count } = await prisma.rideInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RideInterestDeleteManyArgs>(args?: SelectSubset<T, RideInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RideInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RideInterests
     * const rideInterest = await prisma.rideInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RideInterestUpdateManyArgs>(args: SelectSubset<T, RideInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RideInterest.
     * @param {RideInterestUpsertArgs} args - Arguments to update or create a RideInterest.
     * @example
     * // Update or create a RideInterest
     * const rideInterest = await prisma.rideInterest.upsert({
     *   create: {
     *     // ... data to create a RideInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RideInterest we want to update
     *   }
     * })
     */
    upsert<T extends RideInterestUpsertArgs>(args: SelectSubset<T, RideInterestUpsertArgs<ExtArgs>>): Prisma__RideInterestClient<$Result.GetResult<Prisma.$RideInterestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RideInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideInterestCountArgs} args - Arguments to filter RideInterests to count.
     * @example
     * // Count the number of RideInterests
     * const count = await prisma.rideInterest.count({
     *   where: {
     *     // ... the filter for the RideInterests we want to count
     *   }
     * })
    **/
    count<T extends RideInterestCountArgs>(
      args?: Subset<T, RideInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RideInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RideInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RideInterestAggregateArgs>(args: Subset<T, RideInterestAggregateArgs>): Prisma.PrismaPromise<GetRideInterestAggregateType<T>>

    /**
     * Group by RideInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RideInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RideInterestGroupByArgs['orderBy'] }
        : { orderBy?: RideInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RideInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRideInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RideInterest model
   */
  readonly fields: RideInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RideInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RideInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ride<T extends RideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RideDefaultArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RideInterest model
   */ 
  interface RideInterestFieldRefs {
    readonly id: FieldRef<"RideInterest", 'String'>
    readonly rideId: FieldRef<"RideInterest", 'String'>
    readonly userId: FieldRef<"RideInterest", 'String'>
    readonly createdAt: FieldRef<"RideInterest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RideInterest findUnique
   */
  export type RideInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * Filter, which RideInterest to fetch.
     */
    where: RideInterestWhereUniqueInput
  }

  /**
   * RideInterest findUniqueOrThrow
   */
  export type RideInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * Filter, which RideInterest to fetch.
     */
    where: RideInterestWhereUniqueInput
  }

  /**
   * RideInterest findFirst
   */
  export type RideInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * Filter, which RideInterest to fetch.
     */
    where?: RideInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideInterests to fetch.
     */
    orderBy?: RideInterestOrderByWithRelationInput | RideInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RideInterests.
     */
    cursor?: RideInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RideInterests.
     */
    distinct?: RideInterestScalarFieldEnum | RideInterestScalarFieldEnum[]
  }

  /**
   * RideInterest findFirstOrThrow
   */
  export type RideInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * Filter, which RideInterest to fetch.
     */
    where?: RideInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideInterests to fetch.
     */
    orderBy?: RideInterestOrderByWithRelationInput | RideInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RideInterests.
     */
    cursor?: RideInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RideInterests.
     */
    distinct?: RideInterestScalarFieldEnum | RideInterestScalarFieldEnum[]
  }

  /**
   * RideInterest findMany
   */
  export type RideInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * Filter, which RideInterests to fetch.
     */
    where?: RideInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideInterests to fetch.
     */
    orderBy?: RideInterestOrderByWithRelationInput | RideInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RideInterests.
     */
    cursor?: RideInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideInterests.
     */
    skip?: number
    distinct?: RideInterestScalarFieldEnum | RideInterestScalarFieldEnum[]
  }

  /**
   * RideInterest create
   */
  export type RideInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a RideInterest.
     */
    data: XOR<RideInterestCreateInput, RideInterestUncheckedCreateInput>
  }

  /**
   * RideInterest createMany
   */
  export type RideInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RideInterests.
     */
    data: RideInterestCreateManyInput | RideInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RideInterest createManyAndReturn
   */
  export type RideInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RideInterests.
     */
    data: RideInterestCreateManyInput | RideInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RideInterest update
   */
  export type RideInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a RideInterest.
     */
    data: XOR<RideInterestUpdateInput, RideInterestUncheckedUpdateInput>
    /**
     * Choose, which RideInterest to update.
     */
    where: RideInterestWhereUniqueInput
  }

  /**
   * RideInterest updateMany
   */
  export type RideInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RideInterests.
     */
    data: XOR<RideInterestUpdateManyMutationInput, RideInterestUncheckedUpdateManyInput>
    /**
     * Filter which RideInterests to update
     */
    where?: RideInterestWhereInput
  }

  /**
   * RideInterest upsert
   */
  export type RideInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the RideInterest to update in case it exists.
     */
    where: RideInterestWhereUniqueInput
    /**
     * In case the RideInterest found by the `where` argument doesn't exist, create a new RideInterest with this data.
     */
    create: XOR<RideInterestCreateInput, RideInterestUncheckedCreateInput>
    /**
     * In case the RideInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RideInterestUpdateInput, RideInterestUncheckedUpdateInput>
  }

  /**
   * RideInterest delete
   */
  export type RideInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
    /**
     * Filter which RideInterest to delete.
     */
    where: RideInterestWhereUniqueInput
  }

  /**
   * RideInterest deleteMany
   */
  export type RideInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RideInterests to delete
     */
    where?: RideInterestWhereInput
  }

  /**
   * RideInterest without action
   */
  export type RideInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideInterest
     */
    select?: RideInterestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInterestInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    rideId: string | null
    userId: string | null
    createdAt: Date | null
    status: $Enums.BookingStatus | null
    invitationId: string | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    rideId: string | null
    userId: string | null
    createdAt: Date | null
    status: $Enums.BookingStatus | null
    invitationId: string | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    rideId: number
    userId: number
    createdAt: number
    status: number
    invitationId: number
    _all: number
  }


  export type BookingMinAggregateInputType = {
    id?: true
    rideId?: true
    userId?: true
    createdAt?: true
    status?: true
    invitationId?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    rideId?: true
    userId?: true
    createdAt?: true
    status?: true
    invitationId?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    rideId?: true
    userId?: true
    createdAt?: true
    status?: true
    invitationId?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    rideId: string
    userId: string
    createdAt: Date
    status: $Enums.BookingStatus
    invitationId: string | null
    _count: BookingCountAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    status?: boolean
    invitationId?: boolean
    invitation?: boolean | Booking$invitationArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    chatMember?: boolean | Booking$chatMemberArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    status?: boolean
    invitationId?: boolean
    invitation?: boolean | Booking$invitationArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    status?: boolean
    invitationId?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | Booking$invitationArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    chatMember?: boolean | Booking$chatMemberArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitation?: boolean | Booking$invitationArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      invitation: Prisma.$GroupBookingInvitationPayload<ExtArgs> | null
      ride: Prisma.$RidePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      chatMember: Prisma.$ChatMemberPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rideId: string
      userId: string
      createdAt: Date
      status: $Enums.BookingStatus
      invitationId: string | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitation<T extends Booking$invitationArgs<ExtArgs> = {}>(args?: Subset<T, Booking$invitationArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ride<T extends RideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RideDefaultArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    chatMember<T extends Booking$chatMemberArgs<ExtArgs> = {}>(args?: Subset<T, Booking$chatMemberArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly rideId: FieldRef<"Booking", 'String'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly invitationId: FieldRef<"Booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.invitation
   */
  export type Booking$invitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    where?: GroupBookingInvitationWhereInput
  }

  /**
   * Booking.chatMember
   */
  export type Booking$chatMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    where?: ChatMemberWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    price: number | null
  }

  export type OfferSumAggregateOutputType = {
    price: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    price: number | null
    rideId: string | null
    userId: string | null
    createdAt: Date | null
    status: $Enums.OfferStatus | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    price: number | null
    rideId: string | null
    userId: string | null
    createdAt: Date | null
    status: $Enums.OfferStatus | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    price: number
    rideId: number
    userId: number
    createdAt: number
    status: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    price?: true
  }

  export type OfferSumAggregateInputType = {
    price?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    price?: true
    rideId?: true
    userId?: true
    createdAt?: true
    status?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    price?: true
    rideId?: true
    userId?: true
    createdAt?: true
    status?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    price?: true
    rideId?: true
    userId?: true
    createdAt?: true
    status?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: string
    price: number
    rideId: string
    userId: string
    createdAt: Date
    status: $Enums.OfferStatus
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    status?: boolean
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    status?: boolean
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    price?: boolean
    rideId?: boolean
    userId?: boolean
    createdAt?: boolean
    status?: boolean
  }

  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      ride: Prisma.$RidePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      price: number
      rideId: string
      userId: string
      createdAt: Date
      status: $Enums.OfferStatus
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ride<T extends RideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RideDefaultArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */ 
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'String'>
    readonly price: FieldRef<"Offer", 'Float'>
    readonly rideId: FieldRef<"Offer", 'String'>
    readonly userId: FieldRef<"Offer", 'String'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly status: FieldRef<"Offer", 'OfferStatus'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    rideId: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    rideId: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    rideId: number
    startedAt: number
    endedAt: number
    createdAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    rideId?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    rideId?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    rideId?: true
    startedAt?: true
    endedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    rideId: string | null
    startedAt: Date | null
    endedAt: Date | null
    createdAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    ride?: boolean | Chat$rideArgs<ExtArgs>
    members?: boolean | Chat$membersArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    ride?: boolean | Chat$rideArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    rideId?: boolean
    startedAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
  }

  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | Chat$rideArgs<ExtArgs>
    members?: boolean | Chat$membersArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | Chat$rideArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      ride: Prisma.$RidePayload<ExtArgs> | null
      members: Prisma.$ChatMemberPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rideId: string | null
      startedAt: Date | null
      endedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ride<T extends Chat$rideArgs<ExtArgs> = {}>(args?: Subset<T, Chat$rideArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    members<T extends Chat$membersArgs<ExtArgs> = {}>(args?: Subset<T, Chat$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly rideId: FieldRef<"Chat", 'String'>
    readonly startedAt: FieldRef<"Chat", 'DateTime'>
    readonly endedAt: FieldRef<"Chat", 'DateTime'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data?: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }

  /**
   * Chat.ride
   */
  export type Chat$rideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
  }

  /**
   * Chat.members
   */
  export type Chat$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    where?: ChatMemberWhereInput
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    cursor?: ChatMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model ChatMember
   */

  export type AggregateChatMember = {
    _count: ChatMemberCountAggregateOutputType | null
    _min: ChatMemberMinAggregateOutputType | null
    _max: ChatMemberMaxAggregateOutputType | null
  }

  export type ChatMemberMinAggregateOutputType = {
    id: string | null
    hasStarted: boolean | null
    hasEnded: boolean | null
    chatId: string | null
    userId: string | null
    bookingId: string | null
    createdAt: Date | null
  }

  export type ChatMemberMaxAggregateOutputType = {
    id: string | null
    hasStarted: boolean | null
    hasEnded: boolean | null
    chatId: string | null
    userId: string | null
    bookingId: string | null
    createdAt: Date | null
  }

  export type ChatMemberCountAggregateOutputType = {
    id: number
    hasStarted: number
    hasEnded: number
    chatId: number
    userId: number
    bookingId: number
    createdAt: number
    _all: number
  }


  export type ChatMemberMinAggregateInputType = {
    id?: true
    hasStarted?: true
    hasEnded?: true
    chatId?: true
    userId?: true
    bookingId?: true
    createdAt?: true
  }

  export type ChatMemberMaxAggregateInputType = {
    id?: true
    hasStarted?: true
    hasEnded?: true
    chatId?: true
    userId?: true
    bookingId?: true
    createdAt?: true
  }

  export type ChatMemberCountAggregateInputType = {
    id?: true
    hasStarted?: true
    hasEnded?: true
    chatId?: true
    userId?: true
    bookingId?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMember to aggregate.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMembers
    **/
    _count?: true | ChatMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMemberMaxAggregateInputType
  }

  export type GetChatMemberAggregateType<T extends ChatMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMember[P]>
      : GetScalarType<T[P], AggregateChatMember[P]>
  }




  export type ChatMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMemberWhereInput
    orderBy?: ChatMemberOrderByWithAggregationInput | ChatMemberOrderByWithAggregationInput[]
    by: ChatMemberScalarFieldEnum[] | ChatMemberScalarFieldEnum
    having?: ChatMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMemberCountAggregateInputType | true
    _min?: ChatMemberMinAggregateInputType
    _max?: ChatMemberMaxAggregateInputType
  }

  export type ChatMemberGroupByOutputType = {
    id: string
    hasStarted: boolean
    hasEnded: boolean
    chatId: string
    userId: string
    bookingId: string | null
    createdAt: Date
    _count: ChatMemberCountAggregateOutputType | null
    _min: ChatMemberMinAggregateOutputType | null
    _max: ChatMemberMaxAggregateOutputType | null
  }

  type GetChatMemberGroupByPayload<T extends ChatMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMemberGroupByOutputType[P]>
        }
      >
    >


  export type ChatMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hasStarted?: boolean
    hasEnded?: boolean
    chatId?: boolean
    userId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    booking?: boolean | ChatMember$bookingArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMember"]>

  export type ChatMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hasStarted?: boolean
    hasEnded?: boolean
    chatId?: boolean
    userId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    booking?: boolean | ChatMember$bookingArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMember"]>

  export type ChatMemberSelectScalar = {
    id?: boolean
    hasStarted?: boolean
    hasEnded?: boolean
    chatId?: boolean
    userId?: boolean
    bookingId?: boolean
    createdAt?: boolean
  }

  export type ChatMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ChatMember$bookingArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | ChatMember$bookingArgs<ExtArgs>
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMember"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs> | null
      chat: Prisma.$ChatPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hasStarted: boolean
      hasEnded: boolean
      chatId: string
      userId: string
      bookingId: string | null
      createdAt: Date
    }, ExtArgs["result"]["chatMember"]>
    composites: {}
  }

  type ChatMemberGetPayload<S extends boolean | null | undefined | ChatMemberDefaultArgs> = $Result.GetResult<Prisma.$ChatMemberPayload, S>

  type ChatMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatMemberCountAggregateInputType | true
    }

  export interface ChatMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMember'], meta: { name: 'ChatMember' } }
    /**
     * Find zero or one ChatMember that matches the filter.
     * @param {ChatMemberFindUniqueArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMemberFindUniqueArgs>(args: SelectSubset<T, ChatMemberFindUniqueArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatMemberFindUniqueOrThrowArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberFindFirstArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMemberFindFirstArgs>(args?: SelectSubset<T, ChatMemberFindFirstArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberFindFirstOrThrowArgs} args - Arguments to find a ChatMember
     * @example
     * // Get one ChatMember
     * const chatMember = await prisma.chatMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMembers
     * const chatMembers = await prisma.chatMember.findMany()
     * 
     * // Get first 10 ChatMembers
     * const chatMembers = await prisma.chatMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMemberWithIdOnly = await prisma.chatMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMemberFindManyArgs>(args?: SelectSubset<T, ChatMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatMember.
     * @param {ChatMemberCreateArgs} args - Arguments to create a ChatMember.
     * @example
     * // Create one ChatMember
     * const ChatMember = await prisma.chatMember.create({
     *   data: {
     *     // ... data to create a ChatMember
     *   }
     * })
     * 
     */
    create<T extends ChatMemberCreateArgs>(args: SelectSubset<T, ChatMemberCreateArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatMembers.
     * @param {ChatMemberCreateManyArgs} args - Arguments to create many ChatMembers.
     * @example
     * // Create many ChatMembers
     * const chatMember = await prisma.chatMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMemberCreateManyArgs>(args?: SelectSubset<T, ChatMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMembers and returns the data saved in the database.
     * @param {ChatMemberCreateManyAndReturnArgs} args - Arguments to create many ChatMembers.
     * @example
     * // Create many ChatMembers
     * const chatMember = await prisma.chatMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMembers and only return the `id`
     * const chatMemberWithIdOnly = await prisma.chatMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatMember.
     * @param {ChatMemberDeleteArgs} args - Arguments to delete one ChatMember.
     * @example
     * // Delete one ChatMember
     * const ChatMember = await prisma.chatMember.delete({
     *   where: {
     *     // ... filter to delete one ChatMember
     *   }
     * })
     * 
     */
    delete<T extends ChatMemberDeleteArgs>(args: SelectSubset<T, ChatMemberDeleteArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatMember.
     * @param {ChatMemberUpdateArgs} args - Arguments to update one ChatMember.
     * @example
     * // Update one ChatMember
     * const chatMember = await prisma.chatMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMemberUpdateArgs>(args: SelectSubset<T, ChatMemberUpdateArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatMembers.
     * @param {ChatMemberDeleteManyArgs} args - Arguments to filter ChatMembers to delete.
     * @example
     * // Delete a few ChatMembers
     * const { count } = await prisma.chatMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMemberDeleteManyArgs>(args?: SelectSubset<T, ChatMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMembers
     * const chatMember = await prisma.chatMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMemberUpdateManyArgs>(args: SelectSubset<T, ChatMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMember.
     * @param {ChatMemberUpsertArgs} args - Arguments to update or create a ChatMember.
     * @example
     * // Update or create a ChatMember
     * const chatMember = await prisma.chatMember.upsert({
     *   create: {
     *     // ... data to create a ChatMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMember we want to update
     *   }
     * })
     */
    upsert<T extends ChatMemberUpsertArgs>(args: SelectSubset<T, ChatMemberUpsertArgs<ExtArgs>>): Prisma__ChatMemberClient<$Result.GetResult<Prisma.$ChatMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberCountArgs} args - Arguments to filter ChatMembers to count.
     * @example
     * // Count the number of ChatMembers
     * const count = await prisma.chatMember.count({
     *   where: {
     *     // ... the filter for the ChatMembers we want to count
     *   }
     * })
    **/
    count<T extends ChatMemberCountArgs>(
      args?: Subset<T, ChatMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMemberAggregateArgs>(args: Subset<T, ChatMemberAggregateArgs>): Prisma.PrismaPromise<GetChatMemberAggregateType<T>>

    /**
     * Group by ChatMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMemberGroupByArgs['orderBy'] }
        : { orderBy?: ChatMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMember model
   */
  readonly fields: ChatMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends ChatMember$bookingArgs<ExtArgs> = {}>(args?: Subset<T, ChatMember$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMember model
   */ 
  interface ChatMemberFieldRefs {
    readonly id: FieldRef<"ChatMember", 'String'>
    readonly hasStarted: FieldRef<"ChatMember", 'Boolean'>
    readonly hasEnded: FieldRef<"ChatMember", 'Boolean'>
    readonly chatId: FieldRef<"ChatMember", 'String'>
    readonly userId: FieldRef<"ChatMember", 'String'>
    readonly bookingId: FieldRef<"ChatMember", 'String'>
    readonly createdAt: FieldRef<"ChatMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMember findUnique
   */
  export type ChatMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember findUniqueOrThrow
   */
  export type ChatMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember findFirst
   */
  export type ChatMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMembers.
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMembers.
     */
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * ChatMember findFirstOrThrow
   */
  export type ChatMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMember to fetch.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMembers.
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMembers.
     */
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * ChatMember findMany
   */
  export type ChatMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter, which ChatMembers to fetch.
     */
    where?: ChatMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMembers to fetch.
     */
    orderBy?: ChatMemberOrderByWithRelationInput | ChatMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMembers.
     */
    cursor?: ChatMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMembers.
     */
    skip?: number
    distinct?: ChatMemberScalarFieldEnum | ChatMemberScalarFieldEnum[]
  }

  /**
   * ChatMember create
   */
  export type ChatMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMember.
     */
    data: XOR<ChatMemberCreateInput, ChatMemberUncheckedCreateInput>
  }

  /**
   * ChatMember createMany
   */
  export type ChatMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMembers.
     */
    data: ChatMemberCreateManyInput | ChatMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMember createManyAndReturn
   */
  export type ChatMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatMembers.
     */
    data: ChatMemberCreateManyInput | ChatMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMember update
   */
  export type ChatMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMember.
     */
    data: XOR<ChatMemberUpdateInput, ChatMemberUncheckedUpdateInput>
    /**
     * Choose, which ChatMember to update.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember updateMany
   */
  export type ChatMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMembers.
     */
    data: XOR<ChatMemberUpdateManyMutationInput, ChatMemberUncheckedUpdateManyInput>
    /**
     * Filter which ChatMembers to update
     */
    where?: ChatMemberWhereInput
  }

  /**
   * ChatMember upsert
   */
  export type ChatMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMember to update in case it exists.
     */
    where: ChatMemberWhereUniqueInput
    /**
     * In case the ChatMember found by the `where` argument doesn't exist, create a new ChatMember with this data.
     */
    create: XOR<ChatMemberCreateInput, ChatMemberUncheckedCreateInput>
    /**
     * In case the ChatMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMemberUpdateInput, ChatMemberUncheckedUpdateInput>
  }

  /**
   * ChatMember delete
   */
  export type ChatMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
    /**
     * Filter which ChatMember to delete.
     */
    where: ChatMemberWhereUniqueInput
  }

  /**
   * ChatMember deleteMany
   */
  export type ChatMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMembers to delete
     */
    where?: ChatMemberWhereInput
  }

  /**
   * ChatMember.booking
   */
  export type ChatMember$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * ChatMember without action
   */
  export type ChatMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMember
     */
    select?: ChatMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMemberInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    type: string | null
    chatId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    type: string | null
    chatId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    type: number
    chatId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    type?: true
    chatId?: true
    userId?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    type?: true
    chatId?: true
    userId?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    type?: true
    chatId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string
    type: string
    chatId: string
    userId: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    chatId?: boolean
    userId?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    type?: boolean
    chatId?: boolean
    userId?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    type?: boolean
    chatId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      type: string
      chatId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly chatId: FieldRef<"Message", 'String'>
    readonly userId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    userId: string | null
    relatedId: string | null
    createdAt: Date | null
    bookingStatus: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    type: string | null
    isRead: boolean | null
    userId: string | null
    relatedId: string | null
    createdAt: Date | null
    bookingStatus: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    type: number
    isRead: number
    userId: number
    relatedId: number
    createdAt: number
    bookingStatus: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    userId?: true
    relatedId?: true
    createdAt?: true
    bookingStatus?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    userId?: true
    relatedId?: true
    createdAt?: true
    bookingStatus?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    userId?: true
    relatedId?: true
    createdAt?: true
    bookingStatus?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string
    type: string
    isRead: boolean
    userId: string
    relatedId: string | null
    createdAt: Date
    bookingStatus: string | null
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    userId?: boolean
    relatedId?: boolean
    createdAt?: boolean
    bookingStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    userId?: boolean
    relatedId?: boolean
    createdAt?: boolean
    bookingStatus?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    userId?: boolean
    relatedId?: boolean
    createdAt?: boolean
    bookingStatus?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      type: string
      isRead: boolean
      userId: string
      relatedId: string | null
      createdAt: Date
      bookingStatus: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly relatedId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly bookingStatus: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    rideId: string | null
    givenById: string | null
    receivedById: string | null
    createdAt: Date | null
    arrivalOnTime: boolean | null
    startOnTime: boolean | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    rating: number | null
    comment: string | null
    rideId: string | null
    givenById: string | null
    receivedById: string | null
    createdAt: Date | null
    arrivalOnTime: boolean | null
    startOnTime: boolean | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    rating: number
    comment: number
    rideId: number
    givenById: number
    receivedById: number
    createdAt: number
    arrivalOnTime: number
    startOnTime: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    rideId?: true
    givenById?: true
    receivedById?: true
    createdAt?: true
    arrivalOnTime?: true
    startOnTime?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    rideId?: true
    givenById?: true
    receivedById?: true
    createdAt?: true
    arrivalOnTime?: true
    startOnTime?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    rating?: true
    comment?: true
    rideId?: true
    givenById?: true
    receivedById?: true
    createdAt?: true
    arrivalOnTime?: true
    startOnTime?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    rating: number
    comment: string | null
    rideId: string
    givenById: string
    receivedById: string
    createdAt: Date
    arrivalOnTime: boolean | null
    startOnTime: boolean | null
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    rideId?: boolean
    givenById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    arrivalOnTime?: boolean
    startOnTime?: boolean
    givenBy?: boolean | UserDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    comment?: boolean
    rideId?: boolean
    givenById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    arrivalOnTime?: boolean
    startOnTime?: boolean
    givenBy?: boolean | UserDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    rating?: boolean
    comment?: boolean
    rideId?: boolean
    givenById?: boolean
    receivedById?: boolean
    createdAt?: boolean
    arrivalOnTime?: boolean
    startOnTime?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givenBy?: boolean | UserDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }
  export type FeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    givenBy?: boolean | UserDefaultArgs<ExtArgs>
    receivedBy?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      givenBy: Prisma.$UserPayload<ExtArgs>
      receivedBy: Prisma.$UserPayload<ExtArgs>
      ride: Prisma.$RidePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rating: number
      comment: string | null
      rideId: string
      givenById: string
      receivedById: string
      createdAt: Date
      arrivalOnTime: boolean | null
      startOnTime: boolean | null
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    givenBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    receivedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ride<T extends RideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RideDefaultArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly comment: FieldRef<"Feedback", 'String'>
    readonly rideId: FieldRef<"Feedback", 'String'>
    readonly givenById: FieldRef<"Feedback", 'String'>
    readonly receivedById: FieldRef<"Feedback", 'String'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly arrivalOnTime: FieldRef<"Feedback", 'Boolean'>
    readonly startOnTime: FieldRef<"Feedback", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    threshold: number | null
  }

  export type BadgeSumAggregateOutputType = {
    threshold: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    createdAt: Date | null
    description: string | null
    threshold: number | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    createdAt: Date | null
    description: string | null
    threshold: number | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    createdAt: number
    description: number
    threshold: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    threshold?: true
  }

  export type BadgeSumAggregateInputType = {
    threshold?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    createdAt?: true
    description?: true
    threshold?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    createdAt?: true
    description?: true
    threshold?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    createdAt?: true
    description?: true
    threshold?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    icon: string
    createdAt: Date
    description: string
    threshold: number
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    createdAt?: boolean
    description?: boolean
    threshold?: boolean
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    createdAt?: boolean
    description?: boolean
    threshold?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    createdAt?: boolean
    description?: boolean
    threshold?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      users: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string
      createdAt: Date
      description: string
      threshold: number
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Badge$usersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly icon: FieldRef<"Badge", 'String'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly threshold: FieldRef<"Badge", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge.users
   */
  export type Badge$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserBadgeSumAggregateOutputType = {
    progress: number | null
  }

  export type UserBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    createdAt: Date | null
    earnedAt: Date | null
    lostAt: Date | null
    progress: number | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeId: string | null
    createdAt: Date | null
    earnedAt: Date | null
    lostAt: Date | null
    progress: number | null
  }

  export type UserBadgeCountAggregateOutputType = {
    id: number
    userId: number
    badgeId: number
    createdAt: number
    earnedAt: number
    lostAt: number
    progress: number
    _all: number
  }


  export type UserBadgeAvgAggregateInputType = {
    progress?: true
  }

  export type UserBadgeSumAggregateInputType = {
    progress?: true
  }

  export type UserBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    createdAt?: true
    earnedAt?: true
    lostAt?: true
    progress?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    createdAt?: true
    earnedAt?: true
    lostAt?: true
    progress?: true
  }

  export type UserBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    badgeId?: true
    createdAt?: true
    earnedAt?: true
    lostAt?: true
    progress?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _avg?: UserBadgeAvgAggregateInputType
    _sum?: UserBadgeSumAggregateInputType
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    id: string
    userId: string
    badgeId: string
    createdAt: Date
    earnedAt: Date | null
    lostAt: Date | null
    progress: number
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
    earnedAt?: boolean
    lostAt?: boolean
    progress?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
    earnedAt?: boolean
    lostAt?: boolean
    progress?: boolean
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
    earnedAt?: boolean
    lostAt?: boolean
    progress?: boolean
  }

  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      badge: Prisma.$BadgePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      badgeId: string
      createdAt: Date
      earnedAt: Date | null
      lostAt: Date | null
      progress: number
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */ 
  interface UserBadgeFieldRefs {
    readonly id: FieldRef<"UserBadge", 'String'>
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly createdAt: FieldRef<"UserBadge", 'DateTime'>
    readonly earnedAt: FieldRef<"UserBadge", 'DateTime'>
    readonly lostAt: FieldRef<"UserBadge", 'DateTime'>
    readonly progress: FieldRef<"UserBadge", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    code: string | null
    referrerId: string | null
    refereeId: string | null
    bonusGiven: boolean | null
    createdAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    code: string | null
    referrerId: string | null
    refereeId: string | null
    bonusGiven: boolean | null
    createdAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    code: number
    referrerId: number
    refereeId: number
    bonusGiven: number
    createdAt: number
    _all: number
  }


  export type ReferralMinAggregateInputType = {
    id?: true
    code?: true
    referrerId?: true
    refereeId?: true
    bonusGiven?: true
    createdAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    code?: true
    referrerId?: true
    refereeId?: true
    bonusGiven?: true
    createdAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    code?: true
    referrerId?: true
    refereeId?: true
    bonusGiven?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    code: string
    referrerId: string
    refereeId: string
    bonusGiven: boolean
    createdAt: Date
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    referrerId?: boolean
    refereeId?: boolean
    bonusGiven?: boolean
    createdAt?: boolean
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    referrerId?: boolean
    refereeId?: boolean
    bonusGiven?: boolean
    createdAt?: boolean
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    code?: boolean
    referrerId?: boolean
    refereeId?: boolean
    bonusGiven?: boolean
    createdAt?: boolean
  }

  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referee?: boolean | UserDefaultArgs<ExtArgs>
    referrer?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referee: Prisma.$UserPayload<ExtArgs>
      referrer: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      referrerId: string
      refereeId: string
      bonusGiven: boolean
      createdAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */ 
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly code: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly refereeId: FieldRef<"Referral", 'String'>
    readonly bonusGiven: FieldRef<"Referral", 'Boolean'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model AppConfig
   */

  export type AggregateAppConfig = {
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  export type AppConfigMinAggregateOutputType = {
    key: string | null
    value: string | null
  }

  export type AppConfigMaxAggregateOutputType = {
    key: string | null
    value: string | null
  }

  export type AppConfigCountAggregateOutputType = {
    key: number
    value: number
    _all: number
  }


  export type AppConfigMinAggregateInputType = {
    key?: true
    value?: true
  }

  export type AppConfigMaxAggregateInputType = {
    key?: true
    value?: true
  }

  export type AppConfigCountAggregateInputType = {
    key?: true
    value?: true
    _all?: true
  }

  export type AppConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfig to aggregate.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppConfigs
    **/
    _count?: true | AppConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppConfigMaxAggregateInputType
  }

  export type GetAppConfigAggregateType<T extends AppConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateAppConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppConfig[P]>
      : GetScalarType<T[P], AggregateAppConfig[P]>
  }




  export type AppConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppConfigWhereInput
    orderBy?: AppConfigOrderByWithAggregationInput | AppConfigOrderByWithAggregationInput[]
    by: AppConfigScalarFieldEnum[] | AppConfigScalarFieldEnum
    having?: AppConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppConfigCountAggregateInputType | true
    _min?: AppConfigMinAggregateInputType
    _max?: AppConfigMaxAggregateInputType
  }

  export type AppConfigGroupByOutputType = {
    key: string
    value: string
    _count: AppConfigCountAggregateOutputType | null
    _min: AppConfigMinAggregateOutputType | null
    _max: AppConfigMaxAggregateOutputType | null
  }

  type GetAppConfigGroupByPayload<T extends AppConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
            : GetScalarType<T[P], AppConfigGroupByOutputType[P]>
        }
      >
    >


  export type AppConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["appConfig"]>

  export type AppConfigSelectScalar = {
    key?: boolean
    value?: boolean
  }


  export type $AppConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
    }, ExtArgs["result"]["appConfig"]>
    composites: {}
  }

  type AppConfigGetPayload<S extends boolean | null | undefined | AppConfigDefaultArgs> = $Result.GetResult<Prisma.$AppConfigPayload, S>

  type AppConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppConfigFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppConfigCountAggregateInputType | true
    }

  export interface AppConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppConfig'], meta: { name: 'AppConfig' } }
    /**
     * Find zero or one AppConfig that matches the filter.
     * @param {AppConfigFindUniqueArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppConfigFindUniqueArgs>(args: SelectSubset<T, AppConfigFindUniqueArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AppConfig that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppConfigFindUniqueOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, AppConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AppConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppConfigFindFirstArgs>(args?: SelectSubset<T, AppConfigFindFirstArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AppConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindFirstOrThrowArgs} args - Arguments to find a AppConfig
     * @example
     * // Get one AppConfig
     * const appConfig = await prisma.appConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, AppConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AppConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppConfigs
     * const appConfigs = await prisma.appConfig.findMany()
     * 
     * // Get first 10 AppConfigs
     * const appConfigs = await prisma.appConfig.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const appConfigWithKeyOnly = await prisma.appConfig.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends AppConfigFindManyArgs>(args?: SelectSubset<T, AppConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AppConfig.
     * @param {AppConfigCreateArgs} args - Arguments to create a AppConfig.
     * @example
     * // Create one AppConfig
     * const AppConfig = await prisma.appConfig.create({
     *   data: {
     *     // ... data to create a AppConfig
     *   }
     * })
     * 
     */
    create<T extends AppConfigCreateArgs>(args: SelectSubset<T, AppConfigCreateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AppConfigs.
     * @param {AppConfigCreateManyArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppConfigCreateManyArgs>(args?: SelectSubset<T, AppConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppConfigs and returns the data saved in the database.
     * @param {AppConfigCreateManyAndReturnArgs} args - Arguments to create many AppConfigs.
     * @example
     * // Create many AppConfigs
     * const appConfig = await prisma.appConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppConfigs and only return the `key`
     * const appConfigWithKeyOnly = await prisma.appConfig.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, AppConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AppConfig.
     * @param {AppConfigDeleteArgs} args - Arguments to delete one AppConfig.
     * @example
     * // Delete one AppConfig
     * const AppConfig = await prisma.appConfig.delete({
     *   where: {
     *     // ... filter to delete one AppConfig
     *   }
     * })
     * 
     */
    delete<T extends AppConfigDeleteArgs>(args: SelectSubset<T, AppConfigDeleteArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AppConfig.
     * @param {AppConfigUpdateArgs} args - Arguments to update one AppConfig.
     * @example
     * // Update one AppConfig
     * const appConfig = await prisma.appConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppConfigUpdateArgs>(args: SelectSubset<T, AppConfigUpdateArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AppConfigs.
     * @param {AppConfigDeleteManyArgs} args - Arguments to filter AppConfigs to delete.
     * @example
     * // Delete a few AppConfigs
     * const { count } = await prisma.appConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppConfigDeleteManyArgs>(args?: SelectSubset<T, AppConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppConfigs
     * const appConfig = await prisma.appConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppConfigUpdateManyArgs>(args: SelectSubset<T, AppConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppConfig.
     * @param {AppConfigUpsertArgs} args - Arguments to update or create a AppConfig.
     * @example
     * // Update or create a AppConfig
     * const appConfig = await prisma.appConfig.upsert({
     *   create: {
     *     // ... data to create a AppConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppConfig we want to update
     *   }
     * })
     */
    upsert<T extends AppConfigUpsertArgs>(args: SelectSubset<T, AppConfigUpsertArgs<ExtArgs>>): Prisma__AppConfigClient<$Result.GetResult<Prisma.$AppConfigPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AppConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigCountArgs} args - Arguments to filter AppConfigs to count.
     * @example
     * // Count the number of AppConfigs
     * const count = await prisma.appConfig.count({
     *   where: {
     *     // ... the filter for the AppConfigs we want to count
     *   }
     * })
    **/
    count<T extends AppConfigCountArgs>(
      args?: Subset<T, AppConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppConfigAggregateArgs>(args: Subset<T, AppConfigAggregateArgs>): Prisma.PrismaPromise<GetAppConfigAggregateType<T>>

    /**
     * Group by AppConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppConfigGroupByArgs['orderBy'] }
        : { orderBy?: AppConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppConfig model
   */
  readonly fields: AppConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppConfig model
   */ 
  interface AppConfigFieldRefs {
    readonly key: FieldRef<"AppConfig", 'String'>
    readonly value: FieldRef<"AppConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AppConfig findUnique
   */
  export type AppConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findUniqueOrThrow
   */
  export type AppConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig findFirst
   */
  export type AppConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findFirstOrThrow
   */
  export type AppConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfig to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppConfigs.
     */
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig findMany
   */
  export type AppConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter, which AppConfigs to fetch.
     */
    where?: AppConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppConfigs to fetch.
     */
    orderBy?: AppConfigOrderByWithRelationInput | AppConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppConfigs.
     */
    cursor?: AppConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppConfigs.
     */
    skip?: number
    distinct?: AppConfigScalarFieldEnum | AppConfigScalarFieldEnum[]
  }

  /**
   * AppConfig create
   */
  export type AppConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * The data needed to create a AppConfig.
     */
    data: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
  }

  /**
   * AppConfig createMany
   */
  export type AppConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig createManyAndReturn
   */
  export type AppConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AppConfigs.
     */
    data: AppConfigCreateManyInput | AppConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppConfig update
   */
  export type AppConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * The data needed to update a AppConfig.
     */
    data: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
    /**
     * Choose, which AppConfig to update.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig updateMany
   */
  export type AppConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppConfigs.
     */
    data: XOR<AppConfigUpdateManyMutationInput, AppConfigUncheckedUpdateManyInput>
    /**
     * Filter which AppConfigs to update
     */
    where?: AppConfigWhereInput
  }

  /**
   * AppConfig upsert
   */
  export type AppConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * The filter to search for the AppConfig to update in case it exists.
     */
    where: AppConfigWhereUniqueInput
    /**
     * In case the AppConfig found by the `where` argument doesn't exist, create a new AppConfig with this data.
     */
    create: XOR<AppConfigCreateInput, AppConfigUncheckedCreateInput>
    /**
     * In case the AppConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppConfigUpdateInput, AppConfigUncheckedUpdateInput>
  }

  /**
   * AppConfig delete
   */
  export type AppConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
    /**
     * Filter which AppConfig to delete.
     */
    where: AppConfigWhereUniqueInput
  }

  /**
   * AppConfig deleteMany
   */
  export type AppConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppConfigs to delete
     */
    where?: AppConfigWhereInput
  }

  /**
   * AppConfig without action
   */
  export type AppConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppConfig
     */
    select?: AppConfigSelect<ExtArgs> | null
  }


  /**
   * Model UserStats
   */

  export type AggregateUserStats = {
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  export type UserStatsAvgAggregateOutputType = {
    onTimeStarts: number | null
    onTimeArrivals: number | null
    totalChatMessages: number | null
    fastResponses: number | null
    totalBookingsToAccept: number | null
    acceptedBookings: number | null
    totalCancellations: number | null
    totalRidesAsDriver: number | null
    totalRidesAsPassenger: number | null
    completedFreeRidesAsDriver: number | null
    fastResponseOpportunities: number | null
    fastResponseSuccesses: number | null
  }

  export type UserStatsSumAggregateOutputType = {
    onTimeStarts: number | null
    onTimeArrivals: number | null
    totalChatMessages: number | null
    fastResponses: number | null
    totalBookingsToAccept: number | null
    acceptedBookings: number | null
    totalCancellations: number | null
    totalRidesAsDriver: number | null
    totalRidesAsPassenger: number | null
    completedFreeRidesAsDriver: number | null
    fastResponseOpportunities: number | null
    fastResponseSuccesses: number | null
  }

  export type UserStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    onTimeStarts: number | null
    onTimeArrivals: number | null
    totalChatMessages: number | null
    fastResponses: number | null
    totalBookingsToAccept: number | null
    acceptedBookings: number | null
    totalCancellations: number | null
    totalRidesAsDriver: number | null
    totalRidesAsPassenger: number | null
    completedFreeRidesAsDriver: number | null
    fastResponseOpportunities: number | null
    fastResponseSuccesses: number | null
  }

  export type UserStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    onTimeStarts: number | null
    onTimeArrivals: number | null
    totalChatMessages: number | null
    fastResponses: number | null
    totalBookingsToAccept: number | null
    acceptedBookings: number | null
    totalCancellations: number | null
    totalRidesAsDriver: number | null
    totalRidesAsPassenger: number | null
    completedFreeRidesAsDriver: number | null
    fastResponseOpportunities: number | null
    fastResponseSuccesses: number | null
  }

  export type UserStatsCountAggregateOutputType = {
    id: number
    userId: number
    onTimeStarts: number
    onTimeArrivals: number
    totalChatMessages: number
    fastResponses: number
    totalBookingsToAccept: number
    acceptedBookings: number
    totalCancellations: number
    totalRidesAsDriver: number
    totalRidesAsPassenger: number
    completedFreeRidesAsDriver: number
    fastResponseOpportunities: number
    fastResponseSuccesses: number
    _all: number
  }


  export type UserStatsAvgAggregateInputType = {
    onTimeStarts?: true
    onTimeArrivals?: true
    totalChatMessages?: true
    fastResponses?: true
    totalBookingsToAccept?: true
    acceptedBookings?: true
    totalCancellations?: true
    totalRidesAsDriver?: true
    totalRidesAsPassenger?: true
    completedFreeRidesAsDriver?: true
    fastResponseOpportunities?: true
    fastResponseSuccesses?: true
  }

  export type UserStatsSumAggregateInputType = {
    onTimeStarts?: true
    onTimeArrivals?: true
    totalChatMessages?: true
    fastResponses?: true
    totalBookingsToAccept?: true
    acceptedBookings?: true
    totalCancellations?: true
    totalRidesAsDriver?: true
    totalRidesAsPassenger?: true
    completedFreeRidesAsDriver?: true
    fastResponseOpportunities?: true
    fastResponseSuccesses?: true
  }

  export type UserStatsMinAggregateInputType = {
    id?: true
    userId?: true
    onTimeStarts?: true
    onTimeArrivals?: true
    totalChatMessages?: true
    fastResponses?: true
    totalBookingsToAccept?: true
    acceptedBookings?: true
    totalCancellations?: true
    totalRidesAsDriver?: true
    totalRidesAsPassenger?: true
    completedFreeRidesAsDriver?: true
    fastResponseOpportunities?: true
    fastResponseSuccesses?: true
  }

  export type UserStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    onTimeStarts?: true
    onTimeArrivals?: true
    totalChatMessages?: true
    fastResponses?: true
    totalBookingsToAccept?: true
    acceptedBookings?: true
    totalCancellations?: true
    totalRidesAsDriver?: true
    totalRidesAsPassenger?: true
    completedFreeRidesAsDriver?: true
    fastResponseOpportunities?: true
    fastResponseSuccesses?: true
  }

  export type UserStatsCountAggregateInputType = {
    id?: true
    userId?: true
    onTimeStarts?: true
    onTimeArrivals?: true
    totalChatMessages?: true
    fastResponses?: true
    totalBookingsToAccept?: true
    acceptedBookings?: true
    totalCancellations?: true
    totalRidesAsDriver?: true
    totalRidesAsPassenger?: true
    completedFreeRidesAsDriver?: true
    fastResponseOpportunities?: true
    fastResponseSuccesses?: true
    _all?: true
  }

  export type UserStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to aggregate.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStats
    **/
    _count?: true | UserStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStatsMaxAggregateInputType
  }

  export type GetUserStatsAggregateType<T extends UserStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStats[P]>
      : GetScalarType<T[P], AggregateUserStats[P]>
  }




  export type UserStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStatsWhereInput
    orderBy?: UserStatsOrderByWithAggregationInput | UserStatsOrderByWithAggregationInput[]
    by: UserStatsScalarFieldEnum[] | UserStatsScalarFieldEnum
    having?: UserStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStatsCountAggregateInputType | true
    _avg?: UserStatsAvgAggregateInputType
    _sum?: UserStatsSumAggregateInputType
    _min?: UserStatsMinAggregateInputType
    _max?: UserStatsMaxAggregateInputType
  }

  export type UserStatsGroupByOutputType = {
    id: string
    userId: string
    onTimeStarts: number
    onTimeArrivals: number
    totalChatMessages: number
    fastResponses: number
    totalBookingsToAccept: number
    acceptedBookings: number
    totalCancellations: number
    totalRidesAsDriver: number
    totalRidesAsPassenger: number
    completedFreeRidesAsDriver: number
    fastResponseOpportunities: number
    fastResponseSuccesses: number
    _count: UserStatsCountAggregateOutputType | null
    _avg: UserStatsAvgAggregateOutputType | null
    _sum: UserStatsSumAggregateOutputType | null
    _min: UserStatsMinAggregateOutputType | null
    _max: UserStatsMaxAggregateOutputType | null
  }

  type GetUserStatsGroupByPayload<T extends UserStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
            : GetScalarType<T[P], UserStatsGroupByOutputType[P]>
        }
      >
    >


  export type UserStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onTimeStarts?: boolean
    onTimeArrivals?: boolean
    totalChatMessages?: boolean
    fastResponses?: boolean
    totalBookingsToAccept?: boolean
    acceptedBookings?: boolean
    totalCancellations?: boolean
    totalRidesAsDriver?: boolean
    totalRidesAsPassenger?: boolean
    completedFreeRidesAsDriver?: boolean
    fastResponseOpportunities?: boolean
    fastResponseSuccesses?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    onTimeStarts?: boolean
    onTimeArrivals?: boolean
    totalChatMessages?: boolean
    fastResponses?: boolean
    totalBookingsToAccept?: boolean
    acceptedBookings?: boolean
    totalCancellations?: boolean
    totalRidesAsDriver?: boolean
    totalRidesAsPassenger?: boolean
    completedFreeRidesAsDriver?: boolean
    fastResponseOpportunities?: boolean
    fastResponseSuccesses?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStats"]>

  export type UserStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    onTimeStarts?: boolean
    onTimeArrivals?: boolean
    totalChatMessages?: boolean
    fastResponses?: boolean
    totalBookingsToAccept?: boolean
    acceptedBookings?: boolean
    totalCancellations?: boolean
    totalRidesAsDriver?: boolean
    totalRidesAsPassenger?: boolean
    completedFreeRidesAsDriver?: boolean
    fastResponseOpportunities?: boolean
    fastResponseSuccesses?: boolean
  }

  export type UserStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      onTimeStarts: number
      onTimeArrivals: number
      totalChatMessages: number
      fastResponses: number
      totalBookingsToAccept: number
      acceptedBookings: number
      totalCancellations: number
      totalRidesAsDriver: number
      totalRidesAsPassenger: number
      completedFreeRidesAsDriver: number
      fastResponseOpportunities: number
      fastResponseSuccesses: number
    }, ExtArgs["result"]["userStats"]>
    composites: {}
  }

  type UserStatsGetPayload<S extends boolean | null | undefined | UserStatsDefaultArgs> = $Result.GetResult<Prisma.$UserStatsPayload, S>

  type UserStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserStatsCountAggregateInputType | true
    }

  export interface UserStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStats'], meta: { name: 'UserStats' } }
    /**
     * Find zero or one UserStats that matches the filter.
     * @param {UserStatsFindUniqueArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStatsFindUniqueArgs>(args: SelectSubset<T, UserStatsFindUniqueArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserStats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserStatsFindUniqueOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStatsFindFirstArgs>(args?: SelectSubset<T, UserStatsFindFirstArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindFirstOrThrowArgs} args - Arguments to find a UserStats
     * @example
     * // Get one UserStats
     * const userStats = await prisma.userStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStats
     * const userStats = await prisma.userStats.findMany()
     * 
     * // Get first 10 UserStats
     * const userStats = await prisma.userStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userStatsWithIdOnly = await prisma.userStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserStatsFindManyArgs>(args?: SelectSubset<T, UserStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserStats.
     * @param {UserStatsCreateArgs} args - Arguments to create a UserStats.
     * @example
     * // Create one UserStats
     * const UserStats = await prisma.userStats.create({
     *   data: {
     *     // ... data to create a UserStats
     *   }
     * })
     * 
     */
    create<T extends UserStatsCreateArgs>(args: SelectSubset<T, UserStatsCreateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserStats.
     * @param {UserStatsCreateManyArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStatsCreateManyArgs>(args?: SelectSubset<T, UserStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStats and returns the data saved in the database.
     * @param {UserStatsCreateManyAndReturnArgs} args - Arguments to create many UserStats.
     * @example
     * // Create many UserStats
     * const userStats = await prisma.userStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStats and only return the `id`
     * const userStatsWithIdOnly = await prisma.userStats.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserStats.
     * @param {UserStatsDeleteArgs} args - Arguments to delete one UserStats.
     * @example
     * // Delete one UserStats
     * const UserStats = await prisma.userStats.delete({
     *   where: {
     *     // ... filter to delete one UserStats
     *   }
     * })
     * 
     */
    delete<T extends UserStatsDeleteArgs>(args: SelectSubset<T, UserStatsDeleteArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserStats.
     * @param {UserStatsUpdateArgs} args - Arguments to update one UserStats.
     * @example
     * // Update one UserStats
     * const userStats = await prisma.userStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStatsUpdateArgs>(args: SelectSubset<T, UserStatsUpdateArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserStats.
     * @param {UserStatsDeleteManyArgs} args - Arguments to filter UserStats to delete.
     * @example
     * // Delete a few UserStats
     * const { count } = await prisma.userStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStatsDeleteManyArgs>(args?: SelectSubset<T, UserStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStats
     * const userStats = await prisma.userStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStatsUpdateManyArgs>(args: SelectSubset<T, UserStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserStats.
     * @param {UserStatsUpsertArgs} args - Arguments to update or create a UserStats.
     * @example
     * // Update or create a UserStats
     * const userStats = await prisma.userStats.upsert({
     *   create: {
     *     // ... data to create a UserStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStats we want to update
     *   }
     * })
     */
    upsert<T extends UserStatsUpsertArgs>(args: SelectSubset<T, UserStatsUpsertArgs<ExtArgs>>): Prisma__UserStatsClient<$Result.GetResult<Prisma.$UserStatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsCountArgs} args - Arguments to filter UserStats to count.
     * @example
     * // Count the number of UserStats
     * const count = await prisma.userStats.count({
     *   where: {
     *     // ... the filter for the UserStats we want to count
     *   }
     * })
    **/
    count<T extends UserStatsCountArgs>(
      args?: Subset<T, UserStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStatsAggregateArgs>(args: Subset<T, UserStatsAggregateArgs>): Prisma.PrismaPromise<GetUserStatsAggregateType<T>>

    /**
     * Group by UserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStatsGroupByArgs['orderBy'] }
        : { orderBy?: UserStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStats model
   */
  readonly fields: UserStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStats model
   */ 
  interface UserStatsFieldRefs {
    readonly id: FieldRef<"UserStats", 'String'>
    readonly userId: FieldRef<"UserStats", 'String'>
    readonly onTimeStarts: FieldRef<"UserStats", 'Int'>
    readonly onTimeArrivals: FieldRef<"UserStats", 'Int'>
    readonly totalChatMessages: FieldRef<"UserStats", 'Int'>
    readonly fastResponses: FieldRef<"UserStats", 'Int'>
    readonly totalBookingsToAccept: FieldRef<"UserStats", 'Int'>
    readonly acceptedBookings: FieldRef<"UserStats", 'Int'>
    readonly totalCancellations: FieldRef<"UserStats", 'Int'>
    readonly totalRidesAsDriver: FieldRef<"UserStats", 'Int'>
    readonly totalRidesAsPassenger: FieldRef<"UserStats", 'Int'>
    readonly completedFreeRidesAsDriver: FieldRef<"UserStats", 'Int'>
    readonly fastResponseOpportunities: FieldRef<"UserStats", 'Int'>
    readonly fastResponseSuccesses: FieldRef<"UserStats", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserStats findUnique
   */
  export type UserStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findUniqueOrThrow
   */
  export type UserStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats findFirst
   */
  export type UserStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findFirstOrThrow
   */
  export type UserStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStats.
     */
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats findMany
   */
  export type UserStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter, which UserStats to fetch.
     */
    where?: UserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStats to fetch.
     */
    orderBy?: UserStatsOrderByWithRelationInput | UserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStats.
     */
    cursor?: UserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStats.
     */
    skip?: number
    distinct?: UserStatsScalarFieldEnum | UserStatsScalarFieldEnum[]
  }

  /**
   * UserStats create
   */
  export type UserStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStats.
     */
    data: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
  }

  /**
   * UserStats createMany
   */
  export type UserStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserStats createManyAndReturn
   */
  export type UserStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserStats.
     */
    data: UserStatsCreateManyInput | UserStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStats update
   */
  export type UserStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStats.
     */
    data: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
    /**
     * Choose, which UserStats to update.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats updateMany
   */
  export type UserStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStats.
     */
    data: XOR<UserStatsUpdateManyMutationInput, UserStatsUncheckedUpdateManyInput>
    /**
     * Filter which UserStats to update
     */
    where?: UserStatsWhereInput
  }

  /**
   * UserStats upsert
   */
  export type UserStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStats to update in case it exists.
     */
    where: UserStatsWhereUniqueInput
    /**
     * In case the UserStats found by the `where` argument doesn't exist, create a new UserStats with this data.
     */
    create: XOR<UserStatsCreateInput, UserStatsUncheckedCreateInput>
    /**
     * In case the UserStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStatsUpdateInput, UserStatsUncheckedUpdateInput>
  }

  /**
   * UserStats delete
   */
  export type UserStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
    /**
     * Filter which UserStats to delete.
     */
    where: UserStatsWhereUniqueInput
  }

  /**
   * UserStats deleteMany
   */
  export type UserStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStats to delete
     */
    where?: UserStatsWhereInput
  }

  /**
   * UserStats without action
   */
  export type UserStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStats
     */
    select?: UserStatsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStatsInclude<ExtArgs> | null
  }


  /**
   * Model PromoCode
   */

  export type AggregatePromoCode = {
    _count: PromoCodeCountAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  export type PromoCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    isUsed: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PromoCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    isUsed: boolean | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PromoCodeCountAggregateOutputType = {
    id: number
    code: number
    userId: number
    isUsed: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type PromoCodeMinAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    isUsed?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PromoCodeMaxAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    isUsed?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PromoCodeCountAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    isUsed?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type PromoCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCode to aggregate.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoCodes
    **/
    _count?: true | PromoCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoCodeMaxAggregateInputType
  }

  export type GetPromoCodeAggregateType<T extends PromoCodeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoCode[P]>
      : GetScalarType<T[P], AggregatePromoCode[P]>
  }




  export type PromoCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoCodeWhereInput
    orderBy?: PromoCodeOrderByWithAggregationInput | PromoCodeOrderByWithAggregationInput[]
    by: PromoCodeScalarFieldEnum[] | PromoCodeScalarFieldEnum
    having?: PromoCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoCodeCountAggregateInputType | true
    _min?: PromoCodeMinAggregateInputType
    _max?: PromoCodeMaxAggregateInputType
  }

  export type PromoCodeGroupByOutputType = {
    id: string
    code: string
    userId: string
    isUsed: boolean
    createdAt: Date
    expiresAt: Date
    _count: PromoCodeCountAggregateOutputType | null
    _min: PromoCodeMinAggregateOutputType | null
    _max: PromoCodeMaxAggregateOutputType | null
  }

  type GetPromoCodeGroupByPayload<T extends PromoCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
            : GetScalarType<T[P], PromoCodeGroupByOutputType[P]>
        }
      >
    >


  export type PromoCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    isUsed?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    isUsed?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoCode"]>

  export type PromoCodeSelectScalar = {
    id?: boolean
    code?: boolean
    userId?: boolean
    isUsed?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type PromoCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PromoCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PromoCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoCode"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      userId: string
      isUsed: boolean
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["promoCode"]>
    composites: {}
  }

  type PromoCodeGetPayload<S extends boolean | null | undefined | PromoCodeDefaultArgs> = $Result.GetResult<Prisma.$PromoCodePayload, S>

  type PromoCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromoCodeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromoCodeCountAggregateInputType | true
    }

  export interface PromoCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoCode'], meta: { name: 'PromoCode' } }
    /**
     * Find zero or one PromoCode that matches the filter.
     * @param {PromoCodeFindUniqueArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoCodeFindUniqueArgs>(args: SelectSubset<T, PromoCodeFindUniqueArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromoCode that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromoCodeFindUniqueOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromoCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoCodeFindFirstArgs>(args?: SelectSubset<T, PromoCodeFindFirstArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromoCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindFirstOrThrowArgs} args - Arguments to find a PromoCode
     * @example
     * // Get one PromoCode
     * const promoCode = await prisma.promoCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromoCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoCodes
     * const promoCodes = await prisma.promoCode.findMany()
     * 
     * // Get first 10 PromoCodes
     * const promoCodes = await prisma.promoCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoCodeFindManyArgs>(args?: SelectSubset<T, PromoCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromoCode.
     * @param {PromoCodeCreateArgs} args - Arguments to create a PromoCode.
     * @example
     * // Create one PromoCode
     * const PromoCode = await prisma.promoCode.create({
     *   data: {
     *     // ... data to create a PromoCode
     *   }
     * })
     * 
     */
    create<T extends PromoCodeCreateArgs>(args: SelectSubset<T, PromoCodeCreateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromoCodes.
     * @param {PromoCodeCreateManyArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoCodeCreateManyArgs>(args?: SelectSubset<T, PromoCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoCodes and returns the data saved in the database.
     * @param {PromoCodeCreateManyAndReturnArgs} args - Arguments to create many PromoCodes.
     * @example
     * // Create many PromoCodes
     * const promoCode = await prisma.promoCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoCodes and only return the `id`
     * const promoCodeWithIdOnly = await prisma.promoCode.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromoCode.
     * @param {PromoCodeDeleteArgs} args - Arguments to delete one PromoCode.
     * @example
     * // Delete one PromoCode
     * const PromoCode = await prisma.promoCode.delete({
     *   where: {
     *     // ... filter to delete one PromoCode
     *   }
     * })
     * 
     */
    delete<T extends PromoCodeDeleteArgs>(args: SelectSubset<T, PromoCodeDeleteArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromoCode.
     * @param {PromoCodeUpdateArgs} args - Arguments to update one PromoCode.
     * @example
     * // Update one PromoCode
     * const promoCode = await prisma.promoCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoCodeUpdateArgs>(args: SelectSubset<T, PromoCodeUpdateArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromoCodes.
     * @param {PromoCodeDeleteManyArgs} args - Arguments to filter PromoCodes to delete.
     * @example
     * // Delete a few PromoCodes
     * const { count } = await prisma.promoCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoCodeDeleteManyArgs>(args?: SelectSubset<T, PromoCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoCodes
     * const promoCode = await prisma.promoCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoCodeUpdateManyArgs>(args: SelectSubset<T, PromoCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromoCode.
     * @param {PromoCodeUpsertArgs} args - Arguments to update or create a PromoCode.
     * @example
     * // Update or create a PromoCode
     * const promoCode = await prisma.promoCode.upsert({
     *   create: {
     *     // ... data to create a PromoCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoCode we want to update
     *   }
     * })
     */
    upsert<T extends PromoCodeUpsertArgs>(args: SelectSubset<T, PromoCodeUpsertArgs<ExtArgs>>): Prisma__PromoCodeClient<$Result.GetResult<Prisma.$PromoCodePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromoCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeCountArgs} args - Arguments to filter PromoCodes to count.
     * @example
     * // Count the number of PromoCodes
     * const count = await prisma.promoCode.count({
     *   where: {
     *     // ... the filter for the PromoCodes we want to count
     *   }
     * })
    **/
    count<T extends PromoCodeCountArgs>(
      args?: Subset<T, PromoCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoCodeAggregateArgs>(args: Subset<T, PromoCodeAggregateArgs>): Prisma.PrismaPromise<GetPromoCodeAggregateType<T>>

    /**
     * Group by PromoCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoCodeGroupByArgs['orderBy'] }
        : { orderBy?: PromoCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoCode model
   */
  readonly fields: PromoCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoCode model
   */ 
  interface PromoCodeFieldRefs {
    readonly id: FieldRef<"PromoCode", 'String'>
    readonly code: FieldRef<"PromoCode", 'String'>
    readonly userId: FieldRef<"PromoCode", 'String'>
    readonly isUsed: FieldRef<"PromoCode", 'Boolean'>
    readonly createdAt: FieldRef<"PromoCode", 'DateTime'>
    readonly expiresAt: FieldRef<"PromoCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoCode findUnique
   */
  export type PromoCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findUniqueOrThrow
   */
  export type PromoCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode findFirst
   */
  export type PromoCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findFirstOrThrow
   */
  export type PromoCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCode to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoCodes.
     */
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode findMany
   */
  export type PromoCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter, which PromoCodes to fetch.
     */
    where?: PromoCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoCodes to fetch.
     */
    orderBy?: PromoCodeOrderByWithRelationInput | PromoCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoCodes.
     */
    cursor?: PromoCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoCodes.
     */
    skip?: number
    distinct?: PromoCodeScalarFieldEnum | PromoCodeScalarFieldEnum[]
  }

  /**
   * PromoCode create
   */
  export type PromoCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoCode.
     */
    data: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
  }

  /**
   * PromoCode createMany
   */
  export type PromoCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoCode createManyAndReturn
   */
  export type PromoCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromoCodes.
     */
    data: PromoCodeCreateManyInput | PromoCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoCode update
   */
  export type PromoCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoCode.
     */
    data: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
    /**
     * Choose, which PromoCode to update.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode updateMany
   */
  export type PromoCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoCodes.
     */
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyInput>
    /**
     * Filter which PromoCodes to update
     */
    where?: PromoCodeWhereInput
  }

  /**
   * PromoCode upsert
   */
  export type PromoCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoCode to update in case it exists.
     */
    where: PromoCodeWhereUniqueInput
    /**
     * In case the PromoCode found by the `where` argument doesn't exist, create a new PromoCode with this data.
     */
    create: XOR<PromoCodeCreateInput, PromoCodeUncheckedCreateInput>
    /**
     * In case the PromoCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoCodeUpdateInput, PromoCodeUncheckedUpdateInput>
  }

  /**
   * PromoCode delete
   */
  export type PromoCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
    /**
     * Filter which PromoCode to delete.
     */
    where: PromoCodeWhereUniqueInput
  }

  /**
   * PromoCode deleteMany
   */
  export type PromoCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoCodes to delete
     */
    where?: PromoCodeWhereInput
  }

  /**
   * PromoCode without action
   */
  export type PromoCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoCode
     */
    select?: PromoCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoCodeInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    reason: string | null
    comment: string | null
    status: $Enums.ReportStatus | null
    rideId: string | null
    reporterId: string | null
    reportedUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    reason: string | null
    comment: string | null
    status: $Enums.ReportStatus | null
    rideId: string | null
    reporterId: string | null
    reportedUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reason: number
    comment: number
    status: number
    rideId: number
    reporterId: number
    reportedUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    reason?: true
    comment?: true
    status?: true
    rideId?: true
    reporterId?: true
    reportedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reason?: true
    comment?: true
    status?: true
    rideId?: true
    reporterId?: true
    reportedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reason?: true
    comment?: true
    status?: true
    rideId?: true
    reporterId?: true
    reportedUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    reason: string
    comment: string | null
    status: $Enums.ReportStatus
    rideId: string
    reporterId: string
    reportedUserId: string
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    comment?: boolean
    status?: boolean
    rideId?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    comment?: boolean
    status?: boolean
    rideId?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    reason?: boolean
    comment?: boolean
    status?: boolean
    rideId?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      reportedUser: Prisma.$UserPayload<ExtArgs>
      reporter: Prisma.$UserPayload<ExtArgs>
      ride: Prisma.$RidePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reason: string
      comment: string | null
      status: $Enums.ReportStatus
      rideId: string
      reporterId: string
      reportedUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reportedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ride<T extends RideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RideDefaultArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly comment: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly rideId: FieldRef<"Report", 'String'>
    readonly reporterId: FieldRef<"Report", 'String'>
    readonly reportedUserId: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model AdminLastVisit
   */

  export type AggregateAdminLastVisit = {
    _count: AdminLastVisitCountAggregateOutputType | null
    _min: AdminLastVisitMinAggregateOutputType | null
    _max: AdminLastVisitMaxAggregateOutputType | null
  }

  export type AdminLastVisitMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    resource: string | null
    lastVisitedAt: Date | null
  }

  export type AdminLastVisitMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    resource: string | null
    lastVisitedAt: Date | null
  }

  export type AdminLastVisitCountAggregateOutputType = {
    id: number
    adminId: number
    resource: number
    lastVisitedAt: number
    _all: number
  }


  export type AdminLastVisitMinAggregateInputType = {
    id?: true
    adminId?: true
    resource?: true
    lastVisitedAt?: true
  }

  export type AdminLastVisitMaxAggregateInputType = {
    id?: true
    adminId?: true
    resource?: true
    lastVisitedAt?: true
  }

  export type AdminLastVisitCountAggregateInputType = {
    id?: true
    adminId?: true
    resource?: true
    lastVisitedAt?: true
    _all?: true
  }

  export type AdminLastVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLastVisit to aggregate.
     */
    where?: AdminLastVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLastVisits to fetch.
     */
    orderBy?: AdminLastVisitOrderByWithRelationInput | AdminLastVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminLastVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLastVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLastVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminLastVisits
    **/
    _count?: true | AdminLastVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminLastVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminLastVisitMaxAggregateInputType
  }

  export type GetAdminLastVisitAggregateType<T extends AdminLastVisitAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminLastVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminLastVisit[P]>
      : GetScalarType<T[P], AggregateAdminLastVisit[P]>
  }




  export type AdminLastVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminLastVisitWhereInput
    orderBy?: AdminLastVisitOrderByWithAggregationInput | AdminLastVisitOrderByWithAggregationInput[]
    by: AdminLastVisitScalarFieldEnum[] | AdminLastVisitScalarFieldEnum
    having?: AdminLastVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminLastVisitCountAggregateInputType | true
    _min?: AdminLastVisitMinAggregateInputType
    _max?: AdminLastVisitMaxAggregateInputType
  }

  export type AdminLastVisitGroupByOutputType = {
    id: string
    adminId: string
    resource: string
    lastVisitedAt: Date
    _count: AdminLastVisitCountAggregateOutputType | null
    _min: AdminLastVisitMinAggregateOutputType | null
    _max: AdminLastVisitMaxAggregateOutputType | null
  }

  type GetAdminLastVisitGroupByPayload<T extends AdminLastVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminLastVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminLastVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminLastVisitGroupByOutputType[P]>
            : GetScalarType<T[P], AdminLastVisitGroupByOutputType[P]>
        }
      >
    >


  export type AdminLastVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    resource?: boolean
    lastVisitedAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLastVisit"]>

  export type AdminLastVisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    resource?: boolean
    lastVisitedAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminLastVisit"]>

  export type AdminLastVisitSelectScalar = {
    id?: boolean
    adminId?: boolean
    resource?: boolean
    lastVisitedAt?: boolean
  }

  export type AdminLastVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminLastVisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminLastVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminLastVisit"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      resource: string
      lastVisitedAt: Date
    }, ExtArgs["result"]["adminLastVisit"]>
    composites: {}
  }

  type AdminLastVisitGetPayload<S extends boolean | null | undefined | AdminLastVisitDefaultArgs> = $Result.GetResult<Prisma.$AdminLastVisitPayload, S>

  type AdminLastVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminLastVisitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminLastVisitCountAggregateInputType | true
    }

  export interface AdminLastVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminLastVisit'], meta: { name: 'AdminLastVisit' } }
    /**
     * Find zero or one AdminLastVisit that matches the filter.
     * @param {AdminLastVisitFindUniqueArgs} args - Arguments to find a AdminLastVisit
     * @example
     * // Get one AdminLastVisit
     * const adminLastVisit = await prisma.adminLastVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminLastVisitFindUniqueArgs>(args: SelectSubset<T, AdminLastVisitFindUniqueArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminLastVisit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminLastVisitFindUniqueOrThrowArgs} args - Arguments to find a AdminLastVisit
     * @example
     * // Get one AdminLastVisit
     * const adminLastVisit = await prisma.adminLastVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminLastVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminLastVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminLastVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLastVisitFindFirstArgs} args - Arguments to find a AdminLastVisit
     * @example
     * // Get one AdminLastVisit
     * const adminLastVisit = await prisma.adminLastVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminLastVisitFindFirstArgs>(args?: SelectSubset<T, AdminLastVisitFindFirstArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminLastVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLastVisitFindFirstOrThrowArgs} args - Arguments to find a AdminLastVisit
     * @example
     * // Get one AdminLastVisit
     * const adminLastVisit = await prisma.adminLastVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminLastVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminLastVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminLastVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLastVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminLastVisits
     * const adminLastVisits = await prisma.adminLastVisit.findMany()
     * 
     * // Get first 10 AdminLastVisits
     * const adminLastVisits = await prisma.adminLastVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminLastVisitWithIdOnly = await prisma.adminLastVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminLastVisitFindManyArgs>(args?: SelectSubset<T, AdminLastVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminLastVisit.
     * @param {AdminLastVisitCreateArgs} args - Arguments to create a AdminLastVisit.
     * @example
     * // Create one AdminLastVisit
     * const AdminLastVisit = await prisma.adminLastVisit.create({
     *   data: {
     *     // ... data to create a AdminLastVisit
     *   }
     * })
     * 
     */
    create<T extends AdminLastVisitCreateArgs>(args: SelectSubset<T, AdminLastVisitCreateArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminLastVisits.
     * @param {AdminLastVisitCreateManyArgs} args - Arguments to create many AdminLastVisits.
     * @example
     * // Create many AdminLastVisits
     * const adminLastVisit = await prisma.adminLastVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminLastVisitCreateManyArgs>(args?: SelectSubset<T, AdminLastVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminLastVisits and returns the data saved in the database.
     * @param {AdminLastVisitCreateManyAndReturnArgs} args - Arguments to create many AdminLastVisits.
     * @example
     * // Create many AdminLastVisits
     * const adminLastVisit = await prisma.adminLastVisit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminLastVisits and only return the `id`
     * const adminLastVisitWithIdOnly = await prisma.adminLastVisit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminLastVisitCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminLastVisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminLastVisit.
     * @param {AdminLastVisitDeleteArgs} args - Arguments to delete one AdminLastVisit.
     * @example
     * // Delete one AdminLastVisit
     * const AdminLastVisit = await prisma.adminLastVisit.delete({
     *   where: {
     *     // ... filter to delete one AdminLastVisit
     *   }
     * })
     * 
     */
    delete<T extends AdminLastVisitDeleteArgs>(args: SelectSubset<T, AdminLastVisitDeleteArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminLastVisit.
     * @param {AdminLastVisitUpdateArgs} args - Arguments to update one AdminLastVisit.
     * @example
     * // Update one AdminLastVisit
     * const adminLastVisit = await prisma.adminLastVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminLastVisitUpdateArgs>(args: SelectSubset<T, AdminLastVisitUpdateArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminLastVisits.
     * @param {AdminLastVisitDeleteManyArgs} args - Arguments to filter AdminLastVisits to delete.
     * @example
     * // Delete a few AdminLastVisits
     * const { count } = await prisma.adminLastVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminLastVisitDeleteManyArgs>(args?: SelectSubset<T, AdminLastVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminLastVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLastVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminLastVisits
     * const adminLastVisit = await prisma.adminLastVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminLastVisitUpdateManyArgs>(args: SelectSubset<T, AdminLastVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminLastVisit.
     * @param {AdminLastVisitUpsertArgs} args - Arguments to update or create a AdminLastVisit.
     * @example
     * // Update or create a AdminLastVisit
     * const adminLastVisit = await prisma.adminLastVisit.upsert({
     *   create: {
     *     // ... data to create a AdminLastVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminLastVisit we want to update
     *   }
     * })
     */
    upsert<T extends AdminLastVisitUpsertArgs>(args: SelectSubset<T, AdminLastVisitUpsertArgs<ExtArgs>>): Prisma__AdminLastVisitClient<$Result.GetResult<Prisma.$AdminLastVisitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminLastVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLastVisitCountArgs} args - Arguments to filter AdminLastVisits to count.
     * @example
     * // Count the number of AdminLastVisits
     * const count = await prisma.adminLastVisit.count({
     *   where: {
     *     // ... the filter for the AdminLastVisits we want to count
     *   }
     * })
    **/
    count<T extends AdminLastVisitCountArgs>(
      args?: Subset<T, AdminLastVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminLastVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminLastVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLastVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminLastVisitAggregateArgs>(args: Subset<T, AdminLastVisitAggregateArgs>): Prisma.PrismaPromise<GetAdminLastVisitAggregateType<T>>

    /**
     * Group by AdminLastVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminLastVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminLastVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminLastVisitGroupByArgs['orderBy'] }
        : { orderBy?: AdminLastVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminLastVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminLastVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminLastVisit model
   */
  readonly fields: AdminLastVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminLastVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminLastVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminLastVisit model
   */ 
  interface AdminLastVisitFieldRefs {
    readonly id: FieldRef<"AdminLastVisit", 'String'>
    readonly adminId: FieldRef<"AdminLastVisit", 'String'>
    readonly resource: FieldRef<"AdminLastVisit", 'String'>
    readonly lastVisitedAt: FieldRef<"AdminLastVisit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminLastVisit findUnique
   */
  export type AdminLastVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * Filter, which AdminLastVisit to fetch.
     */
    where: AdminLastVisitWhereUniqueInput
  }

  /**
   * AdminLastVisit findUniqueOrThrow
   */
  export type AdminLastVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * Filter, which AdminLastVisit to fetch.
     */
    where: AdminLastVisitWhereUniqueInput
  }

  /**
   * AdminLastVisit findFirst
   */
  export type AdminLastVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * Filter, which AdminLastVisit to fetch.
     */
    where?: AdminLastVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLastVisits to fetch.
     */
    orderBy?: AdminLastVisitOrderByWithRelationInput | AdminLastVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLastVisits.
     */
    cursor?: AdminLastVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLastVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLastVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLastVisits.
     */
    distinct?: AdminLastVisitScalarFieldEnum | AdminLastVisitScalarFieldEnum[]
  }

  /**
   * AdminLastVisit findFirstOrThrow
   */
  export type AdminLastVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * Filter, which AdminLastVisit to fetch.
     */
    where?: AdminLastVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLastVisits to fetch.
     */
    orderBy?: AdminLastVisitOrderByWithRelationInput | AdminLastVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminLastVisits.
     */
    cursor?: AdminLastVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLastVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLastVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminLastVisits.
     */
    distinct?: AdminLastVisitScalarFieldEnum | AdminLastVisitScalarFieldEnum[]
  }

  /**
   * AdminLastVisit findMany
   */
  export type AdminLastVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * Filter, which AdminLastVisits to fetch.
     */
    where?: AdminLastVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminLastVisits to fetch.
     */
    orderBy?: AdminLastVisitOrderByWithRelationInput | AdminLastVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminLastVisits.
     */
    cursor?: AdminLastVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminLastVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminLastVisits.
     */
    skip?: number
    distinct?: AdminLastVisitScalarFieldEnum | AdminLastVisitScalarFieldEnum[]
  }

  /**
   * AdminLastVisit create
   */
  export type AdminLastVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminLastVisit.
     */
    data: XOR<AdminLastVisitCreateInput, AdminLastVisitUncheckedCreateInput>
  }

  /**
   * AdminLastVisit createMany
   */
  export type AdminLastVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminLastVisits.
     */
    data: AdminLastVisitCreateManyInput | AdminLastVisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminLastVisit createManyAndReturn
   */
  export type AdminLastVisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminLastVisits.
     */
    data: AdminLastVisitCreateManyInput | AdminLastVisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminLastVisit update
   */
  export type AdminLastVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminLastVisit.
     */
    data: XOR<AdminLastVisitUpdateInput, AdminLastVisitUncheckedUpdateInput>
    /**
     * Choose, which AdminLastVisit to update.
     */
    where: AdminLastVisitWhereUniqueInput
  }

  /**
   * AdminLastVisit updateMany
   */
  export type AdminLastVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminLastVisits.
     */
    data: XOR<AdminLastVisitUpdateManyMutationInput, AdminLastVisitUncheckedUpdateManyInput>
    /**
     * Filter which AdminLastVisits to update
     */
    where?: AdminLastVisitWhereInput
  }

  /**
   * AdminLastVisit upsert
   */
  export type AdminLastVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminLastVisit to update in case it exists.
     */
    where: AdminLastVisitWhereUniqueInput
    /**
     * In case the AdminLastVisit found by the `where` argument doesn't exist, create a new AdminLastVisit with this data.
     */
    create: XOR<AdminLastVisitCreateInput, AdminLastVisitUncheckedCreateInput>
    /**
     * In case the AdminLastVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminLastVisitUpdateInput, AdminLastVisitUncheckedUpdateInput>
  }

  /**
   * AdminLastVisit delete
   */
  export type AdminLastVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
    /**
     * Filter which AdminLastVisit to delete.
     */
    where: AdminLastVisitWhereUniqueInput
  }

  /**
   * AdminLastVisit deleteMany
   */
  export type AdminLastVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminLastVisits to delete
     */
    where?: AdminLastVisitWhereInput
  }

  /**
   * AdminLastVisit without action
   */
  export type AdminLastVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminLastVisit
     */
    select?: AdminLastVisitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminLastVisitInclude<ExtArgs> | null
  }


  /**
   * Model SavedRoute
   */

  export type AggregateSavedRoute = {
    _count: SavedRouteCountAggregateOutputType | null
    _avg: SavedRouteAvgAggregateOutputType | null
    _sum: SavedRouteSumAggregateOutputType | null
    _min: SavedRouteMinAggregateOutputType | null
    _max: SavedRouteMaxAggregateOutputType | null
  }

  export type SavedRouteAvgAggregateOutputType = {
    originLat: number | null
    originLng: number | null
    destinationLat: number | null
    destinationLng: number | null
  }

  export type SavedRouteSumAggregateOutputType = {
    originLat: number | null
    originLng: number | null
    destinationLat: number | null
    destinationLng: number | null
  }

  export type SavedRouteMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    polyline: string | null
    originAddress: string | null
    originLat: number | null
    originLng: number | null
    originCity: string | null
    originSuburb: string | null
    destinationAddress: string | null
    destinationLat: number | null
    destinationLng: number | null
    destinationCity: string | null
    destinationSuburb: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type SavedRouteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    polyline: string | null
    originAddress: string | null
    originLat: number | null
    originLng: number | null
    originCity: string | null
    originSuburb: string | null
    destinationAddress: string | null
    destinationLat: number | null
    destinationLng: number | null
    destinationCity: string | null
    destinationSuburb: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type SavedRouteCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    polyline: number
    originAddress: number
    originLat: number
    originLng: number
    originCity: number
    originSuburb: number
    destinationAddress: number
    destinationLat: number
    destinationLng: number
    destinationCity: number
    destinationSuburb: number
    userId: number
    createdAt: number
    _all: number
  }


  export type SavedRouteAvgAggregateInputType = {
    originLat?: true
    originLng?: true
    destinationLat?: true
    destinationLng?: true
  }

  export type SavedRouteSumAggregateInputType = {
    originLat?: true
    originLng?: true
    destinationLat?: true
    destinationLng?: true
  }

  export type SavedRouteMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    polyline?: true
    originAddress?: true
    originLat?: true
    originLng?: true
    originCity?: true
    originSuburb?: true
    destinationAddress?: true
    destinationLat?: true
    destinationLng?: true
    destinationCity?: true
    destinationSuburb?: true
    userId?: true
    createdAt?: true
  }

  export type SavedRouteMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    polyline?: true
    originAddress?: true
    originLat?: true
    originLng?: true
    originCity?: true
    originSuburb?: true
    destinationAddress?: true
    destinationLat?: true
    destinationLng?: true
    destinationCity?: true
    destinationSuburb?: true
    userId?: true
    createdAt?: true
  }

  export type SavedRouteCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    polyline?: true
    originAddress?: true
    originLat?: true
    originLng?: true
    originCity?: true
    originSuburb?: true
    destinationAddress?: true
    destinationLat?: true
    destinationLng?: true
    destinationCity?: true
    destinationSuburb?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type SavedRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedRoute to aggregate.
     */
    where?: SavedRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedRoutes to fetch.
     */
    orderBy?: SavedRouteOrderByWithRelationInput | SavedRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedRoutes
    **/
    _count?: true | SavedRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavedRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavedRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedRouteMaxAggregateInputType
  }

  export type GetSavedRouteAggregateType<T extends SavedRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedRoute[P]>
      : GetScalarType<T[P], AggregateSavedRoute[P]>
  }




  export type SavedRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedRouteWhereInput
    orderBy?: SavedRouteOrderByWithAggregationInput | SavedRouteOrderByWithAggregationInput[]
    by: SavedRouteScalarFieldEnum[] | SavedRouteScalarFieldEnum
    having?: SavedRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedRouteCountAggregateInputType | true
    _avg?: SavedRouteAvgAggregateInputType
    _sum?: SavedRouteSumAggregateInputType
    _min?: SavedRouteMinAggregateInputType
    _max?: SavedRouteMaxAggregateInputType
  }

  export type SavedRouteGroupByOutputType = {
    id: string
    name: string
    icon: string | null
    polyline: string | null
    originAddress: string
    originLat: number
    originLng: number
    originCity: string | null
    originSuburb: string | null
    destinationAddress: string
    destinationLat: number
    destinationLng: number
    destinationCity: string | null
    destinationSuburb: string | null
    userId: string
    createdAt: Date
    _count: SavedRouteCountAggregateOutputType | null
    _avg: SavedRouteAvgAggregateOutputType | null
    _sum: SavedRouteSumAggregateOutputType | null
    _min: SavedRouteMinAggregateOutputType | null
    _max: SavedRouteMaxAggregateOutputType | null
  }

  type GetSavedRouteGroupByPayload<T extends SavedRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedRouteGroupByOutputType[P]>
            : GetScalarType<T[P], SavedRouteGroupByOutputType[P]>
        }
      >
    >


  export type SavedRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    polyline?: boolean
    originAddress?: boolean
    originLat?: boolean
    originLng?: boolean
    originCity?: boolean
    originSuburb?: boolean
    destinationAddress?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    destinationCity?: boolean
    destinationSuburb?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedRoute"]>

  export type SavedRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    polyline?: boolean
    originAddress?: boolean
    originLat?: boolean
    originLng?: boolean
    originCity?: boolean
    originSuburb?: boolean
    destinationAddress?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    destinationCity?: boolean
    destinationSuburb?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedRoute"]>

  export type SavedRouteSelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    polyline?: boolean
    originAddress?: boolean
    originLat?: boolean
    originLng?: boolean
    originCity?: boolean
    originSuburb?: boolean
    destinationAddress?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    destinationCity?: boolean
    destinationSuburb?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type SavedRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SavedRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SavedRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedRoute"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string | null
      polyline: string | null
      originAddress: string
      originLat: number
      originLng: number
      originCity: string | null
      originSuburb: string | null
      destinationAddress: string
      destinationLat: number
      destinationLng: number
      destinationCity: string | null
      destinationSuburb: string | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["savedRoute"]>
    composites: {}
  }

  type SavedRouteGetPayload<S extends boolean | null | undefined | SavedRouteDefaultArgs> = $Result.GetResult<Prisma.$SavedRoutePayload, S>

  type SavedRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavedRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavedRouteCountAggregateInputType | true
    }

  export interface SavedRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedRoute'], meta: { name: 'SavedRoute' } }
    /**
     * Find zero or one SavedRoute that matches the filter.
     * @param {SavedRouteFindUniqueArgs} args - Arguments to find a SavedRoute
     * @example
     * // Get one SavedRoute
     * const savedRoute = await prisma.savedRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedRouteFindUniqueArgs>(args: SelectSubset<T, SavedRouteFindUniqueArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavedRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavedRouteFindUniqueOrThrowArgs} args - Arguments to find a SavedRoute
     * @example
     * // Get one SavedRoute
     * const savedRoute = await prisma.savedRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavedRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedRouteFindFirstArgs} args - Arguments to find a SavedRoute
     * @example
     * // Get one SavedRoute
     * const savedRoute = await prisma.savedRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedRouteFindFirstArgs>(args?: SelectSubset<T, SavedRouteFindFirstArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavedRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedRouteFindFirstOrThrowArgs} args - Arguments to find a SavedRoute
     * @example
     * // Get one SavedRoute
     * const savedRoute = await prisma.savedRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavedRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedRoutes
     * const savedRoutes = await prisma.savedRoute.findMany()
     * 
     * // Get first 10 SavedRoutes
     * const savedRoutes = await prisma.savedRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedRouteWithIdOnly = await prisma.savedRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedRouteFindManyArgs>(args?: SelectSubset<T, SavedRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavedRoute.
     * @param {SavedRouteCreateArgs} args - Arguments to create a SavedRoute.
     * @example
     * // Create one SavedRoute
     * const SavedRoute = await prisma.savedRoute.create({
     *   data: {
     *     // ... data to create a SavedRoute
     *   }
     * })
     * 
     */
    create<T extends SavedRouteCreateArgs>(args: SelectSubset<T, SavedRouteCreateArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavedRoutes.
     * @param {SavedRouteCreateManyArgs} args - Arguments to create many SavedRoutes.
     * @example
     * // Create many SavedRoutes
     * const savedRoute = await prisma.savedRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedRouteCreateManyArgs>(args?: SelectSubset<T, SavedRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedRoutes and returns the data saved in the database.
     * @param {SavedRouteCreateManyAndReturnArgs} args - Arguments to create many SavedRoutes.
     * @example
     * // Create many SavedRoutes
     * const savedRoute = await prisma.savedRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedRoutes and only return the `id`
     * const savedRouteWithIdOnly = await prisma.savedRoute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SavedRoute.
     * @param {SavedRouteDeleteArgs} args - Arguments to delete one SavedRoute.
     * @example
     * // Delete one SavedRoute
     * const SavedRoute = await prisma.savedRoute.delete({
     *   where: {
     *     // ... filter to delete one SavedRoute
     *   }
     * })
     * 
     */
    delete<T extends SavedRouteDeleteArgs>(args: SelectSubset<T, SavedRouteDeleteArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavedRoute.
     * @param {SavedRouteUpdateArgs} args - Arguments to update one SavedRoute.
     * @example
     * // Update one SavedRoute
     * const savedRoute = await prisma.savedRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedRouteUpdateArgs>(args: SelectSubset<T, SavedRouteUpdateArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavedRoutes.
     * @param {SavedRouteDeleteManyArgs} args - Arguments to filter SavedRoutes to delete.
     * @example
     * // Delete a few SavedRoutes
     * const { count } = await prisma.savedRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedRouteDeleteManyArgs>(args?: SelectSubset<T, SavedRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedRoutes
     * const savedRoute = await prisma.savedRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedRouteUpdateManyArgs>(args: SelectSubset<T, SavedRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedRoute.
     * @param {SavedRouteUpsertArgs} args - Arguments to update or create a SavedRoute.
     * @example
     * // Update or create a SavedRoute
     * const savedRoute = await prisma.savedRoute.upsert({
     *   create: {
     *     // ... data to create a SavedRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedRoute we want to update
     *   }
     * })
     */
    upsert<T extends SavedRouteUpsertArgs>(args: SelectSubset<T, SavedRouteUpsertArgs<ExtArgs>>): Prisma__SavedRouteClient<$Result.GetResult<Prisma.$SavedRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SavedRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedRouteCountArgs} args - Arguments to filter SavedRoutes to count.
     * @example
     * // Count the number of SavedRoutes
     * const count = await prisma.savedRoute.count({
     *   where: {
     *     // ... the filter for the SavedRoutes we want to count
     *   }
     * })
    **/
    count<T extends SavedRouteCountArgs>(
      args?: Subset<T, SavedRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedRouteAggregateArgs>(args: Subset<T, SavedRouteAggregateArgs>): Prisma.PrismaPromise<GetSavedRouteAggregateType<T>>

    /**
     * Group by SavedRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedRouteGroupByArgs['orderBy'] }
        : { orderBy?: SavedRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedRoute model
   */
  readonly fields: SavedRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedRoute model
   */ 
  interface SavedRouteFieldRefs {
    readonly id: FieldRef<"SavedRoute", 'String'>
    readonly name: FieldRef<"SavedRoute", 'String'>
    readonly icon: FieldRef<"SavedRoute", 'String'>
    readonly polyline: FieldRef<"SavedRoute", 'String'>
    readonly originAddress: FieldRef<"SavedRoute", 'String'>
    readonly originLat: FieldRef<"SavedRoute", 'Float'>
    readonly originLng: FieldRef<"SavedRoute", 'Float'>
    readonly originCity: FieldRef<"SavedRoute", 'String'>
    readonly originSuburb: FieldRef<"SavedRoute", 'String'>
    readonly destinationAddress: FieldRef<"SavedRoute", 'String'>
    readonly destinationLat: FieldRef<"SavedRoute", 'Float'>
    readonly destinationLng: FieldRef<"SavedRoute", 'Float'>
    readonly destinationCity: FieldRef<"SavedRoute", 'String'>
    readonly destinationSuburb: FieldRef<"SavedRoute", 'String'>
    readonly userId: FieldRef<"SavedRoute", 'String'>
    readonly createdAt: FieldRef<"SavedRoute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedRoute findUnique
   */
  export type SavedRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * Filter, which SavedRoute to fetch.
     */
    where: SavedRouteWhereUniqueInput
  }

  /**
   * SavedRoute findUniqueOrThrow
   */
  export type SavedRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * Filter, which SavedRoute to fetch.
     */
    where: SavedRouteWhereUniqueInput
  }

  /**
   * SavedRoute findFirst
   */
  export type SavedRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * Filter, which SavedRoute to fetch.
     */
    where?: SavedRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedRoutes to fetch.
     */
    orderBy?: SavedRouteOrderByWithRelationInput | SavedRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedRoutes.
     */
    cursor?: SavedRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedRoutes.
     */
    distinct?: SavedRouteScalarFieldEnum | SavedRouteScalarFieldEnum[]
  }

  /**
   * SavedRoute findFirstOrThrow
   */
  export type SavedRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * Filter, which SavedRoute to fetch.
     */
    where?: SavedRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedRoutes to fetch.
     */
    orderBy?: SavedRouteOrderByWithRelationInput | SavedRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedRoutes.
     */
    cursor?: SavedRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedRoutes.
     */
    distinct?: SavedRouteScalarFieldEnum | SavedRouteScalarFieldEnum[]
  }

  /**
   * SavedRoute findMany
   */
  export type SavedRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * Filter, which SavedRoutes to fetch.
     */
    where?: SavedRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedRoutes to fetch.
     */
    orderBy?: SavedRouteOrderByWithRelationInput | SavedRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedRoutes.
     */
    cursor?: SavedRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedRoutes.
     */
    skip?: number
    distinct?: SavedRouteScalarFieldEnum | SavedRouteScalarFieldEnum[]
  }

  /**
   * SavedRoute create
   */
  export type SavedRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedRoute.
     */
    data: XOR<SavedRouteCreateInput, SavedRouteUncheckedCreateInput>
  }

  /**
   * SavedRoute createMany
   */
  export type SavedRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedRoutes.
     */
    data: SavedRouteCreateManyInput | SavedRouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SavedRoute createManyAndReturn
   */
  export type SavedRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SavedRoutes.
     */
    data: SavedRouteCreateManyInput | SavedRouteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedRoute update
   */
  export type SavedRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedRoute.
     */
    data: XOR<SavedRouteUpdateInput, SavedRouteUncheckedUpdateInput>
    /**
     * Choose, which SavedRoute to update.
     */
    where: SavedRouteWhereUniqueInput
  }

  /**
   * SavedRoute updateMany
   */
  export type SavedRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedRoutes.
     */
    data: XOR<SavedRouteUpdateManyMutationInput, SavedRouteUncheckedUpdateManyInput>
    /**
     * Filter which SavedRoutes to update
     */
    where?: SavedRouteWhereInput
  }

  /**
   * SavedRoute upsert
   */
  export type SavedRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedRoute to update in case it exists.
     */
    where: SavedRouteWhereUniqueInput
    /**
     * In case the SavedRoute found by the `where` argument doesn't exist, create a new SavedRoute with this data.
     */
    create: XOR<SavedRouteCreateInput, SavedRouteUncheckedCreateInput>
    /**
     * In case the SavedRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedRouteUpdateInput, SavedRouteUncheckedUpdateInput>
  }

  /**
   * SavedRoute delete
   */
  export type SavedRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
    /**
     * Filter which SavedRoute to delete.
     */
    where: SavedRouteWhereUniqueInput
  }

  /**
   * SavedRoute deleteMany
   */
  export type SavedRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedRoutes to delete
     */
    where?: SavedRouteWhereInput
  }

  /**
   * SavedRoute without action
   */
  export type SavedRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedRoute
     */
    select?: SavedRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedRouteInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledRide
   */

  export type AggregateScheduledRide = {
    _count: ScheduledRideCountAggregateOutputType | null
    _avg: ScheduledRideAvgAggregateOutputType | null
    _sum: ScheduledRideSumAggregateOutputType | null
    _min: ScheduledRideMinAggregateOutputType | null
    _max: ScheduledRideMaxAggregateOutputType | null
  }

  export type ScheduledRideAvgAggregateOutputType = {
    originLat: number | null
    originLng: number | null
    destinationLat: number | null
    destinationLng: number | null
    seats: number | null
    price: number | null
    daysOfWeek: number | null
  }

  export type ScheduledRideSumAggregateOutputType = {
    originLat: number | null
    originLng: number | null
    destinationLat: number | null
    destinationLng: number | null
    seats: number | null
    price: number | null
    daysOfWeek: number[]
  }

  export type ScheduledRideMinAggregateOutputType = {
    id: string | null
    origin: string | null
    destination: string | null
    fromCity: string | null
    toCity: string | null
    originLat: number | null
    originLng: number | null
    destinationLat: number | null
    destinationLng: number | null
    seats: number | null
    price: number | null
    scheduleTime: string | null
    isActive: boolean | null
    driverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fromSuburb: string | null
    toSuburb: string | null
  }

  export type ScheduledRideMaxAggregateOutputType = {
    id: string | null
    origin: string | null
    destination: string | null
    fromCity: string | null
    toCity: string | null
    originLat: number | null
    originLng: number | null
    destinationLat: number | null
    destinationLng: number | null
    seats: number | null
    price: number | null
    scheduleTime: string | null
    isActive: boolean | null
    driverId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    fromSuburb: string | null
    toSuburb: string | null
  }

  export type ScheduledRideCountAggregateOutputType = {
    id: number
    origin: number
    destination: number
    fromCity: number
    toCity: number
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: number
    daysOfWeek: number
    isActive: number
    driverId: number
    createdAt: number
    updatedAt: number
    fromSuburb: number
    toSuburb: number
    _all: number
  }


  export type ScheduledRideAvgAggregateInputType = {
    originLat?: true
    originLng?: true
    destinationLat?: true
    destinationLng?: true
    seats?: true
    price?: true
    daysOfWeek?: true
  }

  export type ScheduledRideSumAggregateInputType = {
    originLat?: true
    originLng?: true
    destinationLat?: true
    destinationLng?: true
    seats?: true
    price?: true
    daysOfWeek?: true
  }

  export type ScheduledRideMinAggregateInputType = {
    id?: true
    origin?: true
    destination?: true
    fromCity?: true
    toCity?: true
    originLat?: true
    originLng?: true
    destinationLat?: true
    destinationLng?: true
    seats?: true
    price?: true
    scheduleTime?: true
    isActive?: true
    driverId?: true
    createdAt?: true
    updatedAt?: true
    fromSuburb?: true
    toSuburb?: true
  }

  export type ScheduledRideMaxAggregateInputType = {
    id?: true
    origin?: true
    destination?: true
    fromCity?: true
    toCity?: true
    originLat?: true
    originLng?: true
    destinationLat?: true
    destinationLng?: true
    seats?: true
    price?: true
    scheduleTime?: true
    isActive?: true
    driverId?: true
    createdAt?: true
    updatedAt?: true
    fromSuburb?: true
    toSuburb?: true
  }

  export type ScheduledRideCountAggregateInputType = {
    id?: true
    origin?: true
    destination?: true
    fromCity?: true
    toCity?: true
    originLat?: true
    originLng?: true
    destinationLat?: true
    destinationLng?: true
    seats?: true
    price?: true
    scheduleTime?: true
    daysOfWeek?: true
    isActive?: true
    driverId?: true
    createdAt?: true
    updatedAt?: true
    fromSuburb?: true
    toSuburb?: true
    _all?: true
  }

  export type ScheduledRideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledRide to aggregate.
     */
    where?: ScheduledRideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRides to fetch.
     */
    orderBy?: ScheduledRideOrderByWithRelationInput | ScheduledRideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledRideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledRides
    **/
    _count?: true | ScheduledRideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduledRideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduledRideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledRideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledRideMaxAggregateInputType
  }

  export type GetScheduledRideAggregateType<T extends ScheduledRideAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledRide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledRide[P]>
      : GetScalarType<T[P], AggregateScheduledRide[P]>
  }




  export type ScheduledRideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledRideWhereInput
    orderBy?: ScheduledRideOrderByWithAggregationInput | ScheduledRideOrderByWithAggregationInput[]
    by: ScheduledRideScalarFieldEnum[] | ScheduledRideScalarFieldEnum
    having?: ScheduledRideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledRideCountAggregateInputType | true
    _avg?: ScheduledRideAvgAggregateInputType
    _sum?: ScheduledRideSumAggregateInputType
    _min?: ScheduledRideMinAggregateInputType
    _max?: ScheduledRideMaxAggregateInputType
  }

  export type ScheduledRideGroupByOutputType = {
    id: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek: number[]
    isActive: boolean
    driverId: string
    createdAt: Date
    updatedAt: Date
    fromSuburb: string | null
    toSuburb: string | null
    _count: ScheduledRideCountAggregateOutputType | null
    _avg: ScheduledRideAvgAggregateOutputType | null
    _sum: ScheduledRideSumAggregateOutputType | null
    _min: ScheduledRideMinAggregateOutputType | null
    _max: ScheduledRideMaxAggregateOutputType | null
  }

  type GetScheduledRideGroupByPayload<T extends ScheduledRideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledRideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledRideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledRideGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledRideGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledRideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin?: boolean
    destination?: boolean
    fromCity?: boolean
    toCity?: boolean
    originLat?: boolean
    originLng?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    seats?: boolean
    price?: boolean
    scheduleTime?: boolean
    daysOfWeek?: boolean
    isActive?: boolean
    driverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromSuburb?: boolean
    toSuburb?: boolean
    driver?: boolean | UserDefaultArgs<ExtArgs>
    createdRides?: boolean | ScheduledRide$createdRidesArgs<ExtArgs>
    _count?: boolean | ScheduledRideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledRide"]>

  export type ScheduledRideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    origin?: boolean
    destination?: boolean
    fromCity?: boolean
    toCity?: boolean
    originLat?: boolean
    originLng?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    seats?: boolean
    price?: boolean
    scheduleTime?: boolean
    daysOfWeek?: boolean
    isActive?: boolean
    driverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromSuburb?: boolean
    toSuburb?: boolean
    driver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledRide"]>

  export type ScheduledRideSelectScalar = {
    id?: boolean
    origin?: boolean
    destination?: boolean
    fromCity?: boolean
    toCity?: boolean
    originLat?: boolean
    originLng?: boolean
    destinationLat?: boolean
    destinationLng?: boolean
    seats?: boolean
    price?: boolean
    scheduleTime?: boolean
    daysOfWeek?: boolean
    isActive?: boolean
    driverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromSuburb?: boolean
    toSuburb?: boolean
  }

  export type ScheduledRideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | UserDefaultArgs<ExtArgs>
    createdRides?: boolean | ScheduledRide$createdRidesArgs<ExtArgs>
    _count?: boolean | ScheduledRideCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduledRideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ScheduledRidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledRide"
    objects: {
      driver: Prisma.$UserPayload<ExtArgs>
      createdRides: Prisma.$RidePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      origin: string
      destination: string
      fromCity: string
      toCity: string
      originLat: number
      originLng: number
      destinationLat: number
      destinationLng: number
      seats: number
      price: number
      scheduleTime: string
      daysOfWeek: number[]
      isActive: boolean
      driverId: string
      createdAt: Date
      updatedAt: Date
      fromSuburb: string | null
      toSuburb: string | null
    }, ExtArgs["result"]["scheduledRide"]>
    composites: {}
  }

  type ScheduledRideGetPayload<S extends boolean | null | undefined | ScheduledRideDefaultArgs> = $Result.GetResult<Prisma.$ScheduledRidePayload, S>

  type ScheduledRideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduledRideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduledRideCountAggregateInputType | true
    }

  export interface ScheduledRideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledRide'], meta: { name: 'ScheduledRide' } }
    /**
     * Find zero or one ScheduledRide that matches the filter.
     * @param {ScheduledRideFindUniqueArgs} args - Arguments to find a ScheduledRide
     * @example
     * // Get one ScheduledRide
     * const scheduledRide = await prisma.scheduledRide.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledRideFindUniqueArgs>(args: SelectSubset<T, ScheduledRideFindUniqueArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ScheduledRide that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduledRideFindUniqueOrThrowArgs} args - Arguments to find a ScheduledRide
     * @example
     * // Get one ScheduledRide
     * const scheduledRide = await prisma.scheduledRide.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledRideFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledRideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ScheduledRide that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRideFindFirstArgs} args - Arguments to find a ScheduledRide
     * @example
     * // Get one ScheduledRide
     * const scheduledRide = await prisma.scheduledRide.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledRideFindFirstArgs>(args?: SelectSubset<T, ScheduledRideFindFirstArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ScheduledRide that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRideFindFirstOrThrowArgs} args - Arguments to find a ScheduledRide
     * @example
     * // Get one ScheduledRide
     * const scheduledRide = await prisma.scheduledRide.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledRideFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledRideFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ScheduledRides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledRides
     * const scheduledRides = await prisma.scheduledRide.findMany()
     * 
     * // Get first 10 ScheduledRides
     * const scheduledRides = await prisma.scheduledRide.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledRideWithIdOnly = await prisma.scheduledRide.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledRideFindManyArgs>(args?: SelectSubset<T, ScheduledRideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ScheduledRide.
     * @param {ScheduledRideCreateArgs} args - Arguments to create a ScheduledRide.
     * @example
     * // Create one ScheduledRide
     * const ScheduledRide = await prisma.scheduledRide.create({
     *   data: {
     *     // ... data to create a ScheduledRide
     *   }
     * })
     * 
     */
    create<T extends ScheduledRideCreateArgs>(args: SelectSubset<T, ScheduledRideCreateArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ScheduledRides.
     * @param {ScheduledRideCreateManyArgs} args - Arguments to create many ScheduledRides.
     * @example
     * // Create many ScheduledRides
     * const scheduledRide = await prisma.scheduledRide.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledRideCreateManyArgs>(args?: SelectSubset<T, ScheduledRideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduledRides and returns the data saved in the database.
     * @param {ScheduledRideCreateManyAndReturnArgs} args - Arguments to create many ScheduledRides.
     * @example
     * // Create many ScheduledRides
     * const scheduledRide = await prisma.scheduledRide.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduledRides and only return the `id`
     * const scheduledRideWithIdOnly = await prisma.scheduledRide.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduledRideCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduledRideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ScheduledRide.
     * @param {ScheduledRideDeleteArgs} args - Arguments to delete one ScheduledRide.
     * @example
     * // Delete one ScheduledRide
     * const ScheduledRide = await prisma.scheduledRide.delete({
     *   where: {
     *     // ... filter to delete one ScheduledRide
     *   }
     * })
     * 
     */
    delete<T extends ScheduledRideDeleteArgs>(args: SelectSubset<T, ScheduledRideDeleteArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ScheduledRide.
     * @param {ScheduledRideUpdateArgs} args - Arguments to update one ScheduledRide.
     * @example
     * // Update one ScheduledRide
     * const scheduledRide = await prisma.scheduledRide.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledRideUpdateArgs>(args: SelectSubset<T, ScheduledRideUpdateArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ScheduledRides.
     * @param {ScheduledRideDeleteManyArgs} args - Arguments to filter ScheduledRides to delete.
     * @example
     * // Delete a few ScheduledRides
     * const { count } = await prisma.scheduledRide.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledRideDeleteManyArgs>(args?: SelectSubset<T, ScheduledRideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledRides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledRides
     * const scheduledRide = await prisma.scheduledRide.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledRideUpdateManyArgs>(args: SelectSubset<T, ScheduledRideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledRide.
     * @param {ScheduledRideUpsertArgs} args - Arguments to update or create a ScheduledRide.
     * @example
     * // Update or create a ScheduledRide
     * const scheduledRide = await prisma.scheduledRide.upsert({
     *   create: {
     *     // ... data to create a ScheduledRide
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledRide we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledRideUpsertArgs>(args: SelectSubset<T, ScheduledRideUpsertArgs<ExtArgs>>): Prisma__ScheduledRideClient<$Result.GetResult<Prisma.$ScheduledRidePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ScheduledRides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRideCountArgs} args - Arguments to filter ScheduledRides to count.
     * @example
     * // Count the number of ScheduledRides
     * const count = await prisma.scheduledRide.count({
     *   where: {
     *     // ... the filter for the ScheduledRides we want to count
     *   }
     * })
    **/
    count<T extends ScheduledRideCountArgs>(
      args?: Subset<T, ScheduledRideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledRideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledRide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledRideAggregateArgs>(args: Subset<T, ScheduledRideAggregateArgs>): Prisma.PrismaPromise<GetScheduledRideAggregateType<T>>

    /**
     * Group by ScheduledRide.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledRideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledRideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledRideGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledRideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledRideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledRideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledRide model
   */
  readonly fields: ScheduledRideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledRide.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledRideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdRides<T extends ScheduledRide$createdRidesArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledRide$createdRidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledRide model
   */ 
  interface ScheduledRideFieldRefs {
    readonly id: FieldRef<"ScheduledRide", 'String'>
    readonly origin: FieldRef<"ScheduledRide", 'String'>
    readonly destination: FieldRef<"ScheduledRide", 'String'>
    readonly fromCity: FieldRef<"ScheduledRide", 'String'>
    readonly toCity: FieldRef<"ScheduledRide", 'String'>
    readonly originLat: FieldRef<"ScheduledRide", 'Float'>
    readonly originLng: FieldRef<"ScheduledRide", 'Float'>
    readonly destinationLat: FieldRef<"ScheduledRide", 'Float'>
    readonly destinationLng: FieldRef<"ScheduledRide", 'Float'>
    readonly seats: FieldRef<"ScheduledRide", 'Int'>
    readonly price: FieldRef<"ScheduledRide", 'Float'>
    readonly scheduleTime: FieldRef<"ScheduledRide", 'String'>
    readonly daysOfWeek: FieldRef<"ScheduledRide", 'Int[]'>
    readonly isActive: FieldRef<"ScheduledRide", 'Boolean'>
    readonly driverId: FieldRef<"ScheduledRide", 'String'>
    readonly createdAt: FieldRef<"ScheduledRide", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledRide", 'DateTime'>
    readonly fromSuburb: FieldRef<"ScheduledRide", 'String'>
    readonly toSuburb: FieldRef<"ScheduledRide", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledRide findUnique
   */
  export type ScheduledRideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRide to fetch.
     */
    where: ScheduledRideWhereUniqueInput
  }

  /**
   * ScheduledRide findUniqueOrThrow
   */
  export type ScheduledRideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRide to fetch.
     */
    where: ScheduledRideWhereUniqueInput
  }

  /**
   * ScheduledRide findFirst
   */
  export type ScheduledRideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRide to fetch.
     */
    where?: ScheduledRideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRides to fetch.
     */
    orderBy?: ScheduledRideOrderByWithRelationInput | ScheduledRideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledRides.
     */
    cursor?: ScheduledRideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledRides.
     */
    distinct?: ScheduledRideScalarFieldEnum | ScheduledRideScalarFieldEnum[]
  }

  /**
   * ScheduledRide findFirstOrThrow
   */
  export type ScheduledRideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRide to fetch.
     */
    where?: ScheduledRideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRides to fetch.
     */
    orderBy?: ScheduledRideOrderByWithRelationInput | ScheduledRideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledRides.
     */
    cursor?: ScheduledRideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledRides.
     */
    distinct?: ScheduledRideScalarFieldEnum | ScheduledRideScalarFieldEnum[]
  }

  /**
   * ScheduledRide findMany
   */
  export type ScheduledRideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledRides to fetch.
     */
    where?: ScheduledRideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledRides to fetch.
     */
    orderBy?: ScheduledRideOrderByWithRelationInput | ScheduledRideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledRides.
     */
    cursor?: ScheduledRideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledRides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledRides.
     */
    skip?: number
    distinct?: ScheduledRideScalarFieldEnum | ScheduledRideScalarFieldEnum[]
  }

  /**
   * ScheduledRide create
   */
  export type ScheduledRideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledRide.
     */
    data: XOR<ScheduledRideCreateInput, ScheduledRideUncheckedCreateInput>
  }

  /**
   * ScheduledRide createMany
   */
  export type ScheduledRideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledRides.
     */
    data: ScheduledRideCreateManyInput | ScheduledRideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledRide createManyAndReturn
   */
  export type ScheduledRideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ScheduledRides.
     */
    data: ScheduledRideCreateManyInput | ScheduledRideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduledRide update
   */
  export type ScheduledRideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledRide.
     */
    data: XOR<ScheduledRideUpdateInput, ScheduledRideUncheckedUpdateInput>
    /**
     * Choose, which ScheduledRide to update.
     */
    where: ScheduledRideWhereUniqueInput
  }

  /**
   * ScheduledRide updateMany
   */
  export type ScheduledRideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledRides.
     */
    data: XOR<ScheduledRideUpdateManyMutationInput, ScheduledRideUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledRides to update
     */
    where?: ScheduledRideWhereInput
  }

  /**
   * ScheduledRide upsert
   */
  export type ScheduledRideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledRide to update in case it exists.
     */
    where: ScheduledRideWhereUniqueInput
    /**
     * In case the ScheduledRide found by the `where` argument doesn't exist, create a new ScheduledRide with this data.
     */
    create: XOR<ScheduledRideCreateInput, ScheduledRideUncheckedCreateInput>
    /**
     * In case the ScheduledRide was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledRideUpdateInput, ScheduledRideUncheckedUpdateInput>
  }

  /**
   * ScheduledRide delete
   */
  export type ScheduledRideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
    /**
     * Filter which ScheduledRide to delete.
     */
    where: ScheduledRideWhereUniqueInput
  }

  /**
   * ScheduledRide deleteMany
   */
  export type ScheduledRideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledRides to delete
     */
    where?: ScheduledRideWhereInput
  }

  /**
   * ScheduledRide.createdRides
   */
  export type ScheduledRide$createdRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    cursor?: RideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * ScheduledRide without action
   */
  export type ScheduledRideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledRide
     */
    select?: ScheduledRideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledRideInclude<ExtArgs> | null
  }


  /**
   * Model RideComment
   */

  export type AggregateRideComment = {
    _count: RideCommentCountAggregateOutputType | null
    _min: RideCommentMinAggregateOutputType | null
    _max: RideCommentMaxAggregateOutputType | null
  }

  export type RideCommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    rideId: string | null
    userId: string | null
    parentId: string | null
  }

  export type RideCommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    rideId: string | null
    userId: string | null
    parentId: string | null
  }

  export type RideCommentCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    rideId: number
    userId: number
    parentId: number
    _all: number
  }


  export type RideCommentMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    rideId?: true
    userId?: true
    parentId?: true
  }

  export type RideCommentMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    rideId?: true
    userId?: true
    parentId?: true
  }

  export type RideCommentCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    rideId?: true
    userId?: true
    parentId?: true
    _all?: true
  }

  export type RideCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RideComment to aggregate.
     */
    where?: RideCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideComments to fetch.
     */
    orderBy?: RideCommentOrderByWithRelationInput | RideCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RideCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RideComments
    **/
    _count?: true | RideCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RideCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RideCommentMaxAggregateInputType
  }

  export type GetRideCommentAggregateType<T extends RideCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateRideComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRideComment[P]>
      : GetScalarType<T[P], AggregateRideComment[P]>
  }




  export type RideCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideCommentWhereInput
    orderBy?: RideCommentOrderByWithAggregationInput | RideCommentOrderByWithAggregationInput[]
    by: RideCommentScalarFieldEnum[] | RideCommentScalarFieldEnum
    having?: RideCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RideCommentCountAggregateInputType | true
    _min?: RideCommentMinAggregateInputType
    _max?: RideCommentMaxAggregateInputType
  }

  export type RideCommentGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    rideId: string
    userId: string
    parentId: string | null
    _count: RideCommentCountAggregateOutputType | null
    _min: RideCommentMinAggregateOutputType | null
    _max: RideCommentMaxAggregateOutputType | null
  }

  type GetRideCommentGroupByPayload<T extends RideCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RideCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RideCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RideCommentGroupByOutputType[P]>
            : GetScalarType<T[P], RideCommentGroupByOutputType[P]>
        }
      >
    >


  export type RideCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    rideId?: boolean
    userId?: boolean
    parentId?: boolean
    parent?: boolean | RideComment$parentArgs<ExtArgs>
    replies?: boolean | RideComment$repliesArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | RideCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rideComment"]>

  export type RideCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    rideId?: boolean
    userId?: boolean
    parentId?: boolean
    parent?: boolean | RideComment$parentArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rideComment"]>

  export type RideCommentSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    rideId?: boolean
    userId?: boolean
    parentId?: boolean
  }

  export type RideCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RideComment$parentArgs<ExtArgs>
    replies?: boolean | RideComment$repliesArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | RideCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RideCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RideComment$parentArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RideCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RideComment"
    objects: {
      parent: Prisma.$RideCommentPayload<ExtArgs> | null
      replies: Prisma.$RideCommentPayload<ExtArgs>[]
      ride: Prisma.$RidePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      rideId: string
      userId: string
      parentId: string | null
    }, ExtArgs["result"]["rideComment"]>
    composites: {}
  }

  type RideCommentGetPayload<S extends boolean | null | undefined | RideCommentDefaultArgs> = $Result.GetResult<Prisma.$RideCommentPayload, S>

  type RideCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RideCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RideCommentCountAggregateInputType | true
    }

  export interface RideCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RideComment'], meta: { name: 'RideComment' } }
    /**
     * Find zero or one RideComment that matches the filter.
     * @param {RideCommentFindUniqueArgs} args - Arguments to find a RideComment
     * @example
     * // Get one RideComment
     * const rideComment = await prisma.rideComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RideCommentFindUniqueArgs>(args: SelectSubset<T, RideCommentFindUniqueArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RideComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RideCommentFindUniqueOrThrowArgs} args - Arguments to find a RideComment
     * @example
     * // Get one RideComment
     * const rideComment = await prisma.rideComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RideCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, RideCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RideComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCommentFindFirstArgs} args - Arguments to find a RideComment
     * @example
     * // Get one RideComment
     * const rideComment = await prisma.rideComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RideCommentFindFirstArgs>(args?: SelectSubset<T, RideCommentFindFirstArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RideComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCommentFindFirstOrThrowArgs} args - Arguments to find a RideComment
     * @example
     * // Get one RideComment
     * const rideComment = await prisma.rideComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RideCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, RideCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RideComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RideComments
     * const rideComments = await prisma.rideComment.findMany()
     * 
     * // Get first 10 RideComments
     * const rideComments = await prisma.rideComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rideCommentWithIdOnly = await prisma.rideComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RideCommentFindManyArgs>(args?: SelectSubset<T, RideCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RideComment.
     * @param {RideCommentCreateArgs} args - Arguments to create a RideComment.
     * @example
     * // Create one RideComment
     * const RideComment = await prisma.rideComment.create({
     *   data: {
     *     // ... data to create a RideComment
     *   }
     * })
     * 
     */
    create<T extends RideCommentCreateArgs>(args: SelectSubset<T, RideCommentCreateArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RideComments.
     * @param {RideCommentCreateManyArgs} args - Arguments to create many RideComments.
     * @example
     * // Create many RideComments
     * const rideComment = await prisma.rideComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RideCommentCreateManyArgs>(args?: SelectSubset<T, RideCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RideComments and returns the data saved in the database.
     * @param {RideCommentCreateManyAndReturnArgs} args - Arguments to create many RideComments.
     * @example
     * // Create many RideComments
     * const rideComment = await prisma.rideComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RideComments and only return the `id`
     * const rideCommentWithIdOnly = await prisma.rideComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RideCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, RideCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RideComment.
     * @param {RideCommentDeleteArgs} args - Arguments to delete one RideComment.
     * @example
     * // Delete one RideComment
     * const RideComment = await prisma.rideComment.delete({
     *   where: {
     *     // ... filter to delete one RideComment
     *   }
     * })
     * 
     */
    delete<T extends RideCommentDeleteArgs>(args: SelectSubset<T, RideCommentDeleteArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RideComment.
     * @param {RideCommentUpdateArgs} args - Arguments to update one RideComment.
     * @example
     * // Update one RideComment
     * const rideComment = await prisma.rideComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RideCommentUpdateArgs>(args: SelectSubset<T, RideCommentUpdateArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RideComments.
     * @param {RideCommentDeleteManyArgs} args - Arguments to filter RideComments to delete.
     * @example
     * // Delete a few RideComments
     * const { count } = await prisma.rideComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RideCommentDeleteManyArgs>(args?: SelectSubset<T, RideCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RideComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RideComments
     * const rideComment = await prisma.rideComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RideCommentUpdateManyArgs>(args: SelectSubset<T, RideCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RideComment.
     * @param {RideCommentUpsertArgs} args - Arguments to update or create a RideComment.
     * @example
     * // Update or create a RideComment
     * const rideComment = await prisma.rideComment.upsert({
     *   create: {
     *     // ... data to create a RideComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RideComment we want to update
     *   }
     * })
     */
    upsert<T extends RideCommentUpsertArgs>(args: SelectSubset<T, RideCommentUpsertArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RideComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCommentCountArgs} args - Arguments to filter RideComments to count.
     * @example
     * // Count the number of RideComments
     * const count = await prisma.rideComment.count({
     *   where: {
     *     // ... the filter for the RideComments we want to count
     *   }
     * })
    **/
    count<T extends RideCommentCountArgs>(
      args?: Subset<T, RideCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RideCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RideComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RideCommentAggregateArgs>(args: Subset<T, RideCommentAggregateArgs>): Prisma.PrismaPromise<GetRideCommentAggregateType<T>>

    /**
     * Group by RideComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RideCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RideCommentGroupByArgs['orderBy'] }
        : { orderBy?: RideCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RideCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRideCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RideComment model
   */
  readonly fields: RideCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RideComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RideCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends RideComment$parentArgs<ExtArgs> = {}>(args?: Subset<T, RideComment$parentArgs<ExtArgs>>): Prisma__RideCommentClient<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends RideComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, RideComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideCommentPayload<ExtArgs>, T, "findMany"> | Null>
    ride<T extends RideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RideDefaultArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RideComment model
   */ 
  interface RideCommentFieldRefs {
    readonly id: FieldRef<"RideComment", 'String'>
    readonly content: FieldRef<"RideComment", 'String'>
    readonly createdAt: FieldRef<"RideComment", 'DateTime'>
    readonly rideId: FieldRef<"RideComment", 'String'>
    readonly userId: FieldRef<"RideComment", 'String'>
    readonly parentId: FieldRef<"RideComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RideComment findUnique
   */
  export type RideCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * Filter, which RideComment to fetch.
     */
    where: RideCommentWhereUniqueInput
  }

  /**
   * RideComment findUniqueOrThrow
   */
  export type RideCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * Filter, which RideComment to fetch.
     */
    where: RideCommentWhereUniqueInput
  }

  /**
   * RideComment findFirst
   */
  export type RideCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * Filter, which RideComment to fetch.
     */
    where?: RideCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideComments to fetch.
     */
    orderBy?: RideCommentOrderByWithRelationInput | RideCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RideComments.
     */
    cursor?: RideCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RideComments.
     */
    distinct?: RideCommentScalarFieldEnum | RideCommentScalarFieldEnum[]
  }

  /**
   * RideComment findFirstOrThrow
   */
  export type RideCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * Filter, which RideComment to fetch.
     */
    where?: RideCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideComments to fetch.
     */
    orderBy?: RideCommentOrderByWithRelationInput | RideCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RideComments.
     */
    cursor?: RideCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RideComments.
     */
    distinct?: RideCommentScalarFieldEnum | RideCommentScalarFieldEnum[]
  }

  /**
   * RideComment findMany
   */
  export type RideCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * Filter, which RideComments to fetch.
     */
    where?: RideCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideComments to fetch.
     */
    orderBy?: RideCommentOrderByWithRelationInput | RideCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RideComments.
     */
    cursor?: RideCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideComments.
     */
    skip?: number
    distinct?: RideCommentScalarFieldEnum | RideCommentScalarFieldEnum[]
  }

  /**
   * RideComment create
   */
  export type RideCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a RideComment.
     */
    data: XOR<RideCommentCreateInput, RideCommentUncheckedCreateInput>
  }

  /**
   * RideComment createMany
   */
  export type RideCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RideComments.
     */
    data: RideCommentCreateManyInput | RideCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RideComment createManyAndReturn
   */
  export type RideCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RideComments.
     */
    data: RideCommentCreateManyInput | RideCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RideComment update
   */
  export type RideCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a RideComment.
     */
    data: XOR<RideCommentUpdateInput, RideCommentUncheckedUpdateInput>
    /**
     * Choose, which RideComment to update.
     */
    where: RideCommentWhereUniqueInput
  }

  /**
   * RideComment updateMany
   */
  export type RideCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RideComments.
     */
    data: XOR<RideCommentUpdateManyMutationInput, RideCommentUncheckedUpdateManyInput>
    /**
     * Filter which RideComments to update
     */
    where?: RideCommentWhereInput
  }

  /**
   * RideComment upsert
   */
  export type RideCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the RideComment to update in case it exists.
     */
    where: RideCommentWhereUniqueInput
    /**
     * In case the RideComment found by the `where` argument doesn't exist, create a new RideComment with this data.
     */
    create: XOR<RideCommentCreateInput, RideCommentUncheckedCreateInput>
    /**
     * In case the RideComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RideCommentUpdateInput, RideCommentUncheckedUpdateInput>
  }

  /**
   * RideComment delete
   */
  export type RideCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    /**
     * Filter which RideComment to delete.
     */
    where: RideCommentWhereUniqueInput
  }

  /**
   * RideComment deleteMany
   */
  export type RideCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RideComments to delete
     */
    where?: RideCommentWhereInput
  }

  /**
   * RideComment.parent
   */
  export type RideComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    where?: RideCommentWhereInput
  }

  /**
   * RideComment.replies
   */
  export type RideComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
    where?: RideCommentWhereInput
    orderBy?: RideCommentOrderByWithRelationInput | RideCommentOrderByWithRelationInput[]
    cursor?: RideCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideCommentScalarFieldEnum | RideCommentScalarFieldEnum[]
  }

  /**
   * RideComment without action
   */
  export type RideCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideComment
     */
    select?: RideCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideCommentInclude<ExtArgs> | null
  }


  /**
   * Model GroupBookingInvitation
   */

  export type AggregateGroupBookingInvitation = {
    _count: GroupBookingInvitationCountAggregateOutputType | null
    _avg: GroupBookingInvitationAvgAggregateOutputType | null
    _sum: GroupBookingInvitationSumAggregateOutputType | null
    _min: GroupBookingInvitationMinAggregateOutputType | null
    _max: GroupBookingInvitationMaxAggregateOutputType | null
  }

  export type GroupBookingInvitationAvgAggregateOutputType = {
    seats: number | null
  }

  export type GroupBookingInvitationSumAggregateOutputType = {
    seats: number | null
  }

  export type GroupBookingInvitationMinAggregateOutputType = {
    id: string | null
    rideId: string | null
    initiatorId: string | null
    seats: number | null
    expiresAt: Date | null
    status: string | null
  }

  export type GroupBookingInvitationMaxAggregateOutputType = {
    id: string | null
    rideId: string | null
    initiatorId: string | null
    seats: number | null
    expiresAt: Date | null
    status: string | null
  }

  export type GroupBookingInvitationCountAggregateOutputType = {
    id: number
    rideId: number
    initiatorId: number
    seats: number
    expiresAt: number
    status: number
    _all: number
  }


  export type GroupBookingInvitationAvgAggregateInputType = {
    seats?: true
  }

  export type GroupBookingInvitationSumAggregateInputType = {
    seats?: true
  }

  export type GroupBookingInvitationMinAggregateInputType = {
    id?: true
    rideId?: true
    initiatorId?: true
    seats?: true
    expiresAt?: true
    status?: true
  }

  export type GroupBookingInvitationMaxAggregateInputType = {
    id?: true
    rideId?: true
    initiatorId?: true
    seats?: true
    expiresAt?: true
    status?: true
  }

  export type GroupBookingInvitationCountAggregateInputType = {
    id?: true
    rideId?: true
    initiatorId?: true
    seats?: true
    expiresAt?: true
    status?: true
    _all?: true
  }

  export type GroupBookingInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupBookingInvitation to aggregate.
     */
    where?: GroupBookingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookingInvitations to fetch.
     */
    orderBy?: GroupBookingInvitationOrderByWithRelationInput | GroupBookingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupBookingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookingInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupBookingInvitations
    **/
    _count?: true | GroupBookingInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupBookingInvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupBookingInvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupBookingInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupBookingInvitationMaxAggregateInputType
  }

  export type GetGroupBookingInvitationAggregateType<T extends GroupBookingInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupBookingInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupBookingInvitation[P]>
      : GetScalarType<T[P], AggregateGroupBookingInvitation[P]>
  }




  export type GroupBookingInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupBookingInvitationWhereInput
    orderBy?: GroupBookingInvitationOrderByWithAggregationInput | GroupBookingInvitationOrderByWithAggregationInput[]
    by: GroupBookingInvitationScalarFieldEnum[] | GroupBookingInvitationScalarFieldEnum
    having?: GroupBookingInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupBookingInvitationCountAggregateInputType | true
    _avg?: GroupBookingInvitationAvgAggregateInputType
    _sum?: GroupBookingInvitationSumAggregateInputType
    _min?: GroupBookingInvitationMinAggregateInputType
    _max?: GroupBookingInvitationMaxAggregateInputType
  }

  export type GroupBookingInvitationGroupByOutputType = {
    id: string
    rideId: string
    initiatorId: string
    seats: number
    expiresAt: Date
    status: string
    _count: GroupBookingInvitationCountAggregateOutputType | null
    _avg: GroupBookingInvitationAvgAggregateOutputType | null
    _sum: GroupBookingInvitationSumAggregateOutputType | null
    _min: GroupBookingInvitationMinAggregateOutputType | null
    _max: GroupBookingInvitationMaxAggregateOutputType | null
  }

  type GetGroupBookingInvitationGroupByPayload<T extends GroupBookingInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupBookingInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupBookingInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupBookingInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], GroupBookingInvitationGroupByOutputType[P]>
        }
      >
    >


  export type GroupBookingInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    initiatorId?: boolean
    seats?: boolean
    expiresAt?: boolean
    status?: boolean
    bookings?: boolean | GroupBookingInvitation$bookingsArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | GroupBookingInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupBookingInvitation"]>

  export type GroupBookingInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rideId?: boolean
    initiatorId?: boolean
    seats?: boolean
    expiresAt?: boolean
    status?: boolean
    ride?: boolean | RideDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupBookingInvitation"]>

  export type GroupBookingInvitationSelectScalar = {
    id?: boolean
    rideId?: boolean
    initiatorId?: boolean
    seats?: boolean
    expiresAt?: boolean
    status?: boolean
  }

  export type GroupBookingInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | GroupBookingInvitation$bookingsArgs<ExtArgs>
    ride?: boolean | RideDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | GroupBookingInvitationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupBookingInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | RideDefaultArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupBookingInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupBookingInvitation"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      ride: Prisma.$RidePayload<ExtArgs>
      initiator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rideId: string
      initiatorId: string
      seats: number
      expiresAt: Date
      status: string
    }, ExtArgs["result"]["groupBookingInvitation"]>
    composites: {}
  }

  type GroupBookingInvitationGetPayload<S extends boolean | null | undefined | GroupBookingInvitationDefaultArgs> = $Result.GetResult<Prisma.$GroupBookingInvitationPayload, S>

  type GroupBookingInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupBookingInvitationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupBookingInvitationCountAggregateInputType | true
    }

  export interface GroupBookingInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupBookingInvitation'], meta: { name: 'GroupBookingInvitation' } }
    /**
     * Find zero or one GroupBookingInvitation that matches the filter.
     * @param {GroupBookingInvitationFindUniqueArgs} args - Arguments to find a GroupBookingInvitation
     * @example
     * // Get one GroupBookingInvitation
     * const groupBookingInvitation = await prisma.groupBookingInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupBookingInvitationFindUniqueArgs>(args: SelectSubset<T, GroupBookingInvitationFindUniqueArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupBookingInvitation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupBookingInvitationFindUniqueOrThrowArgs} args - Arguments to find a GroupBookingInvitation
     * @example
     * // Get one GroupBookingInvitation
     * const groupBookingInvitation = await prisma.groupBookingInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupBookingInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupBookingInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupBookingInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookingInvitationFindFirstArgs} args - Arguments to find a GroupBookingInvitation
     * @example
     * // Get one GroupBookingInvitation
     * const groupBookingInvitation = await prisma.groupBookingInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupBookingInvitationFindFirstArgs>(args?: SelectSubset<T, GroupBookingInvitationFindFirstArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupBookingInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookingInvitationFindFirstOrThrowArgs} args - Arguments to find a GroupBookingInvitation
     * @example
     * // Get one GroupBookingInvitation
     * const groupBookingInvitation = await prisma.groupBookingInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupBookingInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupBookingInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupBookingInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookingInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupBookingInvitations
     * const groupBookingInvitations = await prisma.groupBookingInvitation.findMany()
     * 
     * // Get first 10 GroupBookingInvitations
     * const groupBookingInvitations = await prisma.groupBookingInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupBookingInvitationWithIdOnly = await prisma.groupBookingInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupBookingInvitationFindManyArgs>(args?: SelectSubset<T, GroupBookingInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupBookingInvitation.
     * @param {GroupBookingInvitationCreateArgs} args - Arguments to create a GroupBookingInvitation.
     * @example
     * // Create one GroupBookingInvitation
     * const GroupBookingInvitation = await prisma.groupBookingInvitation.create({
     *   data: {
     *     // ... data to create a GroupBookingInvitation
     *   }
     * })
     * 
     */
    create<T extends GroupBookingInvitationCreateArgs>(args: SelectSubset<T, GroupBookingInvitationCreateArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupBookingInvitations.
     * @param {GroupBookingInvitationCreateManyArgs} args - Arguments to create many GroupBookingInvitations.
     * @example
     * // Create many GroupBookingInvitations
     * const groupBookingInvitation = await prisma.groupBookingInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupBookingInvitationCreateManyArgs>(args?: SelectSubset<T, GroupBookingInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupBookingInvitations and returns the data saved in the database.
     * @param {GroupBookingInvitationCreateManyAndReturnArgs} args - Arguments to create many GroupBookingInvitations.
     * @example
     * // Create many GroupBookingInvitations
     * const groupBookingInvitation = await prisma.groupBookingInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupBookingInvitations and only return the `id`
     * const groupBookingInvitationWithIdOnly = await prisma.groupBookingInvitation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupBookingInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupBookingInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GroupBookingInvitation.
     * @param {GroupBookingInvitationDeleteArgs} args - Arguments to delete one GroupBookingInvitation.
     * @example
     * // Delete one GroupBookingInvitation
     * const GroupBookingInvitation = await prisma.groupBookingInvitation.delete({
     *   where: {
     *     // ... filter to delete one GroupBookingInvitation
     *   }
     * })
     * 
     */
    delete<T extends GroupBookingInvitationDeleteArgs>(args: SelectSubset<T, GroupBookingInvitationDeleteArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupBookingInvitation.
     * @param {GroupBookingInvitationUpdateArgs} args - Arguments to update one GroupBookingInvitation.
     * @example
     * // Update one GroupBookingInvitation
     * const groupBookingInvitation = await prisma.groupBookingInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupBookingInvitationUpdateArgs>(args: SelectSubset<T, GroupBookingInvitationUpdateArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupBookingInvitations.
     * @param {GroupBookingInvitationDeleteManyArgs} args - Arguments to filter GroupBookingInvitations to delete.
     * @example
     * // Delete a few GroupBookingInvitations
     * const { count } = await prisma.groupBookingInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupBookingInvitationDeleteManyArgs>(args?: SelectSubset<T, GroupBookingInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupBookingInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookingInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupBookingInvitations
     * const groupBookingInvitation = await prisma.groupBookingInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupBookingInvitationUpdateManyArgs>(args: SelectSubset<T, GroupBookingInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupBookingInvitation.
     * @param {GroupBookingInvitationUpsertArgs} args - Arguments to update or create a GroupBookingInvitation.
     * @example
     * // Update or create a GroupBookingInvitation
     * const groupBookingInvitation = await prisma.groupBookingInvitation.upsert({
     *   create: {
     *     // ... data to create a GroupBookingInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupBookingInvitation we want to update
     *   }
     * })
     */
    upsert<T extends GroupBookingInvitationUpsertArgs>(args: SelectSubset<T, GroupBookingInvitationUpsertArgs<ExtArgs>>): Prisma__GroupBookingInvitationClient<$Result.GetResult<Prisma.$GroupBookingInvitationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupBookingInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookingInvitationCountArgs} args - Arguments to filter GroupBookingInvitations to count.
     * @example
     * // Count the number of GroupBookingInvitations
     * const count = await prisma.groupBookingInvitation.count({
     *   where: {
     *     // ... the filter for the GroupBookingInvitations we want to count
     *   }
     * })
    **/
    count<T extends GroupBookingInvitationCountArgs>(
      args?: Subset<T, GroupBookingInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupBookingInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupBookingInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookingInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupBookingInvitationAggregateArgs>(args: Subset<T, GroupBookingInvitationAggregateArgs>): Prisma.PrismaPromise<GetGroupBookingInvitationAggregateType<T>>

    /**
     * Group by GroupBookingInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupBookingInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupBookingInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupBookingInvitationGroupByArgs['orderBy'] }
        : { orderBy?: GroupBookingInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupBookingInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupBookingInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupBookingInvitation model
   */
  readonly fields: GroupBookingInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupBookingInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupBookingInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends GroupBookingInvitation$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, GroupBookingInvitation$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    ride<T extends RideDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RideDefaultArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    initiator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupBookingInvitation model
   */ 
  interface GroupBookingInvitationFieldRefs {
    readonly id: FieldRef<"GroupBookingInvitation", 'String'>
    readonly rideId: FieldRef<"GroupBookingInvitation", 'String'>
    readonly initiatorId: FieldRef<"GroupBookingInvitation", 'String'>
    readonly seats: FieldRef<"GroupBookingInvitation", 'Int'>
    readonly expiresAt: FieldRef<"GroupBookingInvitation", 'DateTime'>
    readonly status: FieldRef<"GroupBookingInvitation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GroupBookingInvitation findUnique
   */
  export type GroupBookingInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookingInvitation to fetch.
     */
    where: GroupBookingInvitationWhereUniqueInput
  }

  /**
   * GroupBookingInvitation findUniqueOrThrow
   */
  export type GroupBookingInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookingInvitation to fetch.
     */
    where: GroupBookingInvitationWhereUniqueInput
  }

  /**
   * GroupBookingInvitation findFirst
   */
  export type GroupBookingInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookingInvitation to fetch.
     */
    where?: GroupBookingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookingInvitations to fetch.
     */
    orderBy?: GroupBookingInvitationOrderByWithRelationInput | GroupBookingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupBookingInvitations.
     */
    cursor?: GroupBookingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookingInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupBookingInvitations.
     */
    distinct?: GroupBookingInvitationScalarFieldEnum | GroupBookingInvitationScalarFieldEnum[]
  }

  /**
   * GroupBookingInvitation findFirstOrThrow
   */
  export type GroupBookingInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookingInvitation to fetch.
     */
    where?: GroupBookingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookingInvitations to fetch.
     */
    orderBy?: GroupBookingInvitationOrderByWithRelationInput | GroupBookingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupBookingInvitations.
     */
    cursor?: GroupBookingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookingInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupBookingInvitations.
     */
    distinct?: GroupBookingInvitationScalarFieldEnum | GroupBookingInvitationScalarFieldEnum[]
  }

  /**
   * GroupBookingInvitation findMany
   */
  export type GroupBookingInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * Filter, which GroupBookingInvitations to fetch.
     */
    where?: GroupBookingInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupBookingInvitations to fetch.
     */
    orderBy?: GroupBookingInvitationOrderByWithRelationInput | GroupBookingInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupBookingInvitations.
     */
    cursor?: GroupBookingInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupBookingInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupBookingInvitations.
     */
    skip?: number
    distinct?: GroupBookingInvitationScalarFieldEnum | GroupBookingInvitationScalarFieldEnum[]
  }

  /**
   * GroupBookingInvitation create
   */
  export type GroupBookingInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupBookingInvitation.
     */
    data: XOR<GroupBookingInvitationCreateInput, GroupBookingInvitationUncheckedCreateInput>
  }

  /**
   * GroupBookingInvitation createMany
   */
  export type GroupBookingInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupBookingInvitations.
     */
    data: GroupBookingInvitationCreateManyInput | GroupBookingInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupBookingInvitation createManyAndReturn
   */
  export type GroupBookingInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GroupBookingInvitations.
     */
    data: GroupBookingInvitationCreateManyInput | GroupBookingInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupBookingInvitation update
   */
  export type GroupBookingInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupBookingInvitation.
     */
    data: XOR<GroupBookingInvitationUpdateInput, GroupBookingInvitationUncheckedUpdateInput>
    /**
     * Choose, which GroupBookingInvitation to update.
     */
    where: GroupBookingInvitationWhereUniqueInput
  }

  /**
   * GroupBookingInvitation updateMany
   */
  export type GroupBookingInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupBookingInvitations.
     */
    data: XOR<GroupBookingInvitationUpdateManyMutationInput, GroupBookingInvitationUncheckedUpdateManyInput>
    /**
     * Filter which GroupBookingInvitations to update
     */
    where?: GroupBookingInvitationWhereInput
  }

  /**
   * GroupBookingInvitation upsert
   */
  export type GroupBookingInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupBookingInvitation to update in case it exists.
     */
    where: GroupBookingInvitationWhereUniqueInput
    /**
     * In case the GroupBookingInvitation found by the `where` argument doesn't exist, create a new GroupBookingInvitation with this data.
     */
    create: XOR<GroupBookingInvitationCreateInput, GroupBookingInvitationUncheckedCreateInput>
    /**
     * In case the GroupBookingInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupBookingInvitationUpdateInput, GroupBookingInvitationUncheckedUpdateInput>
  }

  /**
   * GroupBookingInvitation delete
   */
  export type GroupBookingInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
    /**
     * Filter which GroupBookingInvitation to delete.
     */
    where: GroupBookingInvitationWhereUniqueInput
  }

  /**
   * GroupBookingInvitation deleteMany
   */
  export type GroupBookingInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupBookingInvitations to delete
     */
    where?: GroupBookingInvitationWhereInput
  }

  /**
   * GroupBookingInvitation.bookings
   */
  export type GroupBookingInvitation$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * GroupBookingInvitation without action
   */
  export type GroupBookingInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupBookingInvitation
     */
    select?: GroupBookingInvitationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupBookingInvitationInclude<ExtArgs> | null
  }


  /**
   * Model spatial_ref_sys
   */

  export type AggregateSpatial_ref_sys = {
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  export type Spatial_ref_sysAvgAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysSumAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysMinAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysMaxAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysCountAggregateOutputType = {
    srid: number
    auth_name: number
    auth_srid: number
    srtext: number
    proj4text: number
    _all: number
  }


  export type Spatial_ref_sysAvgAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysSumAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysMinAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysMaxAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysCountAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
    _all?: true
  }

  export type Spatial_ref_sysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to aggregate.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned spatial_ref_sys
    **/
    _count?: true | Spatial_ref_sysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Spatial_ref_sysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Spatial_ref_sysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Spatial_ref_sysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type GetSpatial_ref_sysAggregateType<T extends Spatial_ref_sysAggregateArgs> = {
        [P in keyof T & keyof AggregateSpatial_ref_sys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
      : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
  }




  export type spatial_ref_sysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: spatial_ref_sysWhereInput
    orderBy?: spatial_ref_sysOrderByWithAggregationInput | spatial_ref_sysOrderByWithAggregationInput[]
    by: Spatial_ref_sysScalarFieldEnum[] | Spatial_ref_sysScalarFieldEnum
    having?: spatial_ref_sysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Spatial_ref_sysCountAggregateInputType | true
    _avg?: Spatial_ref_sysAvgAggregateInputType
    _sum?: Spatial_ref_sysSumAggregateInputType
    _min?: Spatial_ref_sysMinAggregateInputType
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type Spatial_ref_sysGroupByOutputType = {
    srid: number
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  type GetSpatial_ref_sysGroupByPayload<T extends spatial_ref_sysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Spatial_ref_sysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Spatial_ref_sysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
            : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
        }
      >
    >


  export type spatial_ref_sysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectScalar = {
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }


  export type $spatial_ref_sysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "spatial_ref_sys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      srid: number
      auth_name: string | null
      auth_srid: number | null
      srtext: string | null
      proj4text: string | null
    }, ExtArgs["result"]["spatial_ref_sys"]>
    composites: {}
  }

  type spatial_ref_sysGetPayload<S extends boolean | null | undefined | spatial_ref_sysDefaultArgs> = $Result.GetResult<Prisma.$spatial_ref_sysPayload, S>

  type spatial_ref_sysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<spatial_ref_sysFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Spatial_ref_sysCountAggregateInputType | true
    }

  export interface spatial_ref_sysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['spatial_ref_sys'], meta: { name: 'spatial_ref_sys' } }
    /**
     * Find zero or one Spatial_ref_sys that matches the filter.
     * @param {spatial_ref_sysFindUniqueArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends spatial_ref_sysFindUniqueArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Spatial_ref_sys that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {spatial_ref_sysFindUniqueOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends spatial_ref_sysFindUniqueOrThrowArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends spatial_ref_sysFindFirstArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Spatial_ref_sys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends spatial_ref_sysFindFirstOrThrowArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
     * 
     * // Get first 10 Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany({ take: 10 })
     * 
     * // Only select the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.findMany({ select: { srid: true } })
     * 
     */
    findMany<T extends spatial_ref_sysFindManyArgs>(args?: SelectSubset<T, spatial_ref_sysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Spatial_ref_sys.
     * @param {spatial_ref_sysCreateArgs} args - Arguments to create a Spatial_ref_sys.
     * @example
     * // Create one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.create({
     *   data: {
     *     // ... data to create a Spatial_ref_sys
     *   }
     * })
     * 
     */
    create<T extends spatial_ref_sysCreateArgs>(args: SelectSubset<T, spatial_ref_sysCreateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Spatial_ref_sys.
     * @param {spatial_ref_sysCreateManyArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends spatial_ref_sysCreateManyArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spatial_ref_sys and returns the data saved in the database.
     * @param {spatial_ref_sysCreateManyAndReturnArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spatial_ref_sys and only return the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.createManyAndReturn({ 
     *   select: { srid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends spatial_ref_sysCreateManyAndReturnArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteArgs} args - Arguments to delete one Spatial_ref_sys.
     * @example
     * // Delete one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.delete({
     *   where: {
     *     // ... filter to delete one Spatial_ref_sys
     *   }
     * })
     * 
     */
    delete<T extends spatial_ref_sysDeleteArgs>(args: SelectSubset<T, spatial_ref_sysDeleteArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpdateArgs} args - Arguments to update one Spatial_ref_sys.
     * @example
     * // Update one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends spatial_ref_sysUpdateArgs>(args: SelectSubset<T, spatial_ref_sysUpdateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteManyArgs} args - Arguments to filter Spatial_ref_sys to delete.
     * @example
     * // Delete a few Spatial_ref_sys
     * const { count } = await prisma.spatial_ref_sys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends spatial_ref_sysDeleteManyArgs>(args?: SelectSubset<T, spatial_ref_sysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends spatial_ref_sysUpdateManyArgs>(args: SelectSubset<T, spatial_ref_sysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpsertArgs} args - Arguments to update or create a Spatial_ref_sys.
     * @example
     * // Update or create a Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.upsert({
     *   create: {
     *     // ... data to create a Spatial_ref_sys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to update
     *   }
     * })
     */
    upsert<T extends spatial_ref_sysUpsertArgs>(args: SelectSubset<T, spatial_ref_sysUpsertArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysCountArgs} args - Arguments to filter Spatial_ref_sys to count.
     * @example
     * // Count the number of Spatial_ref_sys
     * const count = await prisma.spatial_ref_sys.count({
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to count
     *   }
     * })
    **/
    count<T extends spatial_ref_sysCountArgs>(
      args?: Subset<T, spatial_ref_sysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Spatial_ref_sysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Spatial_ref_sysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Spatial_ref_sysAggregateArgs>(args: Subset<T, Spatial_ref_sysAggregateArgs>): Prisma.PrismaPromise<GetSpatial_ref_sysAggregateType<T>>

    /**
     * Group by Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends spatial_ref_sysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: spatial_ref_sysGroupByArgs['orderBy'] }
        : { orderBy?: spatial_ref_sysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, spatial_ref_sysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpatial_ref_sysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the spatial_ref_sys model
   */
  readonly fields: spatial_ref_sysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for spatial_ref_sys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__spatial_ref_sysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the spatial_ref_sys model
   */ 
  interface spatial_ref_sysFieldRefs {
    readonly srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly auth_name: FieldRef<"spatial_ref_sys", 'String'>
    readonly auth_srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly srtext: FieldRef<"spatial_ref_sys", 'String'>
    readonly proj4text: FieldRef<"spatial_ref_sys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * spatial_ref_sys findUnique
   */
  export type spatial_ref_sysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findUniqueOrThrow
   */
  export type spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findFirst
   */
  export type spatial_ref_sysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findFirstOrThrow
   */
  export type spatial_ref_sysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findMany
   */
  export type spatial_ref_sysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys create
   */
  export type spatial_ref_sysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The data needed to create a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
  }

  /**
   * spatial_ref_sys createMany
   */
  export type spatial_ref_sysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys createManyAndReturn
   */
  export type spatial_ref_sysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys update
   */
  export type spatial_ref_sysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The data needed to update a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
    /**
     * Choose, which spatial_ref_sys to update.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys updateMany
   */
  export type spatial_ref_sysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateManyMutationInput, spatial_ref_sysUncheckedUpdateManyInput>
    /**
     * Filter which spatial_ref_sys to update
     */
    where?: spatial_ref_sysWhereInput
  }

  /**
   * spatial_ref_sys upsert
   */
  export type spatial_ref_sysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * The filter to search for the spatial_ref_sys to update in case it exists.
     */
    where: spatial_ref_sysWhereUniqueInput
    /**
     * In case the spatial_ref_sys found by the `where` argument doesn't exist, create a new spatial_ref_sys with this data.
     */
    create: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
    /**
     * In case the spatial_ref_sys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
  }

  /**
   * spatial_ref_sys delete
   */
  export type spatial_ref_sysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Filter which spatial_ref_sys to delete.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys deleteMany
   */
  export type spatial_ref_sysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to delete
     */
    where?: spatial_ref_sysWhereInput
  }

  /**
   * spatial_ref_sys without action
   */
  export type spatial_ref_sysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    name: 'name',
    email: 'email',
    phone: 'phone',
    createdAt: 'createdAt',
    gender: 'gender',
    isVerified: 'isVerified',
    password: 'password',
    updatedAt: 'updatedAt',
    id: 'id',
    birthDate: 'birthDate',
    city: 'city',
    completedRides: 'completedRides',
    genderPreference: 'genderPreference',
    rideSearchWindowDays: 'rideSearchWindowDays',
    isPremium: 'isPremium',
    joinDate: 'joinDate',
    profileImage: 'profileImage',
    rating: 'rating',
    currentLat: 'currentLat',
    currentLng: 'currentLng',
    drivingLicenseUrl: 'drivingLicenseUrl',
    idBackImageUrl: 'idBackImageUrl',
    idFrontImageUrl: 'idFrontImageUrl',
    autoRenew: 'autoRenew',
    darkMode: 'darkMode',
    hasSeenOnboarding: 'hasSeenOnboarding',
    idVerificationStatus: 'idVerificationStatus',
    nextFreeRideAt: 'nextFreeRideAt',
    passwordResetExpires: 'passwordResetExpires',
    passwordResetToken: 'passwordResetToken',
    preferredLanguage: 'preferredLanguage',
    premiumEndDate: 'premiumEndDate',
    premiumStartDate: 'premiumStartDate',
    referralCode: 'referralCode',
    profileImageLocked: 'profileImageLocked',
    role: 'role',
    emailVerificationExpires: 'emailVerificationExpires',
    emailVerificationToken: 'emailVerificationToken',
    isEmailVerified: 'isEmailVerified',
    hasUsedFreeTrial: 'hasUsedFreeTrial',
    isEligibleForReward: 'isEligibleForReward',
    referralsCount: 'referralsCount',
    driverLicenseExpiryDate: 'driverLicenseExpiryDate',
    homeAddress: 'homeAddress',
    homeLat: 'homeLat',
    homeLng: 'homeLng',
    workAddress: 'workAddress',
    workLat: 'workLat',
    workLng: 'workLng'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CarScalarFieldEnum: {
    id: 'id',
    brand: 'brand',
    model: 'model',
    year: 'year',
    color: 'color',
    plate: 'plate',
    licensePhoto: 'licensePhoto',
    isVerified: 'isVerified',
    userId: 'userId',
    createdAt: 'createdAt',
    verificationStatus: 'verificationStatus',
    licenseExpiryDate: 'licenseExpiryDate'
  };

  export type CarScalarFieldEnum = (typeof CarScalarFieldEnum)[keyof typeof CarScalarFieldEnum]


  export const CarLicenseHistoryScalarFieldEnum: {
    id: 'id',
    photoUrl: 'photoUrl',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    carId: 'carId'
  };

  export type CarLicenseHistoryScalarFieldEnum = (typeof CarLicenseHistoryScalarFieldEnum)[keyof typeof CarLicenseHistoryScalarFieldEnum]


  export const RideScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    carId: 'carId',
    carInfo: 'carInfo',
    serviceType: 'serviceType',
    seats: 'seats',
    price: 'price',
    receiptPrice: 'receiptPrice',
    renterScreenshotUrl: 'renterScreenshotUrl',
    additionalInfo: 'additionalInfo',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    arrivedAt: 'arrivedAt',
    time: 'time',
    isTimeArranged: 'isTimeArranged',
    etaMinutes: 'etaMinutes',
    destination: 'destination',
    origin: 'origin',
    fromCity: 'fromCity',
    fromSuburb: 'fromSuburb',
    toCity: 'toCity',
    toSuburb: 'toSuburb',
    fromCityNorm: 'fromCityNorm',
    fromSuburbNorm: 'fromSuburbNorm',
    toCityNorm: 'toCityNorm',
    toSuburbNorm: 'toSuburbNorm',
    rideType: 'rideType',
    isRequest: 'isRequest',
    isVerified: 'isVerified',
    isAnonymous: 'isAnonymous',
    status: 'status',
    allowedGender: 'allowedGender',
    destinationLat: 'destinationLat',
    destinationLng: 'destinationLng',
    originLat: 'originLat',
    originLng: 'originLng',
    polyline: 'polyline',
    scheduledRideId: 'scheduledRideId'
  };

  export type RideScalarFieldEnum = (typeof RideScalarFieldEnum)[keyof typeof RideScalarFieldEnum]


  export const RideInterestScalarFieldEnum: {
    id: 'id',
    rideId: 'rideId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type RideInterestScalarFieldEnum = (typeof RideInterestScalarFieldEnum)[keyof typeof RideInterestScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    rideId: 'rideId',
    userId: 'userId',
    createdAt: 'createdAt',
    status: 'status',
    invitationId: 'invitationId'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    price: 'price',
    rideId: 'rideId',
    userId: 'userId',
    createdAt: 'createdAt',
    status: 'status'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    rideId: 'rideId',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatMemberScalarFieldEnum: {
    id: 'id',
    hasStarted: 'hasStarted',
    hasEnded: 'hasEnded',
    chatId: 'chatId',
    userId: 'userId',
    bookingId: 'bookingId',
    createdAt: 'createdAt'
  };

  export type ChatMemberScalarFieldEnum = (typeof ChatMemberScalarFieldEnum)[keyof typeof ChatMemberScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    type: 'type',
    chatId: 'chatId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    userId: 'userId',
    relatedId: 'relatedId',
    createdAt: 'createdAt',
    bookingStatus: 'bookingStatus'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    comment: 'comment',
    rideId: 'rideId',
    givenById: 'givenById',
    receivedById: 'receivedById',
    createdAt: 'createdAt',
    arrivalOnTime: 'arrivalOnTime',
    startOnTime: 'startOnTime'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    createdAt: 'createdAt',
    description: 'description',
    threshold: 'threshold'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    badgeId: 'badgeId',
    createdAt: 'createdAt',
    earnedAt: 'earnedAt',
    lostAt: 'lostAt',
    progress: 'progress'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    code: 'code',
    referrerId: 'referrerId',
    refereeId: 'refereeId',
    bonusGiven: 'bonusGiven',
    createdAt: 'createdAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const AppConfigScalarFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type AppConfigScalarFieldEnum = (typeof AppConfigScalarFieldEnum)[keyof typeof AppConfigScalarFieldEnum]


  export const UserStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    onTimeStarts: 'onTimeStarts',
    onTimeArrivals: 'onTimeArrivals',
    totalChatMessages: 'totalChatMessages',
    fastResponses: 'fastResponses',
    totalBookingsToAccept: 'totalBookingsToAccept',
    acceptedBookings: 'acceptedBookings',
    totalCancellations: 'totalCancellations',
    totalRidesAsDriver: 'totalRidesAsDriver',
    totalRidesAsPassenger: 'totalRidesAsPassenger',
    completedFreeRidesAsDriver: 'completedFreeRidesAsDriver',
    fastResponseOpportunities: 'fastResponseOpportunities',
    fastResponseSuccesses: 'fastResponseSuccesses'
  };

  export type UserStatsScalarFieldEnum = (typeof UserStatsScalarFieldEnum)[keyof typeof UserStatsScalarFieldEnum]


  export const PromoCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    userId: 'userId',
    isUsed: 'isUsed',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type PromoCodeScalarFieldEnum = (typeof PromoCodeScalarFieldEnum)[keyof typeof PromoCodeScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reason: 'reason',
    comment: 'comment',
    status: 'status',
    rideId: 'rideId',
    reporterId: 'reporterId',
    reportedUserId: 'reportedUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const AdminLastVisitScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    resource: 'resource',
    lastVisitedAt: 'lastVisitedAt'
  };

  export type AdminLastVisitScalarFieldEnum = (typeof AdminLastVisitScalarFieldEnum)[keyof typeof AdminLastVisitScalarFieldEnum]


  export const SavedRouteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    polyline: 'polyline',
    originAddress: 'originAddress',
    originLat: 'originLat',
    originLng: 'originLng',
    originCity: 'originCity',
    originSuburb: 'originSuburb',
    destinationAddress: 'destinationAddress',
    destinationLat: 'destinationLat',
    destinationLng: 'destinationLng',
    destinationCity: 'destinationCity',
    destinationSuburb: 'destinationSuburb',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type SavedRouteScalarFieldEnum = (typeof SavedRouteScalarFieldEnum)[keyof typeof SavedRouteScalarFieldEnum]


  export const ScheduledRideScalarFieldEnum: {
    id: 'id',
    origin: 'origin',
    destination: 'destination',
    fromCity: 'fromCity',
    toCity: 'toCity',
    originLat: 'originLat',
    originLng: 'originLng',
    destinationLat: 'destinationLat',
    destinationLng: 'destinationLng',
    seats: 'seats',
    price: 'price',
    scheduleTime: 'scheduleTime',
    daysOfWeek: 'daysOfWeek',
    isActive: 'isActive',
    driverId: 'driverId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fromSuburb: 'fromSuburb',
    toSuburb: 'toSuburb'
  };

  export type ScheduledRideScalarFieldEnum = (typeof ScheduledRideScalarFieldEnum)[keyof typeof ScheduledRideScalarFieldEnum]


  export const RideCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    rideId: 'rideId',
    userId: 'userId',
    parentId: 'parentId'
  };

  export type RideCommentScalarFieldEnum = (typeof RideCommentScalarFieldEnum)[keyof typeof RideCommentScalarFieldEnum]


  export const GroupBookingInvitationScalarFieldEnum: {
    id: 'id',
    rideId: 'rideId',
    initiatorId: 'initiatorId',
    seats: 'seats',
    expiresAt: 'expiresAt',
    status: 'status'
  };

  export type GroupBookingInvitationScalarFieldEnum = (typeof GroupBookingInvitationScalarFieldEnum)[keyof typeof GroupBookingInvitationScalarFieldEnum]


  export const Spatial_ref_sysScalarFieldEnum: {
    srid: 'srid',
    auth_name: 'auth_name',
    auth_srid: 'auth_srid',
    srtext: 'srtext',
    proj4text: 'proj4text'
  };

  export type Spatial_ref_sysScalarFieldEnum = (typeof Spatial_ref_sysScalarFieldEnum)[keyof typeof Spatial_ref_sysScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'RideStatus'
   */
  export type EnumRideStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RideStatus'>
    


  /**
   * Reference to a field of type 'RideStatus[]'
   */
  export type ListEnumRideStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RideStatus[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'OfferStatus'
   */
  export type EnumOfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferStatus'>
    


  /**
   * Reference to a field of type 'OfferStatus[]'
   */
  export type ListEnumOfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferStatus[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    gender?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    password?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    id?: StringFilter<"User"> | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    city?: StringNullableFilter<"User"> | string | null
    completedRides?: IntFilter<"User"> | number
    genderPreference?: StringFilter<"User"> | string
    rideSearchWindowDays?: IntFilter<"User"> | number
    isPremium?: BoolFilter<"User"> | boolean
    joinDate?: DateTimeFilter<"User"> | Date | string
    profileImage?: StringNullableFilter<"User"> | string | null
    rating?: FloatFilter<"User"> | number
    currentLat?: FloatNullableFilter<"User"> | number | null
    currentLng?: FloatNullableFilter<"User"> | number | null
    drivingLicenseUrl?: StringNullableFilter<"User"> | string | null
    idBackImageUrl?: StringNullableFilter<"User"> | string | null
    idFrontImageUrl?: StringNullableFilter<"User"> | string | null
    autoRenew?: BoolFilter<"User"> | boolean
    darkMode?: BoolFilter<"User"> | boolean
    hasSeenOnboarding?: BoolFilter<"User"> | boolean
    idVerificationStatus?: EnumVerificationStatusFilter<"User"> | $Enums.VerificationStatus
    nextFreeRideAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringFilter<"User"> | string
    premiumEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    premiumStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    referralCode?: StringNullableFilter<"User"> | string | null
    profileImageLocked?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    hasUsedFreeTrial?: BoolFilter<"User"> | boolean
    isEligibleForReward?: BoolFilter<"User"> | boolean
    referralsCount?: IntFilter<"User"> | number
    driverLicenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    homeAddress?: StringNullableFilter<"User"> | string | null
    homeLat?: FloatNullableFilter<"User"> | number | null
    homeLng?: FloatNullableFilter<"User"> | number | null
    workAddress?: StringNullableFilter<"User"> | string | null
    workLat?: FloatNullableFilter<"User"> | number | null
    workLng?: FloatNullableFilter<"User"> | number | null
    lastVisits?: AdminLastVisitListRelationFilter
    bookings?: BookingListRelationFilter
    initiatedInvitations?: GroupBookingInvitationListRelationFilter
    car?: XOR<CarNullableRelationFilter, CarWhereInput> | null
    chats?: ChatMemberListRelationFilter
    feedbacksGiven?: FeedbackListRelationFilter
    feedbacksReceived?: FeedbackListRelationFilter
    messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    offers?: OfferListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    referralReceived?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
    referralsMade?: ReferralListRelationFilter
    reportsReceived?: ReportListRelationFilter
    reportsMade?: ReportListRelationFilter
    rides?: RideListRelationFilter
    comments?: RideCommentListRelationFilter
    interests?: RideInterestListRelationFilter
    savedRoutes?: SavedRouteListRelationFilter
    scheduledRides?: ScheduledRideListRelationFilter
    badges?: UserBadgeListRelationFilter
    stats?: XOR<UserStatsNullableRelationFilter, UserStatsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    gender?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    password?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    completedRides?: SortOrder
    genderPreference?: SortOrder
    rideSearchWindowDays?: SortOrder
    isPremium?: SortOrder
    joinDate?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    rating?: SortOrder
    currentLat?: SortOrderInput | SortOrder
    currentLng?: SortOrderInput | SortOrder
    drivingLicenseUrl?: SortOrderInput | SortOrder
    idBackImageUrl?: SortOrderInput | SortOrder
    idFrontImageUrl?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    darkMode?: SortOrder
    hasSeenOnboarding?: SortOrder
    idVerificationStatus?: SortOrder
    nextFreeRideAt?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    premiumEndDate?: SortOrderInput | SortOrder
    premiumStartDate?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    profileImageLocked?: SortOrder
    role?: SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    hasUsedFreeTrial?: SortOrder
    isEligibleForReward?: SortOrder
    referralsCount?: SortOrder
    driverLicenseExpiryDate?: SortOrderInput | SortOrder
    homeAddress?: SortOrderInput | SortOrder
    homeLat?: SortOrderInput | SortOrder
    homeLng?: SortOrderInput | SortOrder
    workAddress?: SortOrderInput | SortOrder
    workLat?: SortOrderInput | SortOrder
    workLng?: SortOrderInput | SortOrder
    lastVisits?: AdminLastVisitOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    initiatedInvitations?: GroupBookingInvitationOrderByRelationAggregateInput
    car?: CarOrderByWithRelationInput
    chats?: ChatMemberOrderByRelationAggregateInput
    feedbacksGiven?: FeedbackOrderByRelationAggregateInput
    feedbacksReceived?: FeedbackOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    promoCodes?: PromoCodeOrderByRelationAggregateInput
    referralReceived?: ReferralOrderByWithRelationInput
    referralsMade?: ReferralOrderByRelationAggregateInput
    reportsReceived?: ReportOrderByRelationAggregateInput
    reportsMade?: ReportOrderByRelationAggregateInput
    rides?: RideOrderByRelationAggregateInput
    comments?: RideCommentOrderByRelationAggregateInput
    interests?: RideInterestOrderByRelationAggregateInput
    savedRoutes?: SavedRouteOrderByRelationAggregateInput
    scheduledRides?: ScheduledRideOrderByRelationAggregateInput
    badges?: UserBadgeOrderByRelationAggregateInput
    stats?: UserStatsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    phone?: string
    id?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    gender?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    password?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    city?: StringNullableFilter<"User"> | string | null
    completedRides?: IntFilter<"User"> | number
    genderPreference?: StringFilter<"User"> | string
    rideSearchWindowDays?: IntFilter<"User"> | number
    isPremium?: BoolFilter<"User"> | boolean
    joinDate?: DateTimeFilter<"User"> | Date | string
    profileImage?: StringNullableFilter<"User"> | string | null
    rating?: FloatFilter<"User"> | number
    currentLat?: FloatNullableFilter<"User"> | number | null
    currentLng?: FloatNullableFilter<"User"> | number | null
    drivingLicenseUrl?: StringNullableFilter<"User"> | string | null
    idBackImageUrl?: StringNullableFilter<"User"> | string | null
    idFrontImageUrl?: StringNullableFilter<"User"> | string | null
    autoRenew?: BoolFilter<"User"> | boolean
    darkMode?: BoolFilter<"User"> | boolean
    hasSeenOnboarding?: BoolFilter<"User"> | boolean
    idVerificationStatus?: EnumVerificationStatusFilter<"User"> | $Enums.VerificationStatus
    nextFreeRideAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringFilter<"User"> | string
    premiumEndDate?: DateTimeNullableFilter<"User"> | Date | string | null
    premiumStartDate?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImageLocked?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    emailVerificationExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    isEmailVerified?: BoolFilter<"User"> | boolean
    hasUsedFreeTrial?: BoolFilter<"User"> | boolean
    isEligibleForReward?: BoolFilter<"User"> | boolean
    referralsCount?: IntFilter<"User"> | number
    driverLicenseExpiryDate?: DateTimeNullableFilter<"User"> | Date | string | null
    homeAddress?: StringNullableFilter<"User"> | string | null
    homeLat?: FloatNullableFilter<"User"> | number | null
    homeLng?: FloatNullableFilter<"User"> | number | null
    workAddress?: StringNullableFilter<"User"> | string | null
    workLat?: FloatNullableFilter<"User"> | number | null
    workLng?: FloatNullableFilter<"User"> | number | null
    lastVisits?: AdminLastVisitListRelationFilter
    bookings?: BookingListRelationFilter
    initiatedInvitations?: GroupBookingInvitationListRelationFilter
    car?: XOR<CarNullableRelationFilter, CarWhereInput> | null
    chats?: ChatMemberListRelationFilter
    feedbacksGiven?: FeedbackListRelationFilter
    feedbacksReceived?: FeedbackListRelationFilter
    messages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    offers?: OfferListRelationFilter
    promoCodes?: PromoCodeListRelationFilter
    referralReceived?: XOR<ReferralNullableRelationFilter, ReferralWhereInput> | null
    referralsMade?: ReferralListRelationFilter
    reportsReceived?: ReportListRelationFilter
    reportsMade?: ReportListRelationFilter
    rides?: RideListRelationFilter
    comments?: RideCommentListRelationFilter
    interests?: RideInterestListRelationFilter
    savedRoutes?: SavedRouteListRelationFilter
    scheduledRides?: ScheduledRideListRelationFilter
    badges?: UserBadgeListRelationFilter
    stats?: XOR<UserStatsNullableRelationFilter, UserStatsWhereInput> | null
  }, "id" | "email" | "phone" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    gender?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    password?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    birthDate?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    completedRides?: SortOrder
    genderPreference?: SortOrder
    rideSearchWindowDays?: SortOrder
    isPremium?: SortOrder
    joinDate?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    rating?: SortOrder
    currentLat?: SortOrderInput | SortOrder
    currentLng?: SortOrderInput | SortOrder
    drivingLicenseUrl?: SortOrderInput | SortOrder
    idBackImageUrl?: SortOrderInput | SortOrder
    idFrontImageUrl?: SortOrderInput | SortOrder
    autoRenew?: SortOrder
    darkMode?: SortOrder
    hasSeenOnboarding?: SortOrder
    idVerificationStatus?: SortOrder
    nextFreeRideAt?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrder
    premiumEndDate?: SortOrderInput | SortOrder
    premiumStartDate?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    profileImageLocked?: SortOrder
    role?: SortOrder
    emailVerificationExpires?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    isEmailVerified?: SortOrder
    hasUsedFreeTrial?: SortOrder
    isEligibleForReward?: SortOrder
    referralsCount?: SortOrder
    driverLicenseExpiryDate?: SortOrderInput | SortOrder
    homeAddress?: SortOrderInput | SortOrder
    homeLat?: SortOrderInput | SortOrder
    homeLng?: SortOrderInput | SortOrder
    workAddress?: SortOrderInput | SortOrder
    workLat?: SortOrderInput | SortOrder
    workLng?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    password?: StringWithAggregatesFilter<"User"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    id?: StringWithAggregatesFilter<"User"> | string
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    completedRides?: IntWithAggregatesFilter<"User"> | number
    genderPreference?: StringWithAggregatesFilter<"User"> | string
    rideSearchWindowDays?: IntWithAggregatesFilter<"User"> | number
    isPremium?: BoolWithAggregatesFilter<"User"> | boolean
    joinDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    rating?: FloatWithAggregatesFilter<"User"> | number
    currentLat?: FloatNullableWithAggregatesFilter<"User"> | number | null
    currentLng?: FloatNullableWithAggregatesFilter<"User"> | number | null
    drivingLicenseUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    idBackImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    idFrontImageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    autoRenew?: BoolWithAggregatesFilter<"User"> | boolean
    darkMode?: BoolWithAggregatesFilter<"User"> | boolean
    hasSeenOnboarding?: BoolWithAggregatesFilter<"User"> | boolean
    idVerificationStatus?: EnumVerificationStatusWithAggregatesFilter<"User"> | $Enums.VerificationStatus
    nextFreeRideAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredLanguage?: StringWithAggregatesFilter<"User"> | string
    premiumEndDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    premiumStartDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileImageLocked?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringWithAggregatesFilter<"User"> | string
    emailVerificationExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    hasUsedFreeTrial?: BoolWithAggregatesFilter<"User"> | boolean
    isEligibleForReward?: BoolWithAggregatesFilter<"User"> | boolean
    referralsCount?: IntWithAggregatesFilter<"User"> | number
    driverLicenseExpiryDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    homeAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    homeLat?: FloatNullableWithAggregatesFilter<"User"> | number | null
    homeLng?: FloatNullableWithAggregatesFilter<"User"> | number | null
    workAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    workLat?: FloatNullableWithAggregatesFilter<"User"> | number | null
    workLng?: FloatNullableWithAggregatesFilter<"User"> | number | null
  }

  export type CarWhereInput = {
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    id?: StringFilter<"Car"> | string
    brand?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    year?: IntFilter<"Car"> | number
    color?: StringFilter<"Car"> | string
    plate?: StringFilter<"Car"> | string
    licensePhoto?: StringNullableFilter<"Car"> | string | null
    isVerified?: BoolFilter<"Car"> | boolean
    userId?: StringFilter<"Car"> | string
    createdAt?: DateTimeFilter<"Car"> | Date | string
    verificationStatus?: EnumVerificationStatusFilter<"Car"> | $Enums.VerificationStatus
    licenseExpiryDate?: DateTimeNullableFilter<"Car"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    licenseHistory?: CarLicenseHistoryListRelationFilter
    rides?: RideListRelationFilter
  }

  export type CarOrderByWithRelationInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    plate?: SortOrder
    licensePhoto?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    verificationStatus?: SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    licenseHistory?: CarLicenseHistoryOrderByRelationAggregateInput
    rides?: RideOrderByRelationAggregateInput
  }

  export type CarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CarWhereInput | CarWhereInput[]
    OR?: CarWhereInput[]
    NOT?: CarWhereInput | CarWhereInput[]
    brand?: StringFilter<"Car"> | string
    model?: StringFilter<"Car"> | string
    year?: IntFilter<"Car"> | number
    color?: StringFilter<"Car"> | string
    plate?: StringFilter<"Car"> | string
    licensePhoto?: StringNullableFilter<"Car"> | string | null
    isVerified?: BoolFilter<"Car"> | boolean
    createdAt?: DateTimeFilter<"Car"> | Date | string
    verificationStatus?: EnumVerificationStatusFilter<"Car"> | $Enums.VerificationStatus
    licenseExpiryDate?: DateTimeNullableFilter<"Car"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    licenseHistory?: CarLicenseHistoryListRelationFilter
    rides?: RideListRelationFilter
  }, "id" | "userId">

  export type CarOrderByWithAggregationInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    plate?: SortOrder
    licensePhoto?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    verificationStatus?: SortOrder
    licenseExpiryDate?: SortOrderInput | SortOrder
    _count?: CarCountOrderByAggregateInput
    _avg?: CarAvgOrderByAggregateInput
    _max?: CarMaxOrderByAggregateInput
    _min?: CarMinOrderByAggregateInput
    _sum?: CarSumOrderByAggregateInput
  }

  export type CarScalarWhereWithAggregatesInput = {
    AND?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    OR?: CarScalarWhereWithAggregatesInput[]
    NOT?: CarScalarWhereWithAggregatesInput | CarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Car"> | string
    brand?: StringWithAggregatesFilter<"Car"> | string
    model?: StringWithAggregatesFilter<"Car"> | string
    year?: IntWithAggregatesFilter<"Car"> | number
    color?: StringWithAggregatesFilter<"Car"> | string
    plate?: StringWithAggregatesFilter<"Car"> | string
    licensePhoto?: StringNullableWithAggregatesFilter<"Car"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Car"> | boolean
    userId?: StringWithAggregatesFilter<"Car"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Car"> | Date | string
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"Car"> | $Enums.VerificationStatus
    licenseExpiryDate?: DateTimeNullableWithAggregatesFilter<"Car"> | Date | string | null
  }

  export type CarLicenseHistoryWhereInput = {
    AND?: CarLicenseHistoryWhereInput | CarLicenseHistoryWhereInput[]
    OR?: CarLicenseHistoryWhereInput[]
    NOT?: CarLicenseHistoryWhereInput | CarLicenseHistoryWhereInput[]
    id?: StringFilter<"CarLicenseHistory"> | string
    photoUrl?: StringFilter<"CarLicenseHistory"> | string
    status?: EnumVerificationStatusFilter<"CarLicenseHistory"> | $Enums.VerificationStatus
    notes?: StringNullableFilter<"CarLicenseHistory"> | string | null
    createdAt?: DateTimeFilter<"CarLicenseHistory"> | Date | string
    carId?: StringFilter<"CarLicenseHistory"> | string
    car?: XOR<CarRelationFilter, CarWhereInput>
  }

  export type CarLicenseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    carId?: SortOrder
    car?: CarOrderByWithRelationInput
  }

  export type CarLicenseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CarLicenseHistoryWhereInput | CarLicenseHistoryWhereInput[]
    OR?: CarLicenseHistoryWhereInput[]
    NOT?: CarLicenseHistoryWhereInput | CarLicenseHistoryWhereInput[]
    photoUrl?: StringFilter<"CarLicenseHistory"> | string
    status?: EnumVerificationStatusFilter<"CarLicenseHistory"> | $Enums.VerificationStatus
    notes?: StringNullableFilter<"CarLicenseHistory"> | string | null
    createdAt?: DateTimeFilter<"CarLicenseHistory"> | Date | string
    carId?: StringFilter<"CarLicenseHistory"> | string
    car?: XOR<CarRelationFilter, CarWhereInput>
  }, "id">

  export type CarLicenseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    carId?: SortOrder
    _count?: CarLicenseHistoryCountOrderByAggregateInput
    _max?: CarLicenseHistoryMaxOrderByAggregateInput
    _min?: CarLicenseHistoryMinOrderByAggregateInput
  }

  export type CarLicenseHistoryScalarWhereWithAggregatesInput = {
    AND?: CarLicenseHistoryScalarWhereWithAggregatesInput | CarLicenseHistoryScalarWhereWithAggregatesInput[]
    OR?: CarLicenseHistoryScalarWhereWithAggregatesInput[]
    NOT?: CarLicenseHistoryScalarWhereWithAggregatesInput | CarLicenseHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CarLicenseHistory"> | string
    photoUrl?: StringWithAggregatesFilter<"CarLicenseHistory"> | string
    status?: EnumVerificationStatusWithAggregatesFilter<"CarLicenseHistory"> | $Enums.VerificationStatus
    notes?: StringNullableWithAggregatesFilter<"CarLicenseHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CarLicenseHistory"> | Date | string
    carId?: StringWithAggregatesFilter<"CarLicenseHistory"> | string
  }

  export type RideWhereInput = {
    AND?: RideWhereInput | RideWhereInput[]
    OR?: RideWhereInput[]
    NOT?: RideWhereInput | RideWhereInput[]
    id?: StringFilter<"Ride"> | string
    driverId?: StringFilter<"Ride"> | string
    carId?: StringNullableFilter<"Ride"> | string | null
    carInfo?: StringNullableFilter<"Ride"> | string | null
    serviceType?: StringNullableFilter<"Ride"> | string | null
    seats?: IntFilter<"Ride"> | number
    price?: FloatFilter<"Ride"> | number
    receiptPrice?: FloatNullableFilter<"Ride"> | number | null
    renterScreenshotUrl?: StringNullableFilter<"Ride"> | string | null
    additionalInfo?: StringNullableFilter<"Ride"> | string | null
    createdAt?: DateTimeFilter<"Ride"> | Date | string
    startedAt?: DateTimeNullableFilter<"Ride"> | Date | string | null
    arrivedAt?: DateTimeNullableFilter<"Ride"> | Date | string | null
    time?: DateTimeFilter<"Ride"> | Date | string
    isTimeArranged?: BoolFilter<"Ride"> | boolean
    etaMinutes?: IntNullableFilter<"Ride"> | number | null
    destination?: StringFilter<"Ride"> | string
    origin?: StringFilter<"Ride"> | string
    fromCity?: StringFilter<"Ride"> | string
    fromSuburb?: StringFilter<"Ride"> | string
    toCity?: StringFilter<"Ride"> | string
    toSuburb?: StringFilter<"Ride"> | string
    fromCityNorm?: StringNullableFilter<"Ride"> | string | null
    fromSuburbNorm?: StringNullableFilter<"Ride"> | string | null
    toCityNorm?: StringNullableFilter<"Ride"> | string | null
    toSuburbNorm?: StringNullableFilter<"Ride"> | string | null
    rideType?: StringFilter<"Ride"> | string
    isRequest?: BoolFilter<"Ride"> | boolean
    isVerified?: BoolFilter<"Ride"> | boolean
    isAnonymous?: BoolFilter<"Ride"> | boolean
    status?: EnumRideStatusFilter<"Ride"> | $Enums.RideStatus
    allowedGender?: StringFilter<"Ride"> | string
    destinationLat?: FloatFilter<"Ride"> | number
    destinationLng?: FloatFilter<"Ride"> | number
    originLat?: FloatFilter<"Ride"> | number
    originLng?: FloatFilter<"Ride"> | number
    polyline?: StringNullableFilter<"Ride"> | string | null
    scheduledRideId?: StringNullableFilter<"Ride"> | string | null
    bookings?: BookingListRelationFilter
    chat?: XOR<ChatNullableRelationFilter, ChatWhereInput> | null
    feedbacks?: FeedbackListRelationFilter
    offers?: OfferListRelationFilter
    reports?: ReportListRelationFilter
    car?: XOR<CarNullableRelationFilter, CarWhereInput> | null
    driver?: XOR<UserRelationFilter, UserWhereInput>
    comments?: RideCommentListRelationFilter
    scheduledRide?: XOR<ScheduledRideNullableRelationFilter, ScheduledRideWhereInput> | null
    interests?: RideInterestListRelationFilter
    groupInvitations?: GroupBookingInvitationListRelationFilter
  }

  export type RideOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    carId?: SortOrderInput | SortOrder
    carInfo?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    seats?: SortOrder
    price?: SortOrder
    receiptPrice?: SortOrderInput | SortOrder
    renterScreenshotUrl?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    arrivedAt?: SortOrderInput | SortOrder
    time?: SortOrder
    isTimeArranged?: SortOrder
    etaMinutes?: SortOrderInput | SortOrder
    destination?: SortOrder
    origin?: SortOrder
    fromCity?: SortOrder
    fromSuburb?: SortOrder
    toCity?: SortOrder
    toSuburb?: SortOrder
    fromCityNorm?: SortOrderInput | SortOrder
    fromSuburbNorm?: SortOrderInput | SortOrder
    toCityNorm?: SortOrderInput | SortOrder
    toSuburbNorm?: SortOrderInput | SortOrder
    rideType?: SortOrder
    isRequest?: SortOrder
    isVerified?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    allowedGender?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    polyline?: SortOrderInput | SortOrder
    scheduledRideId?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    chat?: ChatOrderByWithRelationInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    offers?: OfferOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    car?: CarOrderByWithRelationInput
    driver?: UserOrderByWithRelationInput
    comments?: RideCommentOrderByRelationAggregateInput
    scheduledRide?: ScheduledRideOrderByWithRelationInput
    interests?: RideInterestOrderByRelationAggregateInput
    groupInvitations?: GroupBookingInvitationOrderByRelationAggregateInput
  }

  export type RideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RideWhereInput | RideWhereInput[]
    OR?: RideWhereInput[]
    NOT?: RideWhereInput | RideWhereInput[]
    driverId?: StringFilter<"Ride"> | string
    carId?: StringNullableFilter<"Ride"> | string | null
    carInfo?: StringNullableFilter<"Ride"> | string | null
    serviceType?: StringNullableFilter<"Ride"> | string | null
    seats?: IntFilter<"Ride"> | number
    price?: FloatFilter<"Ride"> | number
    receiptPrice?: FloatNullableFilter<"Ride"> | number | null
    renterScreenshotUrl?: StringNullableFilter<"Ride"> | string | null
    additionalInfo?: StringNullableFilter<"Ride"> | string | null
    createdAt?: DateTimeFilter<"Ride"> | Date | string
    startedAt?: DateTimeNullableFilter<"Ride"> | Date | string | null
    arrivedAt?: DateTimeNullableFilter<"Ride"> | Date | string | null
    time?: DateTimeFilter<"Ride"> | Date | string
    isTimeArranged?: BoolFilter<"Ride"> | boolean
    etaMinutes?: IntNullableFilter<"Ride"> | number | null
    destination?: StringFilter<"Ride"> | string
    origin?: StringFilter<"Ride"> | string
    fromCity?: StringFilter<"Ride"> | string
    fromSuburb?: StringFilter<"Ride"> | string
    toCity?: StringFilter<"Ride"> | string
    toSuburb?: StringFilter<"Ride"> | string
    fromCityNorm?: StringNullableFilter<"Ride"> | string | null
    fromSuburbNorm?: StringNullableFilter<"Ride"> | string | null
    toCityNorm?: StringNullableFilter<"Ride"> | string | null
    toSuburbNorm?: StringNullableFilter<"Ride"> | string | null
    rideType?: StringFilter<"Ride"> | string
    isRequest?: BoolFilter<"Ride"> | boolean
    isVerified?: BoolFilter<"Ride"> | boolean
    isAnonymous?: BoolFilter<"Ride"> | boolean
    status?: EnumRideStatusFilter<"Ride"> | $Enums.RideStatus
    allowedGender?: StringFilter<"Ride"> | string
    destinationLat?: FloatFilter<"Ride"> | number
    destinationLng?: FloatFilter<"Ride"> | number
    originLat?: FloatFilter<"Ride"> | number
    originLng?: FloatFilter<"Ride"> | number
    polyline?: StringNullableFilter<"Ride"> | string | null
    scheduledRideId?: StringNullableFilter<"Ride"> | string | null
    bookings?: BookingListRelationFilter
    chat?: XOR<ChatNullableRelationFilter, ChatWhereInput> | null
    feedbacks?: FeedbackListRelationFilter
    offers?: OfferListRelationFilter
    reports?: ReportListRelationFilter
    car?: XOR<CarNullableRelationFilter, CarWhereInput> | null
    driver?: XOR<UserRelationFilter, UserWhereInput>
    comments?: RideCommentListRelationFilter
    scheduledRide?: XOR<ScheduledRideNullableRelationFilter, ScheduledRideWhereInput> | null
    interests?: RideInterestListRelationFilter
    groupInvitations?: GroupBookingInvitationListRelationFilter
  }, "id">

  export type RideOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    carId?: SortOrderInput | SortOrder
    carInfo?: SortOrderInput | SortOrder
    serviceType?: SortOrderInput | SortOrder
    seats?: SortOrder
    price?: SortOrder
    receiptPrice?: SortOrderInput | SortOrder
    renterScreenshotUrl?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    arrivedAt?: SortOrderInput | SortOrder
    time?: SortOrder
    isTimeArranged?: SortOrder
    etaMinutes?: SortOrderInput | SortOrder
    destination?: SortOrder
    origin?: SortOrder
    fromCity?: SortOrder
    fromSuburb?: SortOrder
    toCity?: SortOrder
    toSuburb?: SortOrder
    fromCityNorm?: SortOrderInput | SortOrder
    fromSuburbNorm?: SortOrderInput | SortOrder
    toCityNorm?: SortOrderInput | SortOrder
    toSuburbNorm?: SortOrderInput | SortOrder
    rideType?: SortOrder
    isRequest?: SortOrder
    isVerified?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    allowedGender?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    polyline?: SortOrderInput | SortOrder
    scheduledRideId?: SortOrderInput | SortOrder
    _count?: RideCountOrderByAggregateInput
    _avg?: RideAvgOrderByAggregateInput
    _max?: RideMaxOrderByAggregateInput
    _min?: RideMinOrderByAggregateInput
    _sum?: RideSumOrderByAggregateInput
  }

  export type RideScalarWhereWithAggregatesInput = {
    AND?: RideScalarWhereWithAggregatesInput | RideScalarWhereWithAggregatesInput[]
    OR?: RideScalarWhereWithAggregatesInput[]
    NOT?: RideScalarWhereWithAggregatesInput | RideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ride"> | string
    driverId?: StringWithAggregatesFilter<"Ride"> | string
    carId?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    carInfo?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    serviceType?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    seats?: IntWithAggregatesFilter<"Ride"> | number
    price?: FloatWithAggregatesFilter<"Ride"> | number
    receiptPrice?: FloatNullableWithAggregatesFilter<"Ride"> | number | null
    renterScreenshotUrl?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    additionalInfo?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ride"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"Ride"> | Date | string | null
    arrivedAt?: DateTimeNullableWithAggregatesFilter<"Ride"> | Date | string | null
    time?: DateTimeWithAggregatesFilter<"Ride"> | Date | string
    isTimeArranged?: BoolWithAggregatesFilter<"Ride"> | boolean
    etaMinutes?: IntNullableWithAggregatesFilter<"Ride"> | number | null
    destination?: StringWithAggregatesFilter<"Ride"> | string
    origin?: StringWithAggregatesFilter<"Ride"> | string
    fromCity?: StringWithAggregatesFilter<"Ride"> | string
    fromSuburb?: StringWithAggregatesFilter<"Ride"> | string
    toCity?: StringWithAggregatesFilter<"Ride"> | string
    toSuburb?: StringWithAggregatesFilter<"Ride"> | string
    fromCityNorm?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    fromSuburbNorm?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    toCityNorm?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    toSuburbNorm?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    rideType?: StringWithAggregatesFilter<"Ride"> | string
    isRequest?: BoolWithAggregatesFilter<"Ride"> | boolean
    isVerified?: BoolWithAggregatesFilter<"Ride"> | boolean
    isAnonymous?: BoolWithAggregatesFilter<"Ride"> | boolean
    status?: EnumRideStatusWithAggregatesFilter<"Ride"> | $Enums.RideStatus
    allowedGender?: StringWithAggregatesFilter<"Ride"> | string
    destinationLat?: FloatWithAggregatesFilter<"Ride"> | number
    destinationLng?: FloatWithAggregatesFilter<"Ride"> | number
    originLat?: FloatWithAggregatesFilter<"Ride"> | number
    originLng?: FloatWithAggregatesFilter<"Ride"> | number
    polyline?: StringNullableWithAggregatesFilter<"Ride"> | string | null
    scheduledRideId?: StringNullableWithAggregatesFilter<"Ride"> | string | null
  }

  export type RideInterestWhereInput = {
    AND?: RideInterestWhereInput | RideInterestWhereInput[]
    OR?: RideInterestWhereInput[]
    NOT?: RideInterestWhereInput | RideInterestWhereInput[]
    id?: StringFilter<"RideInterest"> | string
    rideId?: StringFilter<"RideInterest"> | string
    userId?: StringFilter<"RideInterest"> | string
    createdAt?: DateTimeFilter<"RideInterest"> | Date | string
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RideInterestOrderByWithRelationInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    ride?: RideOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RideInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rideId_userId?: RideInterestRideIdUserIdCompoundUniqueInput
    AND?: RideInterestWhereInput | RideInterestWhereInput[]
    OR?: RideInterestWhereInput[]
    NOT?: RideInterestWhereInput | RideInterestWhereInput[]
    rideId?: StringFilter<"RideInterest"> | string
    userId?: StringFilter<"RideInterest"> | string
    createdAt?: DateTimeFilter<"RideInterest"> | Date | string
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "rideId_userId">

  export type RideInterestOrderByWithAggregationInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: RideInterestCountOrderByAggregateInput
    _max?: RideInterestMaxOrderByAggregateInput
    _min?: RideInterestMinOrderByAggregateInput
  }

  export type RideInterestScalarWhereWithAggregatesInput = {
    AND?: RideInterestScalarWhereWithAggregatesInput | RideInterestScalarWhereWithAggregatesInput[]
    OR?: RideInterestScalarWhereWithAggregatesInput[]
    NOT?: RideInterestScalarWhereWithAggregatesInput | RideInterestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RideInterest"> | string
    rideId?: StringWithAggregatesFilter<"RideInterest"> | string
    userId?: StringWithAggregatesFilter<"RideInterest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RideInterest"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    rideId?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    invitationId?: StringNullableFilter<"Booking"> | string | null
    invitation?: XOR<GroupBookingInvitationNullableRelationFilter, GroupBookingInvitationWhereInput> | null
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    chatMember?: XOR<ChatMemberNullableRelationFilter, ChatMemberWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    invitationId?: SortOrderInput | SortOrder
    invitation?: GroupBookingInvitationOrderByWithRelationInput
    ride?: RideOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    chatMember?: ChatMemberOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rideId_userId?: BookingRideIdUserIdCompoundUniqueInput
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    rideId?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    invitationId?: StringNullableFilter<"Booking"> | string | null
    invitation?: XOR<GroupBookingInvitationNullableRelationFilter, GroupBookingInvitationWhereInput> | null
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    chatMember?: XOR<ChatMemberNullableRelationFilter, ChatMemberWhereInput> | null
  }, "id" | "rideId_userId">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    invitationId?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    rideId?: StringWithAggregatesFilter<"Booking"> | string
    userId?: StringWithAggregatesFilter<"Booking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    invitationId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: StringFilter<"Offer"> | string
    price?: FloatFilter<"Offer"> | number
    rideId?: StringFilter<"Offer"> | string
    userId?: StringFilter<"Offer"> | string
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    ride?: RideOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    price?: FloatFilter<"Offer"> | number
    rideId?: StringFilter<"Offer"> | string
    userId?: StringFilter<"Offer"> | string
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offer"> | string
    price?: FloatWithAggregatesFilter<"Offer"> | number
    rideId?: StringWithAggregatesFilter<"Offer"> | string
    userId?: StringWithAggregatesFilter<"Offer"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    status?: EnumOfferStatusWithAggregatesFilter<"Offer"> | $Enums.OfferStatus
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    rideId?: StringNullableFilter<"Chat"> | string | null
    startedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    ride?: XOR<RideNullableRelationFilter, RideWhereInput> | null
    members?: ChatMemberListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    rideId?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    ride?: RideOrderByWithRelationInput
    members?: ChatMemberOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rideId?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    startedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    ride?: XOR<RideNullableRelationFilter, RideWhereInput> | null
    members?: ChatMemberListRelationFilter
    messages?: MessageListRelationFilter
  }, "id" | "rideId">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    rideId?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    rideId?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type ChatMemberWhereInput = {
    AND?: ChatMemberWhereInput | ChatMemberWhereInput[]
    OR?: ChatMemberWhereInput[]
    NOT?: ChatMemberWhereInput | ChatMemberWhereInput[]
    id?: StringFilter<"ChatMember"> | string
    hasStarted?: BoolFilter<"ChatMember"> | boolean
    hasEnded?: BoolFilter<"ChatMember"> | boolean
    chatId?: StringFilter<"ChatMember"> | string
    userId?: StringFilter<"ChatMember"> | string
    bookingId?: StringNullableFilter<"ChatMember"> | string | null
    createdAt?: DateTimeFilter<"ChatMember"> | Date | string
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatMemberOrderByWithRelationInput = {
    id?: SortOrder
    hasStarted?: SortOrder
    hasEnded?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    chat?: ChatOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    AND?: ChatMemberWhereInput | ChatMemberWhereInput[]
    OR?: ChatMemberWhereInput[]
    NOT?: ChatMemberWhereInput | ChatMemberWhereInput[]
    hasStarted?: BoolFilter<"ChatMember"> | boolean
    hasEnded?: BoolFilter<"ChatMember"> | boolean
    chatId?: StringFilter<"ChatMember"> | string
    userId?: StringFilter<"ChatMember"> | string
    createdAt?: DateTimeFilter<"ChatMember"> | Date | string
    booking?: XOR<BookingNullableRelationFilter, BookingWhereInput> | null
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "bookingId">

  export type ChatMemberOrderByWithAggregationInput = {
    id?: SortOrder
    hasStarted?: SortOrder
    hasEnded?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatMemberCountOrderByAggregateInput
    _max?: ChatMemberMaxOrderByAggregateInput
    _min?: ChatMemberMinOrderByAggregateInput
  }

  export type ChatMemberScalarWhereWithAggregatesInput = {
    AND?: ChatMemberScalarWhereWithAggregatesInput | ChatMemberScalarWhereWithAggregatesInput[]
    OR?: ChatMemberScalarWhereWithAggregatesInput[]
    NOT?: ChatMemberScalarWhereWithAggregatesInput | ChatMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMember"> | string
    hasStarted?: BoolWithAggregatesFilter<"ChatMember"> | boolean
    hasEnded?: BoolWithAggregatesFilter<"ChatMember"> | boolean
    chatId?: StringWithAggregatesFilter<"ChatMember"> | string
    userId?: StringWithAggregatesFilter<"ChatMember"> | string
    bookingId?: StringNullableWithAggregatesFilter<"ChatMember"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatMember"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    chat?: XOR<ChatRelationFilter, ChatWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: StringWithAggregatesFilter<"Message"> | string
    chatId?: StringWithAggregatesFilter<"Message"> | string
    userId?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    relatedId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    bookingStatus?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    relatedId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    bookingStatus?: StringNullableFilter<"Notification"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    userId?: StringWithAggregatesFilter<"Notification"> | string
    relatedId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    bookingStatus?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    comment?: StringNullableFilter<"Feedback"> | string | null
    rideId?: StringFilter<"Feedback"> | string
    givenById?: StringFilter<"Feedback"> | string
    receivedById?: StringFilter<"Feedback"> | string
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    arrivalOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    startOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    givenBy?: XOR<UserRelationFilter, UserWhereInput>
    receivedBy?: XOR<UserRelationFilter, UserWhereInput>
    ride?: XOR<RideRelationFilter, RideWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    rideId?: SortOrder
    givenById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    arrivalOnTime?: SortOrderInput | SortOrder
    startOnTime?: SortOrderInput | SortOrder
    givenBy?: UserOrderByWithRelationInput
    receivedBy?: UserOrderByWithRelationInput
    ride?: RideOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rideId_givenById?: FeedbackRideIdGivenByIdCompoundUniqueInput
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    rating?: IntFilter<"Feedback"> | number
    comment?: StringNullableFilter<"Feedback"> | string | null
    rideId?: StringFilter<"Feedback"> | string
    givenById?: StringFilter<"Feedback"> | string
    receivedById?: StringFilter<"Feedback"> | string
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    arrivalOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    startOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    givenBy?: XOR<UserRelationFilter, UserWhereInput>
    receivedBy?: XOR<UserRelationFilter, UserWhereInput>
    ride?: XOR<RideRelationFilter, RideWhereInput>
  }, "id" | "rideId_givenById">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    rideId?: SortOrder
    givenById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    arrivalOnTime?: SortOrderInput | SortOrder
    startOnTime?: SortOrderInput | SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    rating?: IntWithAggregatesFilter<"Feedback"> | number
    comment?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    rideId?: StringWithAggregatesFilter<"Feedback"> | string
    givenById?: StringWithAggregatesFilter<"Feedback"> | string
    receivedById?: StringWithAggregatesFilter<"Feedback"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    arrivalOnTime?: BoolNullableWithAggregatesFilter<"Feedback"> | boolean | null
    startOnTime?: BoolNullableWithAggregatesFilter<"Feedback"> | boolean | null
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    icon?: StringFilter<"Badge"> | string
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    description?: StringFilter<"Badge"> | string
    threshold?: FloatFilter<"Badge"> | number
    users?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    threshold?: SortOrder
    users?: UserBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    icon?: StringFilter<"Badge"> | string
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    description?: StringFilter<"Badge"> | string
    threshold?: FloatFilter<"Badge"> | number
    users?: UserBadgeListRelationFilter
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    threshold?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    icon?: StringWithAggregatesFilter<"Badge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
    description?: StringWithAggregatesFilter<"Badge"> | string
    threshold?: FloatWithAggregatesFilter<"Badge"> | number
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    earnedAt?: DateTimeNullableFilter<"UserBadge"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"UserBadge"> | Date | string | null
    progress?: FloatFilter<"UserBadge"> | number
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    earnedAt?: SortOrderInput | SortOrder
    lostAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    badge?: BadgeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_badgeId?: UserBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    earnedAt?: DateTimeNullableFilter<"UserBadge"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"UserBadge"> | Date | string | null
    progress?: FloatFilter<"UserBadge"> | number
    badge?: XOR<BadgeRelationFilter, BadgeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    earnedAt?: SortOrderInput | SortOrder
    lostAt?: SortOrderInput | SortOrder
    progress?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _avg?: UserBadgeAvgOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
    _sum?: UserBadgeSumOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBadge"> | string
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
    earnedAt?: DateTimeNullableWithAggregatesFilter<"UserBadge"> | Date | string | null
    lostAt?: DateTimeNullableWithAggregatesFilter<"UserBadge"> | Date | string | null
    progress?: FloatWithAggregatesFilter<"UserBadge"> | number
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    code?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringFilter<"Referral"> | string
    bonusGiven?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    referee?: XOR<UserRelationFilter, UserWhereInput>
    referrer?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    bonusGiven?: SortOrder
    createdAt?: SortOrder
    referee?: UserOrderByWithRelationInput
    referrer?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refereeId?: string
    referrerId_refereeId?: ReferralReferrerIdRefereeIdCompoundUniqueInput
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    code?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    bonusGiven?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    referee?: XOR<UserRelationFilter, UserWhereInput>
    referrer?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "refereeId" | "referrerId_refereeId">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    bonusGiven?: SortOrder
    createdAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    code?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    refereeId?: StringWithAggregatesFilter<"Referral"> | string
    bonusGiven?: BoolWithAggregatesFilter<"Referral"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type AppConfigWhereInput = {
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    key?: StringFilter<"AppConfig"> | string
    value?: StringFilter<"AppConfig"> | string
  }

  export type AppConfigOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type AppConfigWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: AppConfigWhereInput | AppConfigWhereInput[]
    OR?: AppConfigWhereInput[]
    NOT?: AppConfigWhereInput | AppConfigWhereInput[]
    value?: StringFilter<"AppConfig"> | string
  }, "key">

  export type AppConfigOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    _count?: AppConfigCountOrderByAggregateInput
    _max?: AppConfigMaxOrderByAggregateInput
    _min?: AppConfigMinOrderByAggregateInput
  }

  export type AppConfigScalarWhereWithAggregatesInput = {
    AND?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    OR?: AppConfigScalarWhereWithAggregatesInput[]
    NOT?: AppConfigScalarWhereWithAggregatesInput | AppConfigScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"AppConfig"> | string
    value?: StringWithAggregatesFilter<"AppConfig"> | string
  }

  export type UserStatsWhereInput = {
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    id?: StringFilter<"UserStats"> | string
    userId?: StringFilter<"UserStats"> | string
    onTimeStarts?: IntFilter<"UserStats"> | number
    onTimeArrivals?: IntFilter<"UserStats"> | number
    totalChatMessages?: IntFilter<"UserStats"> | number
    fastResponses?: IntFilter<"UserStats"> | number
    totalBookingsToAccept?: IntFilter<"UserStats"> | number
    acceptedBookings?: IntFilter<"UserStats"> | number
    totalCancellations?: IntFilter<"UserStats"> | number
    totalRidesAsDriver?: IntFilter<"UserStats"> | number
    totalRidesAsPassenger?: IntFilter<"UserStats"> | number
    completedFreeRidesAsDriver?: IntFilter<"UserStats"> | number
    fastResponseOpportunities?: IntFilter<"UserStats"> | number
    fastResponseSuccesses?: IntFilter<"UserStats"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    onTimeStarts?: SortOrder
    onTimeArrivals?: SortOrder
    totalChatMessages?: SortOrder
    fastResponses?: SortOrder
    totalBookingsToAccept?: SortOrder
    acceptedBookings?: SortOrder
    totalCancellations?: SortOrder
    totalRidesAsDriver?: SortOrder
    totalRidesAsPassenger?: SortOrder
    completedFreeRidesAsDriver?: SortOrder
    fastResponseOpportunities?: SortOrder
    fastResponseSuccesses?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserStatsWhereInput | UserStatsWhereInput[]
    OR?: UserStatsWhereInput[]
    NOT?: UserStatsWhereInput | UserStatsWhereInput[]
    onTimeStarts?: IntFilter<"UserStats"> | number
    onTimeArrivals?: IntFilter<"UserStats"> | number
    totalChatMessages?: IntFilter<"UserStats"> | number
    fastResponses?: IntFilter<"UserStats"> | number
    totalBookingsToAccept?: IntFilter<"UserStats"> | number
    acceptedBookings?: IntFilter<"UserStats"> | number
    totalCancellations?: IntFilter<"UserStats"> | number
    totalRidesAsDriver?: IntFilter<"UserStats"> | number
    totalRidesAsPassenger?: IntFilter<"UserStats"> | number
    completedFreeRidesAsDriver?: IntFilter<"UserStats"> | number
    fastResponseOpportunities?: IntFilter<"UserStats"> | number
    fastResponseSuccesses?: IntFilter<"UserStats"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    onTimeStarts?: SortOrder
    onTimeArrivals?: SortOrder
    totalChatMessages?: SortOrder
    fastResponses?: SortOrder
    totalBookingsToAccept?: SortOrder
    acceptedBookings?: SortOrder
    totalCancellations?: SortOrder
    totalRidesAsDriver?: SortOrder
    totalRidesAsPassenger?: SortOrder
    completedFreeRidesAsDriver?: SortOrder
    fastResponseOpportunities?: SortOrder
    fastResponseSuccesses?: SortOrder
    _count?: UserStatsCountOrderByAggregateInput
    _avg?: UserStatsAvgOrderByAggregateInput
    _max?: UserStatsMaxOrderByAggregateInput
    _min?: UserStatsMinOrderByAggregateInput
    _sum?: UserStatsSumOrderByAggregateInput
  }

  export type UserStatsScalarWhereWithAggregatesInput = {
    AND?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    OR?: UserStatsScalarWhereWithAggregatesInput[]
    NOT?: UserStatsScalarWhereWithAggregatesInput | UserStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserStats"> | string
    userId?: StringWithAggregatesFilter<"UserStats"> | string
    onTimeStarts?: IntWithAggregatesFilter<"UserStats"> | number
    onTimeArrivals?: IntWithAggregatesFilter<"UserStats"> | number
    totalChatMessages?: IntWithAggregatesFilter<"UserStats"> | number
    fastResponses?: IntWithAggregatesFilter<"UserStats"> | number
    totalBookingsToAccept?: IntWithAggregatesFilter<"UserStats"> | number
    acceptedBookings?: IntWithAggregatesFilter<"UserStats"> | number
    totalCancellations?: IntWithAggregatesFilter<"UserStats"> | number
    totalRidesAsDriver?: IntWithAggregatesFilter<"UserStats"> | number
    totalRidesAsPassenger?: IntWithAggregatesFilter<"UserStats"> | number
    completedFreeRidesAsDriver?: IntWithAggregatesFilter<"UserStats"> | number
    fastResponseOpportunities?: IntWithAggregatesFilter<"UserStats"> | number
    fastResponseSuccesses?: IntWithAggregatesFilter<"UserStats"> | number
  }

  export type PromoCodeWhereInput = {
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    userId?: StringFilter<"PromoCode"> | string
    isUsed?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    expiresAt?: DateTimeFilter<"PromoCode"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PromoCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PromoCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: PromoCodeWhereInput | PromoCodeWhereInput[]
    OR?: PromoCodeWhereInput[]
    NOT?: PromoCodeWhereInput | PromoCodeWhereInput[]
    userId?: StringFilter<"PromoCode"> | string
    isUsed?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    expiresAt?: DateTimeFilter<"PromoCode"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type PromoCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: PromoCodeCountOrderByAggregateInput
    _max?: PromoCodeMaxOrderByAggregateInput
    _min?: PromoCodeMinOrderByAggregateInput
  }

  export type PromoCodeScalarWhereWithAggregatesInput = {
    AND?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    OR?: PromoCodeScalarWhereWithAggregatesInput[]
    NOT?: PromoCodeScalarWhereWithAggregatesInput | PromoCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoCode"> | string
    code?: StringWithAggregatesFilter<"PromoCode"> | string
    userId?: StringWithAggregatesFilter<"PromoCode"> | string
    isUsed?: BoolWithAggregatesFilter<"PromoCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"PromoCode"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    reason?: StringFilter<"Report"> | string
    comment?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    rideId?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    reportedUser?: XOR<UserRelationFilter, UserWhereInput>
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    ride?: XOR<RideRelationFilter, RideWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrder
    rideId?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportedUser?: UserOrderByWithRelationInput
    reporter?: UserOrderByWithRelationInput
    ride?: RideOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reason?: StringFilter<"Report"> | string
    comment?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    rideId?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    reportedUser?: XOR<UserRelationFilter, UserWhereInput>
    reporter?: XOR<UserRelationFilter, UserWhereInput>
    ride?: XOR<RideRelationFilter, RideWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrderInput | SortOrder
    status?: SortOrder
    rideId?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    reason?: StringWithAggregatesFilter<"Report"> | string
    comment?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    rideId?: StringWithAggregatesFilter<"Report"> | string
    reporterId?: StringWithAggregatesFilter<"Report"> | string
    reportedUserId?: StringWithAggregatesFilter<"Report"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type AdminLastVisitWhereInput = {
    AND?: AdminLastVisitWhereInput | AdminLastVisitWhereInput[]
    OR?: AdminLastVisitWhereInput[]
    NOT?: AdminLastVisitWhereInput | AdminLastVisitWhereInput[]
    id?: StringFilter<"AdminLastVisit"> | string
    adminId?: StringFilter<"AdminLastVisit"> | string
    resource?: StringFilter<"AdminLastVisit"> | string
    lastVisitedAt?: DateTimeFilter<"AdminLastVisit"> | Date | string
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminLastVisitOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    resource?: SortOrder
    lastVisitedAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminLastVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adminId_resource?: AdminLastVisitAdminIdResourceCompoundUniqueInput
    AND?: AdminLastVisitWhereInput | AdminLastVisitWhereInput[]
    OR?: AdminLastVisitWhereInput[]
    NOT?: AdminLastVisitWhereInput | AdminLastVisitWhereInput[]
    adminId?: StringFilter<"AdminLastVisit"> | string
    resource?: StringFilter<"AdminLastVisit"> | string
    lastVisitedAt?: DateTimeFilter<"AdminLastVisit"> | Date | string
    admin?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "adminId_resource">

  export type AdminLastVisitOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    resource?: SortOrder
    lastVisitedAt?: SortOrder
    _count?: AdminLastVisitCountOrderByAggregateInput
    _max?: AdminLastVisitMaxOrderByAggregateInput
    _min?: AdminLastVisitMinOrderByAggregateInput
  }

  export type AdminLastVisitScalarWhereWithAggregatesInput = {
    AND?: AdminLastVisitScalarWhereWithAggregatesInput | AdminLastVisitScalarWhereWithAggregatesInput[]
    OR?: AdminLastVisitScalarWhereWithAggregatesInput[]
    NOT?: AdminLastVisitScalarWhereWithAggregatesInput | AdminLastVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminLastVisit"> | string
    adminId?: StringWithAggregatesFilter<"AdminLastVisit"> | string
    resource?: StringWithAggregatesFilter<"AdminLastVisit"> | string
    lastVisitedAt?: DateTimeWithAggregatesFilter<"AdminLastVisit"> | Date | string
  }

  export type SavedRouteWhereInput = {
    AND?: SavedRouteWhereInput | SavedRouteWhereInput[]
    OR?: SavedRouteWhereInput[]
    NOT?: SavedRouteWhereInput | SavedRouteWhereInput[]
    id?: StringFilter<"SavedRoute"> | string
    name?: StringFilter<"SavedRoute"> | string
    icon?: StringNullableFilter<"SavedRoute"> | string | null
    polyline?: StringNullableFilter<"SavedRoute"> | string | null
    originAddress?: StringFilter<"SavedRoute"> | string
    originLat?: FloatFilter<"SavedRoute"> | number
    originLng?: FloatFilter<"SavedRoute"> | number
    originCity?: StringNullableFilter<"SavedRoute"> | string | null
    originSuburb?: StringNullableFilter<"SavedRoute"> | string | null
    destinationAddress?: StringFilter<"SavedRoute"> | string
    destinationLat?: FloatFilter<"SavedRoute"> | number
    destinationLng?: FloatFilter<"SavedRoute"> | number
    destinationCity?: StringNullableFilter<"SavedRoute"> | string | null
    destinationSuburb?: StringNullableFilter<"SavedRoute"> | string | null
    userId?: StringFilter<"SavedRoute"> | string
    createdAt?: DateTimeFilter<"SavedRoute"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SavedRouteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    polyline?: SortOrderInput | SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    originCity?: SortOrderInput | SortOrder
    originSuburb?: SortOrderInput | SortOrder
    destinationAddress?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    destinationCity?: SortOrderInput | SortOrder
    destinationSuburb?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SavedRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SavedRouteWhereInput | SavedRouteWhereInput[]
    OR?: SavedRouteWhereInput[]
    NOT?: SavedRouteWhereInput | SavedRouteWhereInput[]
    name?: StringFilter<"SavedRoute"> | string
    icon?: StringNullableFilter<"SavedRoute"> | string | null
    polyline?: StringNullableFilter<"SavedRoute"> | string | null
    originAddress?: StringFilter<"SavedRoute"> | string
    originLat?: FloatFilter<"SavedRoute"> | number
    originLng?: FloatFilter<"SavedRoute"> | number
    originCity?: StringNullableFilter<"SavedRoute"> | string | null
    originSuburb?: StringNullableFilter<"SavedRoute"> | string | null
    destinationAddress?: StringFilter<"SavedRoute"> | string
    destinationLat?: FloatFilter<"SavedRoute"> | number
    destinationLng?: FloatFilter<"SavedRoute"> | number
    destinationCity?: StringNullableFilter<"SavedRoute"> | string | null
    destinationSuburb?: StringNullableFilter<"SavedRoute"> | string | null
    userId?: StringFilter<"SavedRoute"> | string
    createdAt?: DateTimeFilter<"SavedRoute"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SavedRouteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    polyline?: SortOrderInput | SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    originCity?: SortOrderInput | SortOrder
    originSuburb?: SortOrderInput | SortOrder
    destinationAddress?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    destinationCity?: SortOrderInput | SortOrder
    destinationSuburb?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: SavedRouteCountOrderByAggregateInput
    _avg?: SavedRouteAvgOrderByAggregateInput
    _max?: SavedRouteMaxOrderByAggregateInput
    _min?: SavedRouteMinOrderByAggregateInput
    _sum?: SavedRouteSumOrderByAggregateInput
  }

  export type SavedRouteScalarWhereWithAggregatesInput = {
    AND?: SavedRouteScalarWhereWithAggregatesInput | SavedRouteScalarWhereWithAggregatesInput[]
    OR?: SavedRouteScalarWhereWithAggregatesInput[]
    NOT?: SavedRouteScalarWhereWithAggregatesInput | SavedRouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SavedRoute"> | string
    name?: StringWithAggregatesFilter<"SavedRoute"> | string
    icon?: StringNullableWithAggregatesFilter<"SavedRoute"> | string | null
    polyline?: StringNullableWithAggregatesFilter<"SavedRoute"> | string | null
    originAddress?: StringWithAggregatesFilter<"SavedRoute"> | string
    originLat?: FloatWithAggregatesFilter<"SavedRoute"> | number
    originLng?: FloatWithAggregatesFilter<"SavedRoute"> | number
    originCity?: StringNullableWithAggregatesFilter<"SavedRoute"> | string | null
    originSuburb?: StringNullableWithAggregatesFilter<"SavedRoute"> | string | null
    destinationAddress?: StringWithAggregatesFilter<"SavedRoute"> | string
    destinationLat?: FloatWithAggregatesFilter<"SavedRoute"> | number
    destinationLng?: FloatWithAggregatesFilter<"SavedRoute"> | number
    destinationCity?: StringNullableWithAggregatesFilter<"SavedRoute"> | string | null
    destinationSuburb?: StringNullableWithAggregatesFilter<"SavedRoute"> | string | null
    userId?: StringWithAggregatesFilter<"SavedRoute"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SavedRoute"> | Date | string
  }

  export type ScheduledRideWhereInput = {
    AND?: ScheduledRideWhereInput | ScheduledRideWhereInput[]
    OR?: ScheduledRideWhereInput[]
    NOT?: ScheduledRideWhereInput | ScheduledRideWhereInput[]
    id?: StringFilter<"ScheduledRide"> | string
    origin?: StringFilter<"ScheduledRide"> | string
    destination?: StringFilter<"ScheduledRide"> | string
    fromCity?: StringFilter<"ScheduledRide"> | string
    toCity?: StringFilter<"ScheduledRide"> | string
    originLat?: FloatFilter<"ScheduledRide"> | number
    originLng?: FloatFilter<"ScheduledRide"> | number
    destinationLat?: FloatFilter<"ScheduledRide"> | number
    destinationLng?: FloatFilter<"ScheduledRide"> | number
    seats?: IntFilter<"ScheduledRide"> | number
    price?: FloatFilter<"ScheduledRide"> | number
    scheduleTime?: StringFilter<"ScheduledRide"> | string
    daysOfWeek?: IntNullableListFilter<"ScheduledRide">
    isActive?: BoolFilter<"ScheduledRide"> | boolean
    driverId?: StringFilter<"ScheduledRide"> | string
    createdAt?: DateTimeFilter<"ScheduledRide"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRide"> | Date | string
    fromSuburb?: StringNullableFilter<"ScheduledRide"> | string | null
    toSuburb?: StringNullableFilter<"ScheduledRide"> | string | null
    driver?: XOR<UserRelationFilter, UserWhereInput>
    createdRides?: RideListRelationFilter
  }

  export type ScheduledRideOrderByWithRelationInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    fromCity?: SortOrder
    toCity?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    scheduleTime?: SortOrder
    daysOfWeek?: SortOrder
    isActive?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromSuburb?: SortOrderInput | SortOrder
    toSuburb?: SortOrderInput | SortOrder
    driver?: UserOrderByWithRelationInput
    createdRides?: RideOrderByRelationAggregateInput
  }

  export type ScheduledRideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledRideWhereInput | ScheduledRideWhereInput[]
    OR?: ScheduledRideWhereInput[]
    NOT?: ScheduledRideWhereInput | ScheduledRideWhereInput[]
    origin?: StringFilter<"ScheduledRide"> | string
    destination?: StringFilter<"ScheduledRide"> | string
    fromCity?: StringFilter<"ScheduledRide"> | string
    toCity?: StringFilter<"ScheduledRide"> | string
    originLat?: FloatFilter<"ScheduledRide"> | number
    originLng?: FloatFilter<"ScheduledRide"> | number
    destinationLat?: FloatFilter<"ScheduledRide"> | number
    destinationLng?: FloatFilter<"ScheduledRide"> | number
    seats?: IntFilter<"ScheduledRide"> | number
    price?: FloatFilter<"ScheduledRide"> | number
    scheduleTime?: StringFilter<"ScheduledRide"> | string
    daysOfWeek?: IntNullableListFilter<"ScheduledRide">
    isActive?: BoolFilter<"ScheduledRide"> | boolean
    driverId?: StringFilter<"ScheduledRide"> | string
    createdAt?: DateTimeFilter<"ScheduledRide"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRide"> | Date | string
    fromSuburb?: StringNullableFilter<"ScheduledRide"> | string | null
    toSuburb?: StringNullableFilter<"ScheduledRide"> | string | null
    driver?: XOR<UserRelationFilter, UserWhereInput>
    createdRides?: RideListRelationFilter
  }, "id">

  export type ScheduledRideOrderByWithAggregationInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    fromCity?: SortOrder
    toCity?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    scheduleTime?: SortOrder
    daysOfWeek?: SortOrder
    isActive?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromSuburb?: SortOrderInput | SortOrder
    toSuburb?: SortOrderInput | SortOrder
    _count?: ScheduledRideCountOrderByAggregateInput
    _avg?: ScheduledRideAvgOrderByAggregateInput
    _max?: ScheduledRideMaxOrderByAggregateInput
    _min?: ScheduledRideMinOrderByAggregateInput
    _sum?: ScheduledRideSumOrderByAggregateInput
  }

  export type ScheduledRideScalarWhereWithAggregatesInput = {
    AND?: ScheduledRideScalarWhereWithAggregatesInput | ScheduledRideScalarWhereWithAggregatesInput[]
    OR?: ScheduledRideScalarWhereWithAggregatesInput[]
    NOT?: ScheduledRideScalarWhereWithAggregatesInput | ScheduledRideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledRide"> | string
    origin?: StringWithAggregatesFilter<"ScheduledRide"> | string
    destination?: StringWithAggregatesFilter<"ScheduledRide"> | string
    fromCity?: StringWithAggregatesFilter<"ScheduledRide"> | string
    toCity?: StringWithAggregatesFilter<"ScheduledRide"> | string
    originLat?: FloatWithAggregatesFilter<"ScheduledRide"> | number
    originLng?: FloatWithAggregatesFilter<"ScheduledRide"> | number
    destinationLat?: FloatWithAggregatesFilter<"ScheduledRide"> | number
    destinationLng?: FloatWithAggregatesFilter<"ScheduledRide"> | number
    seats?: IntWithAggregatesFilter<"ScheduledRide"> | number
    price?: FloatWithAggregatesFilter<"ScheduledRide"> | number
    scheduleTime?: StringWithAggregatesFilter<"ScheduledRide"> | string
    daysOfWeek?: IntNullableListFilter<"ScheduledRide">
    isActive?: BoolWithAggregatesFilter<"ScheduledRide"> | boolean
    driverId?: StringWithAggregatesFilter<"ScheduledRide"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledRide"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledRide"> | Date | string
    fromSuburb?: StringNullableWithAggregatesFilter<"ScheduledRide"> | string | null
    toSuburb?: StringNullableWithAggregatesFilter<"ScheduledRide"> | string | null
  }

  export type RideCommentWhereInput = {
    AND?: RideCommentWhereInput | RideCommentWhereInput[]
    OR?: RideCommentWhereInput[]
    NOT?: RideCommentWhereInput | RideCommentWhereInput[]
    id?: StringFilter<"RideComment"> | string
    content?: StringFilter<"RideComment"> | string
    createdAt?: DateTimeFilter<"RideComment"> | Date | string
    rideId?: StringFilter<"RideComment"> | string
    userId?: StringFilter<"RideComment"> | string
    parentId?: StringNullableFilter<"RideComment"> | string | null
    parent?: XOR<RideCommentNullableRelationFilter, RideCommentWhereInput> | null
    replies?: RideCommentListRelationFilter
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RideCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    parent?: RideCommentOrderByWithRelationInput
    replies?: RideCommentOrderByRelationAggregateInput
    ride?: RideOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RideCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RideCommentWhereInput | RideCommentWhereInput[]
    OR?: RideCommentWhereInput[]
    NOT?: RideCommentWhereInput | RideCommentWhereInput[]
    content?: StringFilter<"RideComment"> | string
    createdAt?: DateTimeFilter<"RideComment"> | Date | string
    rideId?: StringFilter<"RideComment"> | string
    userId?: StringFilter<"RideComment"> | string
    parentId?: StringNullableFilter<"RideComment"> | string | null
    parent?: XOR<RideCommentNullableRelationFilter, RideCommentWhereInput> | null
    replies?: RideCommentListRelationFilter
    ride?: XOR<RideRelationFilter, RideWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RideCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: RideCommentCountOrderByAggregateInput
    _max?: RideCommentMaxOrderByAggregateInput
    _min?: RideCommentMinOrderByAggregateInput
  }

  export type RideCommentScalarWhereWithAggregatesInput = {
    AND?: RideCommentScalarWhereWithAggregatesInput | RideCommentScalarWhereWithAggregatesInput[]
    OR?: RideCommentScalarWhereWithAggregatesInput[]
    NOT?: RideCommentScalarWhereWithAggregatesInput | RideCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RideComment"> | string
    content?: StringWithAggregatesFilter<"RideComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RideComment"> | Date | string
    rideId?: StringWithAggregatesFilter<"RideComment"> | string
    userId?: StringWithAggregatesFilter<"RideComment"> | string
    parentId?: StringNullableWithAggregatesFilter<"RideComment"> | string | null
  }

  export type GroupBookingInvitationWhereInput = {
    AND?: GroupBookingInvitationWhereInput | GroupBookingInvitationWhereInput[]
    OR?: GroupBookingInvitationWhereInput[]
    NOT?: GroupBookingInvitationWhereInput | GroupBookingInvitationWhereInput[]
    id?: StringFilter<"GroupBookingInvitation"> | string
    rideId?: StringFilter<"GroupBookingInvitation"> | string
    initiatorId?: StringFilter<"GroupBookingInvitation"> | string
    seats?: IntFilter<"GroupBookingInvitation"> | number
    expiresAt?: DateTimeFilter<"GroupBookingInvitation"> | Date | string
    status?: StringFilter<"GroupBookingInvitation"> | string
    bookings?: BookingListRelationFilter
    ride?: XOR<RideRelationFilter, RideWhereInput>
    initiator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GroupBookingInvitationOrderByWithRelationInput = {
    id?: SortOrder
    rideId?: SortOrder
    initiatorId?: SortOrder
    seats?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    ride?: RideOrderByWithRelationInput
    initiator?: UserOrderByWithRelationInput
  }

  export type GroupBookingInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupBookingInvitationWhereInput | GroupBookingInvitationWhereInput[]
    OR?: GroupBookingInvitationWhereInput[]
    NOT?: GroupBookingInvitationWhereInput | GroupBookingInvitationWhereInput[]
    rideId?: StringFilter<"GroupBookingInvitation"> | string
    initiatorId?: StringFilter<"GroupBookingInvitation"> | string
    seats?: IntFilter<"GroupBookingInvitation"> | number
    expiresAt?: DateTimeFilter<"GroupBookingInvitation"> | Date | string
    status?: StringFilter<"GroupBookingInvitation"> | string
    bookings?: BookingListRelationFilter
    ride?: XOR<RideRelationFilter, RideWhereInput>
    initiator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type GroupBookingInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    rideId?: SortOrder
    initiatorId?: SortOrder
    seats?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
    _count?: GroupBookingInvitationCountOrderByAggregateInput
    _avg?: GroupBookingInvitationAvgOrderByAggregateInput
    _max?: GroupBookingInvitationMaxOrderByAggregateInput
    _min?: GroupBookingInvitationMinOrderByAggregateInput
    _sum?: GroupBookingInvitationSumOrderByAggregateInput
  }

  export type GroupBookingInvitationScalarWhereWithAggregatesInput = {
    AND?: GroupBookingInvitationScalarWhereWithAggregatesInput | GroupBookingInvitationScalarWhereWithAggregatesInput[]
    OR?: GroupBookingInvitationScalarWhereWithAggregatesInput[]
    NOT?: GroupBookingInvitationScalarWhereWithAggregatesInput | GroupBookingInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GroupBookingInvitation"> | string
    rideId?: StringWithAggregatesFilter<"GroupBookingInvitation"> | string
    initiatorId?: StringWithAggregatesFilter<"GroupBookingInvitation"> | string
    seats?: IntWithAggregatesFilter<"GroupBookingInvitation"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"GroupBookingInvitation"> | Date | string
    status?: StringWithAggregatesFilter<"GroupBookingInvitation"> | string
  }

  export type spatial_ref_sysWhereInput = {
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    srid?: IntFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }

  export type spatial_ref_sysOrderByWithRelationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
  }

  export type spatial_ref_sysWhereUniqueInput = Prisma.AtLeast<{
    srid?: number
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }, "srid">

  export type spatial_ref_sysOrderByWithAggregationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
    _count?: spatial_ref_sysCountOrderByAggregateInput
    _avg?: spatial_ref_sysAvgOrderByAggregateInput
    _max?: spatial_ref_sysMaxOrderByAggregateInput
    _min?: spatial_ref_sysMinOrderByAggregateInput
    _sum?: spatial_ref_sysSumOrderByAggregateInput
  }

  export type spatial_ref_sysScalarWhereWithAggregatesInput = {
    AND?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    OR?: spatial_ref_sysScalarWhereWithAggregatesInput[]
    NOT?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    srid?: IntWithAggregatesFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableWithAggregatesFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
  }

  export type UserCreateInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CarCreateInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    user: UserCreateNestedOneWithoutCarInput
    licenseHistory?: CarLicenseHistoryCreateNestedManyWithoutCarInput
    rides?: RideCreateNestedManyWithoutCarInput
  }

  export type CarUncheckedCreateInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    userId: string
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    licenseHistory?: CarLicenseHistoryUncheckedCreateNestedManyWithoutCarInput
    rides?: RideUncheckedCreateNestedManyWithoutCarInput
  }

  export type CarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCarNestedInput
    licenseHistory?: CarLicenseHistoryUpdateManyWithoutCarNestedInput
    rides?: RideUpdateManyWithoutCarNestedInput
  }

  export type CarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    licenseHistory?: CarLicenseHistoryUncheckedUpdateManyWithoutCarNestedInput
    rides?: RideUncheckedUpdateManyWithoutCarNestedInput
  }

  export type CarCreateManyInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    userId: string
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
  }

  export type CarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CarLicenseHistoryCreateInput = {
    id?: string
    photoUrl: string
    status?: $Enums.VerificationStatus
    notes?: string | null
    createdAt?: Date | string
    car: CarCreateNestedOneWithoutLicenseHistoryInput
  }

  export type CarLicenseHistoryUncheckedCreateInput = {
    id?: string
    photoUrl: string
    status?: $Enums.VerificationStatus
    notes?: string | null
    createdAt?: Date | string
    carId: string
  }

  export type CarLicenseHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    car?: CarUpdateOneRequiredWithoutLicenseHistoryNestedInput
  }

  export type CarLicenseHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carId?: StringFieldUpdateOperationsInput | string
  }

  export type CarLicenseHistoryCreateManyInput = {
    id?: string
    photoUrl: string
    status?: $Enums.VerificationStatus
    notes?: string | null
    createdAt?: Date | string
    carId: string
  }

  export type CarLicenseHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarLicenseHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    carId?: StringFieldUpdateOperationsInput | string
  }

  export type RideCreateInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideCreateManyInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
  }

  export type RideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideInterestCreateInput = {
    id?: string
    createdAt?: Date | string
    ride: RideCreateNestedOneWithoutInterestsInput
    user: UserCreateNestedOneWithoutInterestsInput
  }

  export type RideInterestUncheckedCreateInput = {
    id?: string
    rideId: string
    userId: string
    createdAt?: Date | string
  }

  export type RideInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: RideUpdateOneRequiredWithoutInterestsNestedInput
    user?: UserUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type RideInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideInterestCreateManyInput = {
    id?: string
    rideId: string
    userId: string
    createdAt?: Date | string
  }

  export type RideInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitation?: GroupBookingInvitationCreateNestedOneWithoutBookingsInput
    ride: RideCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    chatMember?: ChatMemberCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    rideId: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitationId?: string | null
    chatMember?: ChatMemberUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitation?: GroupBookingInvitationUpdateOneWithoutBookingsNestedInput
    ride?: RideUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    chatMember?: ChatMemberUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
    chatMember?: ChatMemberUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    rideId: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitationId?: string | null
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OfferCreateInput = {
    id?: string
    price: number
    createdAt?: Date | string
    status?: $Enums.OfferStatus
    ride: RideCreateNestedOneWithoutOffersInput
    user: UserCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    price: number
    rideId: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.OfferStatus
  }

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    ride?: RideUpdateOneRequiredWithoutOffersNestedInput
    user?: UserUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
  }

  export type OfferCreateManyInput = {
    id?: string
    price: number
    rideId: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.OfferStatus
  }

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
  }

  export type ChatCreateInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    ride?: RideCreateNestedOneWithoutChatInput
    members?: ChatMemberCreateNestedManyWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    rideId?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    members?: ChatMemberUncheckedCreateNestedManyWithoutChatInput
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: RideUpdateOneWithoutChatNestedInput
    members?: ChatMemberUpdateManyWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUncheckedUpdateManyWithoutChatNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    rideId?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMemberCreateInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    createdAt?: Date | string
    booking?: BookingCreateNestedOneWithoutChatMemberInput
    chat: ChatCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutChatsInput
  }

  export type ChatMemberUncheckedCreateInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    chatId: string
    userId: string
    bookingId?: string | null
    createdAt?: Date | string
  }

  export type ChatMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutChatMemberNestedInput
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMemberCreateManyInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    chatId: string
    userId: string
    bookingId?: string | null
    createdAt?: Date | string
  }

  export type ChatMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
    user: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content: string
    type?: string
    chatId: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content: string
    type?: string
    chatId: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    relatedId?: string | null
    createdAt?: Date | string
    bookingStatus?: string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    userId: string
    relatedId?: string | null
    createdAt?: Date | string
    bookingStatus?: string | null
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    userId: string
    relatedId?: string | null
    createdAt?: Date | string
    bookingStatus?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
    givenBy: UserCreateNestedOneWithoutFeedbacksGivenInput
    receivedBy: UserCreateNestedOneWithoutFeedbacksReceivedInput
    ride: RideCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    rideId: string
    givenById: string
    receivedById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenBy?: UserUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutFeedbacksReceivedNestedInput
    ride?: RideUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: StringFieldUpdateOperationsInput | string
    givenById?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeedbackCreateManyInput = {
    id?: string
    rating: number
    comment?: string | null
    rideId: string
    givenById: string
    receivedById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: StringFieldUpdateOperationsInput | string
    givenById?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    icon: string
    createdAt?: Date | string
    description: string
    threshold: number
    users?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    icon: string
    createdAt?: Date | string
    description: string
    threshold: number
    users?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    users?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
    users?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    icon: string
    createdAt?: Date | string
    description: string
    threshold: number
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
  }

  export type UserBadgeCreateInput = {
    id?: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
    badge: BadgeCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    badgeId: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
  }

  export type UserBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type UserBadgeCreateManyInput = {
    id?: string
    userId: string
    badgeId: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
  }

  export type UserBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type ReferralCreateInput = {
    id?: string
    code: string
    bonusGiven?: boolean
    createdAt?: Date | string
    referee: UserCreateNestedOneWithoutReferralReceivedInput
    referrer: UserCreateNestedOneWithoutReferralsMadeInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    code: string
    referrerId: string
    refereeId: string
    bonusGiven?: boolean
    createdAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneRequiredWithoutReferralReceivedNestedInput
    referrer?: UserUpdateOneRequiredWithoutReferralsMadeNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    code: string
    referrerId: string
    refereeId: string
    bonusGiven?: boolean
    createdAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppConfigCreateInput = {
    key: string
    value: string
  }

  export type AppConfigUncheckedCreateInput = {
    key: string
    value: string
  }

  export type AppConfigUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type AppConfigUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type AppConfigCreateManyInput = {
    key: string
    value: string
  }

  export type AppConfigUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type AppConfigUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserStatsCreateInput = {
    id?: string
    onTimeStarts?: number
    onTimeArrivals?: number
    totalChatMessages?: number
    fastResponses?: number
    totalBookingsToAccept?: number
    acceptedBookings?: number
    totalCancellations?: number
    totalRidesAsDriver?: number
    totalRidesAsPassenger?: number
    completedFreeRidesAsDriver?: number
    fastResponseOpportunities?: number
    fastResponseSuccesses?: number
    user: UserCreateNestedOneWithoutStatsInput
  }

  export type UserStatsUncheckedCreateInput = {
    id?: string
    userId: string
    onTimeStarts?: number
    onTimeArrivals?: number
    totalChatMessages?: number
    fastResponses?: number
    totalBookingsToAccept?: number
    acceptedBookings?: number
    totalCancellations?: number
    totalRidesAsDriver?: number
    totalRidesAsPassenger?: number
    completedFreeRidesAsDriver?: number
    fastResponseOpportunities?: number
    fastResponseSuccesses?: number
  }

  export type UserStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    onTimeStarts?: IntFieldUpdateOperationsInput | number
    onTimeArrivals?: IntFieldUpdateOperationsInput | number
    totalChatMessages?: IntFieldUpdateOperationsInput | number
    fastResponses?: IntFieldUpdateOperationsInput | number
    totalBookingsToAccept?: IntFieldUpdateOperationsInput | number
    acceptedBookings?: IntFieldUpdateOperationsInput | number
    totalCancellations?: IntFieldUpdateOperationsInput | number
    totalRidesAsDriver?: IntFieldUpdateOperationsInput | number
    totalRidesAsPassenger?: IntFieldUpdateOperationsInput | number
    completedFreeRidesAsDriver?: IntFieldUpdateOperationsInput | number
    fastResponseOpportunities?: IntFieldUpdateOperationsInput | number
    fastResponseSuccesses?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStatsNestedInput
  }

  export type UserStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onTimeStarts?: IntFieldUpdateOperationsInput | number
    onTimeArrivals?: IntFieldUpdateOperationsInput | number
    totalChatMessages?: IntFieldUpdateOperationsInput | number
    fastResponses?: IntFieldUpdateOperationsInput | number
    totalBookingsToAccept?: IntFieldUpdateOperationsInput | number
    acceptedBookings?: IntFieldUpdateOperationsInput | number
    totalCancellations?: IntFieldUpdateOperationsInput | number
    totalRidesAsDriver?: IntFieldUpdateOperationsInput | number
    totalRidesAsPassenger?: IntFieldUpdateOperationsInput | number
    completedFreeRidesAsDriver?: IntFieldUpdateOperationsInput | number
    fastResponseOpportunities?: IntFieldUpdateOperationsInput | number
    fastResponseSuccesses?: IntFieldUpdateOperationsInput | number
  }

  export type UserStatsCreateManyInput = {
    id?: string
    userId: string
    onTimeStarts?: number
    onTimeArrivals?: number
    totalChatMessages?: number
    fastResponses?: number
    totalBookingsToAccept?: number
    acceptedBookings?: number
    totalCancellations?: number
    totalRidesAsDriver?: number
    totalRidesAsPassenger?: number
    completedFreeRidesAsDriver?: number
    fastResponseOpportunities?: number
    fastResponseSuccesses?: number
  }

  export type UserStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    onTimeStarts?: IntFieldUpdateOperationsInput | number
    onTimeArrivals?: IntFieldUpdateOperationsInput | number
    totalChatMessages?: IntFieldUpdateOperationsInput | number
    fastResponses?: IntFieldUpdateOperationsInput | number
    totalBookingsToAccept?: IntFieldUpdateOperationsInput | number
    acceptedBookings?: IntFieldUpdateOperationsInput | number
    totalCancellations?: IntFieldUpdateOperationsInput | number
    totalRidesAsDriver?: IntFieldUpdateOperationsInput | number
    totalRidesAsPassenger?: IntFieldUpdateOperationsInput | number
    completedFreeRidesAsDriver?: IntFieldUpdateOperationsInput | number
    fastResponseOpportunities?: IntFieldUpdateOperationsInput | number
    fastResponseSuccesses?: IntFieldUpdateOperationsInput | number
  }

  export type UserStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    onTimeStarts?: IntFieldUpdateOperationsInput | number
    onTimeArrivals?: IntFieldUpdateOperationsInput | number
    totalChatMessages?: IntFieldUpdateOperationsInput | number
    fastResponses?: IntFieldUpdateOperationsInput | number
    totalBookingsToAccept?: IntFieldUpdateOperationsInput | number
    acceptedBookings?: IntFieldUpdateOperationsInput | number
    totalCancellations?: IntFieldUpdateOperationsInput | number
    totalRidesAsDriver?: IntFieldUpdateOperationsInput | number
    totalRidesAsPassenger?: IntFieldUpdateOperationsInput | number
    completedFreeRidesAsDriver?: IntFieldUpdateOperationsInput | number
    fastResponseOpportunities?: IntFieldUpdateOperationsInput | number
    fastResponseSuccesses?: IntFieldUpdateOperationsInput | number
  }

  export type PromoCodeCreateInput = {
    id?: string
    code: string
    isUsed?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
    user: UserCreateNestedOneWithoutPromoCodesInput
  }

  export type PromoCodeUncheckedCreateInput = {
    id?: string
    code: string
    userId: string
    isUsed?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PromoCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPromoCodesNestedInput
  }

  export type PromoCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeCreateManyInput = {
    id?: string
    code: string
    userId: string
    isUsed?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PromoCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    ride: RideCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    rideId: string
    reporterId: string
    reportedUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    ride?: RideUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    rideId?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    rideId: string
    reporterId: string
    reportedUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    rideId?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLastVisitCreateInput = {
    id?: string
    resource: string
    lastVisitedAt?: Date | string
    admin: UserCreateNestedOneWithoutLastVisitsInput
  }

  export type AdminLastVisitUncheckedCreateInput = {
    id?: string
    adminId: string
    resource: string
    lastVisitedAt?: Date | string
  }

  export type AdminLastVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    lastVisitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutLastVisitsNestedInput
  }

  export type AdminLastVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    lastVisitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLastVisitCreateManyInput = {
    id?: string
    adminId: string
    resource: string
    lastVisitedAt?: Date | string
  }

  export type AdminLastVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    lastVisitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLastVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    lastVisitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedRouteCreateInput = {
    id?: string
    name: string
    icon?: string | null
    polyline?: string | null
    originAddress: string
    originLat: number
    originLng: number
    originCity?: string | null
    originSuburb?: string | null
    destinationAddress: string
    destinationLat: number
    destinationLng: number
    destinationCity?: string | null
    destinationSuburb?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavedRoutesInput
  }

  export type SavedRouteUncheckedCreateInput = {
    id?: string
    name: string
    icon?: string | null
    polyline?: string | null
    originAddress: string
    originLat: number
    originLng: number
    originCity?: string | null
    originSuburb?: string | null
    destinationAddress: string
    destinationLat: number
    destinationLng: number
    destinationCity?: string | null
    destinationSuburb?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SavedRouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    originCity?: NullableStringFieldUpdateOperationsInput | string | null
    originSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    destinationAddress?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    destinationCity?: NullableStringFieldUpdateOperationsInput | string | null
    destinationSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedRoutesNestedInput
  }

  export type SavedRouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    originCity?: NullableStringFieldUpdateOperationsInput | string | null
    originSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    destinationAddress?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    destinationCity?: NullableStringFieldUpdateOperationsInput | string | null
    destinationSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedRouteCreateManyInput = {
    id?: string
    name: string
    icon?: string | null
    polyline?: string | null
    originAddress: string
    originLat: number
    originLng: number
    originCity?: string | null
    originSuburb?: string | null
    destinationAddress: string
    destinationLat: number
    destinationLng: number
    destinationCity?: string | null
    destinationSuburb?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type SavedRouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    originCity?: NullableStringFieldUpdateOperationsInput | string | null
    originSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    destinationAddress?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    destinationCity?: NullableStringFieldUpdateOperationsInput | string | null
    destinationSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedRouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    originCity?: NullableStringFieldUpdateOperationsInput | string | null
    originSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    destinationAddress?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    destinationCity?: NullableStringFieldUpdateOperationsInput | string | null
    destinationSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRideCreateInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
    driver: UserCreateNestedOneWithoutScheduledRidesInput
    createdRides?: RideCreateNestedManyWithoutScheduledRideInput
  }

  export type ScheduledRideUncheckedCreateInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    driverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
    createdRides?: RideUncheckedCreateNestedManyWithoutScheduledRideInput
  }

  export type ScheduledRideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    driver?: UserUpdateOneRequiredWithoutScheduledRidesNestedInput
    createdRides?: RideUpdateManyWithoutScheduledRideNestedInput
  }

  export type ScheduledRideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    driverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdRides?: RideUncheckedUpdateManyWithoutScheduledRideNestedInput
  }

  export type ScheduledRideCreateManyInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    driverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
  }

  export type ScheduledRideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduledRideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    driverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    parent?: RideCommentCreateNestedOneWithoutRepliesInput
    replies?: RideCommentCreateNestedManyWithoutParentInput
    ride: RideCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type RideCommentUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    rideId: string
    userId: string
    parentId?: string | null
    replies?: RideCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type RideCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RideCommentUpdateOneWithoutRepliesNestedInput
    replies?: RideCommentUpdateManyWithoutParentNestedInput
    ride?: RideUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type RideCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: RideCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RideCommentCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    rideId: string
    userId: string
    parentId?: string | null
  }

  export type RideCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupBookingInvitationCreateInput = {
    id?: string
    seats: number
    expiresAt: Date | string
    status?: string
    bookings?: BookingCreateNestedManyWithoutInvitationInput
    ride: RideCreateNestedOneWithoutGroupInvitationsInput
    initiator: UserCreateNestedOneWithoutInitiatedInvitationsInput
  }

  export type GroupBookingInvitationUncheckedCreateInput = {
    id?: string
    rideId: string
    initiatorId: string
    seats: number
    expiresAt: Date | string
    status?: string
    bookings?: BookingUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type GroupBookingInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUpdateManyWithoutInvitationNestedInput
    ride?: RideUpdateOneRequiredWithoutGroupInvitationsNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedInvitationsNestedInput
  }

  export type GroupBookingInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type GroupBookingInvitationCreateManyInput = {
    id?: string
    rideId: string
    initiatorId: string
    seats: number
    expiresAt: Date | string
    status?: string
  }

  export type GroupBookingInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type GroupBookingInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type spatial_ref_sysCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUncheckedCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysCreateManyInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateManyMutationInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateManyInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type AdminLastVisitListRelationFilter = {
    every?: AdminLastVisitWhereInput
    some?: AdminLastVisitWhereInput
    none?: AdminLastVisitWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type GroupBookingInvitationListRelationFilter = {
    every?: GroupBookingInvitationWhereInput
    some?: GroupBookingInvitationWhereInput
    none?: GroupBookingInvitationWhereInput
  }

  export type CarNullableRelationFilter = {
    is?: CarWhereInput | null
    isNot?: CarWhereInput | null
  }

  export type ChatMemberListRelationFilter = {
    every?: ChatMemberWhereInput
    some?: ChatMemberWhereInput
    none?: ChatMemberWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type OfferListRelationFilter = {
    every?: OfferWhereInput
    some?: OfferWhereInput
    none?: OfferWhereInput
  }

  export type PromoCodeListRelationFilter = {
    every?: PromoCodeWhereInput
    some?: PromoCodeWhereInput
    none?: PromoCodeWhereInput
  }

  export type ReferralNullableRelationFilter = {
    is?: ReferralWhereInput | null
    isNot?: ReferralWhereInput | null
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type RideListRelationFilter = {
    every?: RideWhereInput
    some?: RideWhereInput
    none?: RideWhereInput
  }

  export type RideCommentListRelationFilter = {
    every?: RideCommentWhereInput
    some?: RideCommentWhereInput
    none?: RideCommentWhereInput
  }

  export type RideInterestListRelationFilter = {
    every?: RideInterestWhereInput
    some?: RideInterestWhereInput
    none?: RideInterestWhereInput
  }

  export type SavedRouteListRelationFilter = {
    every?: SavedRouteWhereInput
    some?: SavedRouteWhereInput
    none?: SavedRouteWhereInput
  }

  export type ScheduledRideListRelationFilter = {
    every?: ScheduledRideWhereInput
    some?: ScheduledRideWhereInput
    none?: ScheduledRideWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type UserStatsNullableRelationFilter = {
    is?: UserStatsWhereInput | null
    isNot?: UserStatsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminLastVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupBookingInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RideCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RideInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledRideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    gender?: SortOrder
    isVerified?: SortOrder
    password?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    birthDate?: SortOrder
    city?: SortOrder
    completedRides?: SortOrder
    genderPreference?: SortOrder
    rideSearchWindowDays?: SortOrder
    isPremium?: SortOrder
    joinDate?: SortOrder
    profileImage?: SortOrder
    rating?: SortOrder
    currentLat?: SortOrder
    currentLng?: SortOrder
    drivingLicenseUrl?: SortOrder
    idBackImageUrl?: SortOrder
    idFrontImageUrl?: SortOrder
    autoRenew?: SortOrder
    darkMode?: SortOrder
    hasSeenOnboarding?: SortOrder
    idVerificationStatus?: SortOrder
    nextFreeRideAt?: SortOrder
    passwordResetExpires?: SortOrder
    passwordResetToken?: SortOrder
    preferredLanguage?: SortOrder
    premiumEndDate?: SortOrder
    premiumStartDate?: SortOrder
    referralCode?: SortOrder
    profileImageLocked?: SortOrder
    role?: SortOrder
    emailVerificationExpires?: SortOrder
    emailVerificationToken?: SortOrder
    isEmailVerified?: SortOrder
    hasUsedFreeTrial?: SortOrder
    isEligibleForReward?: SortOrder
    referralsCount?: SortOrder
    driverLicenseExpiryDate?: SortOrder
    homeAddress?: SortOrder
    homeLat?: SortOrder
    homeLng?: SortOrder
    workAddress?: SortOrder
    workLat?: SortOrder
    workLng?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    completedRides?: SortOrder
    rideSearchWindowDays?: SortOrder
    rating?: SortOrder
    currentLat?: SortOrder
    currentLng?: SortOrder
    referralsCount?: SortOrder
    homeLat?: SortOrder
    homeLng?: SortOrder
    workLat?: SortOrder
    workLng?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    gender?: SortOrder
    isVerified?: SortOrder
    password?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    birthDate?: SortOrder
    city?: SortOrder
    completedRides?: SortOrder
    genderPreference?: SortOrder
    rideSearchWindowDays?: SortOrder
    isPremium?: SortOrder
    joinDate?: SortOrder
    profileImage?: SortOrder
    rating?: SortOrder
    currentLat?: SortOrder
    currentLng?: SortOrder
    drivingLicenseUrl?: SortOrder
    idBackImageUrl?: SortOrder
    idFrontImageUrl?: SortOrder
    autoRenew?: SortOrder
    darkMode?: SortOrder
    hasSeenOnboarding?: SortOrder
    idVerificationStatus?: SortOrder
    nextFreeRideAt?: SortOrder
    passwordResetExpires?: SortOrder
    passwordResetToken?: SortOrder
    preferredLanguage?: SortOrder
    premiumEndDate?: SortOrder
    premiumStartDate?: SortOrder
    referralCode?: SortOrder
    profileImageLocked?: SortOrder
    role?: SortOrder
    emailVerificationExpires?: SortOrder
    emailVerificationToken?: SortOrder
    isEmailVerified?: SortOrder
    hasUsedFreeTrial?: SortOrder
    isEligibleForReward?: SortOrder
    referralsCount?: SortOrder
    driverLicenseExpiryDate?: SortOrder
    homeAddress?: SortOrder
    homeLat?: SortOrder
    homeLng?: SortOrder
    workAddress?: SortOrder
    workLat?: SortOrder
    workLng?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    gender?: SortOrder
    isVerified?: SortOrder
    password?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    birthDate?: SortOrder
    city?: SortOrder
    completedRides?: SortOrder
    genderPreference?: SortOrder
    rideSearchWindowDays?: SortOrder
    isPremium?: SortOrder
    joinDate?: SortOrder
    profileImage?: SortOrder
    rating?: SortOrder
    currentLat?: SortOrder
    currentLng?: SortOrder
    drivingLicenseUrl?: SortOrder
    idBackImageUrl?: SortOrder
    idFrontImageUrl?: SortOrder
    autoRenew?: SortOrder
    darkMode?: SortOrder
    hasSeenOnboarding?: SortOrder
    idVerificationStatus?: SortOrder
    nextFreeRideAt?: SortOrder
    passwordResetExpires?: SortOrder
    passwordResetToken?: SortOrder
    preferredLanguage?: SortOrder
    premiumEndDate?: SortOrder
    premiumStartDate?: SortOrder
    referralCode?: SortOrder
    profileImageLocked?: SortOrder
    role?: SortOrder
    emailVerificationExpires?: SortOrder
    emailVerificationToken?: SortOrder
    isEmailVerified?: SortOrder
    hasUsedFreeTrial?: SortOrder
    isEligibleForReward?: SortOrder
    referralsCount?: SortOrder
    driverLicenseExpiryDate?: SortOrder
    homeAddress?: SortOrder
    homeLat?: SortOrder
    homeLng?: SortOrder
    workAddress?: SortOrder
    workLat?: SortOrder
    workLng?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    completedRides?: SortOrder
    rideSearchWindowDays?: SortOrder
    rating?: SortOrder
    currentLat?: SortOrder
    currentLng?: SortOrder
    referralsCount?: SortOrder
    homeLat?: SortOrder
    homeLng?: SortOrder
    workLat?: SortOrder
    workLng?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CarLicenseHistoryListRelationFilter = {
    every?: CarLicenseHistoryWhereInput
    some?: CarLicenseHistoryWhereInput
    none?: CarLicenseHistoryWhereInput
  }

  export type CarLicenseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CarCountOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    plate?: SortOrder
    licensePhoto?: SortOrder
    isVerified?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    verificationStatus?: SortOrder
    licenseExpiryDate?: SortOrder
  }

  export type CarAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type CarMaxOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    plate?: SortOrder
    licensePhoto?: SortOrder
    isVerified?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    verificationStatus?: SortOrder
    licenseExpiryDate?: SortOrder
  }

  export type CarMinOrderByAggregateInput = {
    id?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    plate?: SortOrder
    licensePhoto?: SortOrder
    isVerified?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    verificationStatus?: SortOrder
    licenseExpiryDate?: SortOrder
  }

  export type CarSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type CarRelationFilter = {
    is?: CarWhereInput
    isNot?: CarWhereInput
  }

  export type CarLicenseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    carId?: SortOrder
  }

  export type CarLicenseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    carId?: SortOrder
  }

  export type CarLicenseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    photoUrl?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    carId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumRideStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusFilter<$PrismaModel> | $Enums.RideStatus
  }

  export type ChatNullableRelationFilter = {
    is?: ChatWhereInput | null
    isNot?: ChatWhereInput | null
  }

  export type ScheduledRideNullableRelationFilter = {
    is?: ScheduledRideWhereInput | null
    isNot?: ScheduledRideWhereInput | null
  }

  export type RideCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    carInfo?: SortOrder
    serviceType?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    receiptPrice?: SortOrder
    renterScreenshotUrl?: SortOrder
    additionalInfo?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    arrivedAt?: SortOrder
    time?: SortOrder
    isTimeArranged?: SortOrder
    etaMinutes?: SortOrder
    destination?: SortOrder
    origin?: SortOrder
    fromCity?: SortOrder
    fromSuburb?: SortOrder
    toCity?: SortOrder
    toSuburb?: SortOrder
    fromCityNorm?: SortOrder
    fromSuburbNorm?: SortOrder
    toCityNorm?: SortOrder
    toSuburbNorm?: SortOrder
    rideType?: SortOrder
    isRequest?: SortOrder
    isVerified?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    allowedGender?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    polyline?: SortOrder
    scheduledRideId?: SortOrder
  }

  export type RideAvgOrderByAggregateInput = {
    seats?: SortOrder
    price?: SortOrder
    receiptPrice?: SortOrder
    etaMinutes?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
  }

  export type RideMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    carInfo?: SortOrder
    serviceType?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    receiptPrice?: SortOrder
    renterScreenshotUrl?: SortOrder
    additionalInfo?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    arrivedAt?: SortOrder
    time?: SortOrder
    isTimeArranged?: SortOrder
    etaMinutes?: SortOrder
    destination?: SortOrder
    origin?: SortOrder
    fromCity?: SortOrder
    fromSuburb?: SortOrder
    toCity?: SortOrder
    toSuburb?: SortOrder
    fromCityNorm?: SortOrder
    fromSuburbNorm?: SortOrder
    toCityNorm?: SortOrder
    toSuburbNorm?: SortOrder
    rideType?: SortOrder
    isRequest?: SortOrder
    isVerified?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    allowedGender?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    polyline?: SortOrder
    scheduledRideId?: SortOrder
  }

  export type RideMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    carId?: SortOrder
    carInfo?: SortOrder
    serviceType?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    receiptPrice?: SortOrder
    renterScreenshotUrl?: SortOrder
    additionalInfo?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    arrivedAt?: SortOrder
    time?: SortOrder
    isTimeArranged?: SortOrder
    etaMinutes?: SortOrder
    destination?: SortOrder
    origin?: SortOrder
    fromCity?: SortOrder
    fromSuburb?: SortOrder
    toCity?: SortOrder
    toSuburb?: SortOrder
    fromCityNorm?: SortOrder
    fromSuburbNorm?: SortOrder
    toCityNorm?: SortOrder
    toSuburbNorm?: SortOrder
    rideType?: SortOrder
    isRequest?: SortOrder
    isVerified?: SortOrder
    isAnonymous?: SortOrder
    status?: SortOrder
    allowedGender?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    polyline?: SortOrder
    scheduledRideId?: SortOrder
  }

  export type RideSumOrderByAggregateInput = {
    seats?: SortOrder
    price?: SortOrder
    receiptPrice?: SortOrder
    etaMinutes?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumRideStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusWithAggregatesFilter<$PrismaModel> | $Enums.RideStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRideStatusFilter<$PrismaModel>
    _max?: NestedEnumRideStatusFilter<$PrismaModel>
  }

  export type RideRelationFilter = {
    is?: RideWhereInput
    isNot?: RideWhereInput
  }

  export type RideInterestRideIdUserIdCompoundUniqueInput = {
    rideId: string
    userId: string
  }

  export type RideInterestCountOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RideInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RideInterestMinOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type GroupBookingInvitationNullableRelationFilter = {
    is?: GroupBookingInvitationWhereInput | null
    isNot?: GroupBookingInvitationWhereInput | null
  }

  export type ChatMemberNullableRelationFilter = {
    is?: ChatMemberWhereInput | null
    isNot?: ChatMemberWhereInput | null
  }

  export type BookingRideIdUserIdCompoundUniqueInput = {
    rideId: string
    userId: string
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    invitationId?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    invitationId?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
    invitationId?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    status?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type RideNullableRelationFilter = {
    is?: RideWhereInput | null
    isNot?: RideWhereInput | null
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingNullableRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type ChatRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatMemberCountOrderByAggregateInput = {
    id?: SortOrder
    hasStarted?: SortOrder
    hasEnded?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    hasStarted?: SortOrder
    hasEnded?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMemberMinOrderByAggregateInput = {
    id?: SortOrder
    hasStarted?: SortOrder
    hasEnded?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    chatId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    relatedId?: SortOrder
    createdAt?: SortOrder
    bookingStatus?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    relatedId?: SortOrder
    createdAt?: SortOrder
    bookingStatus?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    relatedId?: SortOrder
    createdAt?: SortOrder
    bookingStatus?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FeedbackRideIdGivenByIdCompoundUniqueInput = {
    rideId: string
    givenById: string
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    rideId?: SortOrder
    givenById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    arrivalOnTime?: SortOrder
    startOnTime?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    rideId?: SortOrder
    givenById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    arrivalOnTime?: SortOrder
    startOnTime?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    rideId?: SortOrder
    givenById?: SortOrder
    receivedById?: SortOrder
    createdAt?: SortOrder
    arrivalOnTime?: SortOrder
    startOnTime?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    threshold?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    threshold?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    threshold?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type BadgeRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    earnedAt?: SortOrder
    lostAt?: SortOrder
    progress?: SortOrder
  }

  export type UserBadgeAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    earnedAt?: SortOrder
    lostAt?: SortOrder
    progress?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    earnedAt?: SortOrder
    lostAt?: SortOrder
    progress?: SortOrder
  }

  export type UserBadgeSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type ReferralReferrerIdRefereeIdCompoundUniqueInput = {
    referrerId: string
    refereeId: string
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    bonusGiven?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    bonusGiven?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    referrerId?: SortOrder
    refereeId?: SortOrder
    bonusGiven?: SortOrder
    createdAt?: SortOrder
  }

  export type AppConfigCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type AppConfigMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type AppConfigMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
  }

  export type UserStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onTimeStarts?: SortOrder
    onTimeArrivals?: SortOrder
    totalChatMessages?: SortOrder
    fastResponses?: SortOrder
    totalBookingsToAccept?: SortOrder
    acceptedBookings?: SortOrder
    totalCancellations?: SortOrder
    totalRidesAsDriver?: SortOrder
    totalRidesAsPassenger?: SortOrder
    completedFreeRidesAsDriver?: SortOrder
    fastResponseOpportunities?: SortOrder
    fastResponseSuccesses?: SortOrder
  }

  export type UserStatsAvgOrderByAggregateInput = {
    onTimeStarts?: SortOrder
    onTimeArrivals?: SortOrder
    totalChatMessages?: SortOrder
    fastResponses?: SortOrder
    totalBookingsToAccept?: SortOrder
    acceptedBookings?: SortOrder
    totalCancellations?: SortOrder
    totalRidesAsDriver?: SortOrder
    totalRidesAsPassenger?: SortOrder
    completedFreeRidesAsDriver?: SortOrder
    fastResponseOpportunities?: SortOrder
    fastResponseSuccesses?: SortOrder
  }

  export type UserStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onTimeStarts?: SortOrder
    onTimeArrivals?: SortOrder
    totalChatMessages?: SortOrder
    fastResponses?: SortOrder
    totalBookingsToAccept?: SortOrder
    acceptedBookings?: SortOrder
    totalCancellations?: SortOrder
    totalRidesAsDriver?: SortOrder
    totalRidesAsPassenger?: SortOrder
    completedFreeRidesAsDriver?: SortOrder
    fastResponseOpportunities?: SortOrder
    fastResponseSuccesses?: SortOrder
  }

  export type UserStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    onTimeStarts?: SortOrder
    onTimeArrivals?: SortOrder
    totalChatMessages?: SortOrder
    fastResponses?: SortOrder
    totalBookingsToAccept?: SortOrder
    acceptedBookings?: SortOrder
    totalCancellations?: SortOrder
    totalRidesAsDriver?: SortOrder
    totalRidesAsPassenger?: SortOrder
    completedFreeRidesAsDriver?: SortOrder
    fastResponseOpportunities?: SortOrder
    fastResponseSuccesses?: SortOrder
  }

  export type UserStatsSumOrderByAggregateInput = {
    onTimeStarts?: SortOrder
    onTimeArrivals?: SortOrder
    totalChatMessages?: SortOrder
    fastResponses?: SortOrder
    totalBookingsToAccept?: SortOrder
    acceptedBookings?: SortOrder
    totalCancellations?: SortOrder
    totalRidesAsDriver?: SortOrder
    totalRidesAsPassenger?: SortOrder
    completedFreeRidesAsDriver?: SortOrder
    fastResponseOpportunities?: SortOrder
    fastResponseSuccesses?: SortOrder
  }

  export type PromoCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PromoCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PromoCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    rideId?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    rideId?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    comment?: SortOrder
    status?: SortOrder
    rideId?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type AdminLastVisitAdminIdResourceCompoundUniqueInput = {
    adminId: string
    resource: string
  }

  export type AdminLastVisitCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    resource?: SortOrder
    lastVisitedAt?: SortOrder
  }

  export type AdminLastVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    resource?: SortOrder
    lastVisitedAt?: SortOrder
  }

  export type AdminLastVisitMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    resource?: SortOrder
    lastVisitedAt?: SortOrder
  }

  export type SavedRouteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    polyline?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    originCity?: SortOrder
    originSuburb?: SortOrder
    destinationAddress?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    destinationCity?: SortOrder
    destinationSuburb?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedRouteAvgOrderByAggregateInput = {
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
  }

  export type SavedRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    polyline?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    originCity?: SortOrder
    originSuburb?: SortOrder
    destinationAddress?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    destinationCity?: SortOrder
    destinationSuburb?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedRouteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    polyline?: SortOrder
    originAddress?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    originCity?: SortOrder
    originSuburb?: SortOrder
    destinationAddress?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    destinationCity?: SortOrder
    destinationSuburb?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedRouteSumOrderByAggregateInput = {
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ScheduledRideCountOrderByAggregateInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    fromCity?: SortOrder
    toCity?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    scheduleTime?: SortOrder
    daysOfWeek?: SortOrder
    isActive?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromSuburb?: SortOrder
    toSuburb?: SortOrder
  }

  export type ScheduledRideAvgOrderByAggregateInput = {
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    daysOfWeek?: SortOrder
  }

  export type ScheduledRideMaxOrderByAggregateInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    fromCity?: SortOrder
    toCity?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    scheduleTime?: SortOrder
    isActive?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromSuburb?: SortOrder
    toSuburb?: SortOrder
  }

  export type ScheduledRideMinOrderByAggregateInput = {
    id?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    fromCity?: SortOrder
    toCity?: SortOrder
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    scheduleTime?: SortOrder
    isActive?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromSuburb?: SortOrder
    toSuburb?: SortOrder
  }

  export type ScheduledRideSumOrderByAggregateInput = {
    originLat?: SortOrder
    originLng?: SortOrder
    destinationLat?: SortOrder
    destinationLng?: SortOrder
    seats?: SortOrder
    price?: SortOrder
    daysOfWeek?: SortOrder
  }

  export type RideCommentNullableRelationFilter = {
    is?: RideCommentWhereInput | null
    isNot?: RideCommentWhereInput | null
  }

  export type RideCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type RideCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type RideCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    rideId?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type GroupBookingInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    initiatorId?: SortOrder
    seats?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
  }

  export type GroupBookingInvitationAvgOrderByAggregateInput = {
    seats?: SortOrder
  }

  export type GroupBookingInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    initiatorId?: SortOrder
    seats?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
  }

  export type GroupBookingInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    rideId?: SortOrder
    initiatorId?: SortOrder
    seats?: SortOrder
    expiresAt?: SortOrder
    status?: SortOrder
  }

  export type GroupBookingInvitationSumOrderByAggregateInput = {
    seats?: SortOrder
  }

  export type spatial_ref_sysCountOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysAvgOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type spatial_ref_sysMaxOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysMinOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysSumOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type AdminLastVisitCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminLastVisitCreateWithoutAdminInput, AdminLastVisitUncheckedCreateWithoutAdminInput> | AdminLastVisitCreateWithoutAdminInput[] | AdminLastVisitUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLastVisitCreateOrConnectWithoutAdminInput | AdminLastVisitCreateOrConnectWithoutAdminInput[]
    createMany?: AdminLastVisitCreateManyAdminInputEnvelope
    connect?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type GroupBookingInvitationCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutInitiatorInput, GroupBookingInvitationUncheckedCreateWithoutInitiatorInput> | GroupBookingInvitationCreateWithoutInitiatorInput[] | GroupBookingInvitationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutInitiatorInput | GroupBookingInvitationCreateOrConnectWithoutInitiatorInput[]
    createMany?: GroupBookingInvitationCreateManyInitiatorInputEnvelope
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
  }

  export type CarCreateNestedOneWithoutUserInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarCreateOrConnectWithoutUserInput
    connect?: CarWhereUniqueInput
  }

  export type ChatMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutGivenByInput = {
    create?: XOR<FeedbackCreateWithoutGivenByInput, FeedbackUncheckedCreateWithoutGivenByInput> | FeedbackCreateWithoutGivenByInput[] | FeedbackUncheckedCreateWithoutGivenByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutGivenByInput | FeedbackCreateOrConnectWithoutGivenByInput[]
    createMany?: FeedbackCreateManyGivenByInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<FeedbackCreateWithoutReceivedByInput, FeedbackUncheckedCreateWithoutReceivedByInput> | FeedbackCreateWithoutReceivedByInput[] | FeedbackUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutReceivedByInput | FeedbackCreateOrConnectWithoutReceivedByInput[]
    createMany?: FeedbackCreateManyReceivedByInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutUserInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type PromoCodeCreateNestedManyWithoutUserInput = {
    create?: XOR<PromoCodeCreateWithoutUserInput, PromoCodeUncheckedCreateWithoutUserInput> | PromoCodeCreateWithoutUserInput[] | PromoCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUserInput | PromoCodeCreateOrConnectWithoutUserInput[]
    createMany?: PromoCodeCreateManyUserInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type ReferralCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    connect?: ReferralWhereUniqueInput
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type RideCreateNestedManyWithoutDriverInput = {
    create?: XOR<RideCreateWithoutDriverInput, RideUncheckedCreateWithoutDriverInput> | RideCreateWithoutDriverInput[] | RideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDriverInput | RideCreateOrConnectWithoutDriverInput[]
    createMany?: RideCreateManyDriverInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<RideCommentCreateWithoutUserInput, RideCommentUncheckedCreateWithoutUserInput> | RideCommentCreateWithoutUserInput[] | RideCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutUserInput | RideCommentCreateOrConnectWithoutUserInput[]
    createMany?: RideCommentCreateManyUserInputEnvelope
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
  }

  export type RideInterestCreateNestedManyWithoutUserInput = {
    create?: XOR<RideInterestCreateWithoutUserInput, RideInterestUncheckedCreateWithoutUserInput> | RideInterestCreateWithoutUserInput[] | RideInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutUserInput | RideInterestCreateOrConnectWithoutUserInput[]
    createMany?: RideInterestCreateManyUserInputEnvelope
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
  }

  export type SavedRouteCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedRouteCreateWithoutUserInput, SavedRouteUncheckedCreateWithoutUserInput> | SavedRouteCreateWithoutUserInput[] | SavedRouteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedRouteCreateOrConnectWithoutUserInput | SavedRouteCreateOrConnectWithoutUserInput[]
    createMany?: SavedRouteCreateManyUserInputEnvelope
    connect?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
  }

  export type ScheduledRideCreateNestedManyWithoutDriverInput = {
    create?: XOR<ScheduledRideCreateWithoutDriverInput, ScheduledRideUncheckedCreateWithoutDriverInput> | ScheduledRideCreateWithoutDriverInput[] | ScheduledRideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ScheduledRideCreateOrConnectWithoutDriverInput | ScheduledRideCreateOrConnectWithoutDriverInput[]
    createMany?: ScheduledRideCreateManyDriverInputEnvelope
    connect?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminLastVisitCreateWithoutAdminInput, AdminLastVisitUncheckedCreateWithoutAdminInput> | AdminLastVisitCreateWithoutAdminInput[] | AdminLastVisitUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLastVisitCreateOrConnectWithoutAdminInput | AdminLastVisitCreateOrConnectWithoutAdminInput[]
    createMany?: AdminLastVisitCreateManyAdminInputEnvelope
    connect?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutInitiatorInput, GroupBookingInvitationUncheckedCreateWithoutInitiatorInput> | GroupBookingInvitationCreateWithoutInitiatorInput[] | GroupBookingInvitationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutInitiatorInput | GroupBookingInvitationCreateOrConnectWithoutInitiatorInput[]
    createMany?: GroupBookingInvitationCreateManyInitiatorInputEnvelope
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
  }

  export type CarUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarCreateOrConnectWithoutUserInput
    connect?: CarWhereUniqueInput
  }

  export type ChatMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutGivenByInput = {
    create?: XOR<FeedbackCreateWithoutGivenByInput, FeedbackUncheckedCreateWithoutGivenByInput> | FeedbackCreateWithoutGivenByInput[] | FeedbackUncheckedCreateWithoutGivenByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutGivenByInput | FeedbackCreateOrConnectWithoutGivenByInput[]
    createMany?: FeedbackCreateManyGivenByInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutReceivedByInput = {
    create?: XOR<FeedbackCreateWithoutReceivedByInput, FeedbackUncheckedCreateWithoutReceivedByInput> | FeedbackCreateWithoutReceivedByInput[] | FeedbackUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutReceivedByInput | FeedbackCreateOrConnectWithoutReceivedByInput[]
    createMany?: FeedbackCreateManyReceivedByInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type PromoCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PromoCodeCreateWithoutUserInput, PromoCodeUncheckedCreateWithoutUserInput> | PromoCodeCreateWithoutUserInput[] | PromoCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUserInput | PromoCodeCreateOrConnectWithoutUserInput[]
    createMany?: PromoCodeCreateManyUserInputEnvelope
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedOneWithoutRefereeInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    connect?: ReferralWhereUniqueInput
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type RideUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<RideCreateWithoutDriverInput, RideUncheckedCreateWithoutDriverInput> | RideCreateWithoutDriverInput[] | RideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDriverInput | RideCreateOrConnectWithoutDriverInput[]
    createMany?: RideCreateManyDriverInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RideCommentCreateWithoutUserInput, RideCommentUncheckedCreateWithoutUserInput> | RideCommentCreateWithoutUserInput[] | RideCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutUserInput | RideCommentCreateOrConnectWithoutUserInput[]
    createMany?: RideCommentCreateManyUserInputEnvelope
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
  }

  export type RideInterestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RideInterestCreateWithoutUserInput, RideInterestUncheckedCreateWithoutUserInput> | RideInterestCreateWithoutUserInput[] | RideInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutUserInput | RideInterestCreateOrConnectWithoutUserInput[]
    createMany?: RideInterestCreateManyUserInputEnvelope
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
  }

  export type SavedRouteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedRouteCreateWithoutUserInput, SavedRouteUncheckedCreateWithoutUserInput> | SavedRouteCreateWithoutUserInput[] | SavedRouteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedRouteCreateOrConnectWithoutUserInput | SavedRouteCreateOrConnectWithoutUserInput[]
    createMany?: SavedRouteCreateManyUserInputEnvelope
    connect?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
  }

  export type ScheduledRideUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<ScheduledRideCreateWithoutDriverInput, ScheduledRideUncheckedCreateWithoutDriverInput> | ScheduledRideCreateWithoutDriverInput[] | ScheduledRideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ScheduledRideCreateOrConnectWithoutDriverInput | ScheduledRideCreateOrConnectWithoutDriverInput[]
    createMany?: ScheduledRideCreateManyDriverInputEnvelope
    connect?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    connect?: UserStatsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type AdminLastVisitUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminLastVisitCreateWithoutAdminInput, AdminLastVisitUncheckedCreateWithoutAdminInput> | AdminLastVisitCreateWithoutAdminInput[] | AdminLastVisitUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLastVisitCreateOrConnectWithoutAdminInput | AdminLastVisitCreateOrConnectWithoutAdminInput[]
    upsert?: AdminLastVisitUpsertWithWhereUniqueWithoutAdminInput | AdminLastVisitUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminLastVisitCreateManyAdminInputEnvelope
    set?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    disconnect?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    delete?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    connect?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    update?: AdminLastVisitUpdateWithWhereUniqueWithoutAdminInput | AdminLastVisitUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminLastVisitUpdateManyWithWhereWithoutAdminInput | AdminLastVisitUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminLastVisitScalarWhereInput | AdminLastVisitScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutInitiatorInput, GroupBookingInvitationUncheckedCreateWithoutInitiatorInput> | GroupBookingInvitationCreateWithoutInitiatorInput[] | GroupBookingInvitationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutInitiatorInput | GroupBookingInvitationCreateOrConnectWithoutInitiatorInput[]
    upsert?: GroupBookingInvitationUpsertWithWhereUniqueWithoutInitiatorInput | GroupBookingInvitationUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: GroupBookingInvitationCreateManyInitiatorInputEnvelope
    set?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    disconnect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    delete?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    update?: GroupBookingInvitationUpdateWithWhereUniqueWithoutInitiatorInput | GroupBookingInvitationUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: GroupBookingInvitationUpdateManyWithWhereWithoutInitiatorInput | GroupBookingInvitationUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: GroupBookingInvitationScalarWhereInput | GroupBookingInvitationScalarWhereInput[]
  }

  export type CarUpdateOneWithoutUserNestedInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarCreateOrConnectWithoutUserInput
    upsert?: CarUpsertWithoutUserInput
    disconnect?: CarWhereInput | boolean
    delete?: CarWhereInput | boolean
    connect?: CarWhereUniqueInput
    update?: XOR<XOR<CarUpdateToOneWithWhereWithoutUserInput, CarUpdateWithoutUserInput>, CarUncheckedUpdateWithoutUserInput>
  }

  export type ChatMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutUserInput | ChatMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutUserInput | ChatMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutUserInput | ChatMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutGivenByNestedInput = {
    create?: XOR<FeedbackCreateWithoutGivenByInput, FeedbackUncheckedCreateWithoutGivenByInput> | FeedbackCreateWithoutGivenByInput[] | FeedbackUncheckedCreateWithoutGivenByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutGivenByInput | FeedbackCreateOrConnectWithoutGivenByInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutGivenByInput | FeedbackUpsertWithWhereUniqueWithoutGivenByInput[]
    createMany?: FeedbackCreateManyGivenByInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutGivenByInput | FeedbackUpdateWithWhereUniqueWithoutGivenByInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutGivenByInput | FeedbackUpdateManyWithWhereWithoutGivenByInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<FeedbackCreateWithoutReceivedByInput, FeedbackUncheckedCreateWithoutReceivedByInput> | FeedbackCreateWithoutReceivedByInput[] | FeedbackUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutReceivedByInput | FeedbackCreateOrConnectWithoutReceivedByInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutReceivedByInput | FeedbackUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: FeedbackCreateManyReceivedByInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutReceivedByInput | FeedbackUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutReceivedByInput | FeedbackUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutUserNestedInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutUserInput | OfferUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutUserInput | OfferUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutUserInput | OfferUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type PromoCodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromoCodeCreateWithoutUserInput, PromoCodeUncheckedCreateWithoutUserInput> | PromoCodeCreateWithoutUserInput[] | PromoCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUserInput | PromoCodeCreateOrConnectWithoutUserInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutUserInput | PromoCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromoCodeCreateManyUserInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutUserInput | PromoCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutUserInput | PromoCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type ReferralUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    upsert?: ReferralUpsertWithoutRefereeInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutRefereeInput, ReferralUpdateWithoutRefereeInput>, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type RideUpdateManyWithoutDriverNestedInput = {
    create?: XOR<RideCreateWithoutDriverInput, RideUncheckedCreateWithoutDriverInput> | RideCreateWithoutDriverInput[] | RideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDriverInput | RideCreateOrConnectWithoutDriverInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutDriverInput | RideUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: RideCreateManyDriverInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutDriverInput | RideUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: RideUpdateManyWithWhereWithoutDriverInput | RideUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<RideCommentCreateWithoutUserInput, RideCommentUncheckedCreateWithoutUserInput> | RideCommentCreateWithoutUserInput[] | RideCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutUserInput | RideCommentCreateOrConnectWithoutUserInput[]
    upsert?: RideCommentUpsertWithWhereUniqueWithoutUserInput | RideCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RideCommentCreateManyUserInputEnvelope
    set?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    disconnect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    delete?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    update?: RideCommentUpdateWithWhereUniqueWithoutUserInput | RideCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RideCommentUpdateManyWithWhereWithoutUserInput | RideCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
  }

  export type RideInterestUpdateManyWithoutUserNestedInput = {
    create?: XOR<RideInterestCreateWithoutUserInput, RideInterestUncheckedCreateWithoutUserInput> | RideInterestCreateWithoutUserInput[] | RideInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutUserInput | RideInterestCreateOrConnectWithoutUserInput[]
    upsert?: RideInterestUpsertWithWhereUniqueWithoutUserInput | RideInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RideInterestCreateManyUserInputEnvelope
    set?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    disconnect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    delete?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    update?: RideInterestUpdateWithWhereUniqueWithoutUserInput | RideInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RideInterestUpdateManyWithWhereWithoutUserInput | RideInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RideInterestScalarWhereInput | RideInterestScalarWhereInput[]
  }

  export type SavedRouteUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedRouteCreateWithoutUserInput, SavedRouteUncheckedCreateWithoutUserInput> | SavedRouteCreateWithoutUserInput[] | SavedRouteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedRouteCreateOrConnectWithoutUserInput | SavedRouteCreateOrConnectWithoutUserInput[]
    upsert?: SavedRouteUpsertWithWhereUniqueWithoutUserInput | SavedRouteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedRouteCreateManyUserInputEnvelope
    set?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    disconnect?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    delete?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    connect?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    update?: SavedRouteUpdateWithWhereUniqueWithoutUserInput | SavedRouteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedRouteUpdateManyWithWhereWithoutUserInput | SavedRouteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedRouteScalarWhereInput | SavedRouteScalarWhereInput[]
  }

  export type ScheduledRideUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ScheduledRideCreateWithoutDriverInput, ScheduledRideUncheckedCreateWithoutDriverInput> | ScheduledRideCreateWithoutDriverInput[] | ScheduledRideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ScheduledRideCreateOrConnectWithoutDriverInput | ScheduledRideCreateOrConnectWithoutDriverInput[]
    upsert?: ScheduledRideUpsertWithWhereUniqueWithoutDriverInput | ScheduledRideUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ScheduledRideCreateManyDriverInputEnvelope
    set?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    disconnect?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    delete?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    connect?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    update?: ScheduledRideUpdateWithWhereUniqueWithoutDriverInput | ScheduledRideUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ScheduledRideUpdateManyWithWhereWithoutDriverInput | ScheduledRideUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ScheduledRideScalarWhereInput | ScheduledRideScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminLastVisitCreateWithoutAdminInput, AdminLastVisitUncheckedCreateWithoutAdminInput> | AdminLastVisitCreateWithoutAdminInput[] | AdminLastVisitUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminLastVisitCreateOrConnectWithoutAdminInput | AdminLastVisitCreateOrConnectWithoutAdminInput[]
    upsert?: AdminLastVisitUpsertWithWhereUniqueWithoutAdminInput | AdminLastVisitUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminLastVisitCreateManyAdminInputEnvelope
    set?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    disconnect?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    delete?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    connect?: AdminLastVisitWhereUniqueInput | AdminLastVisitWhereUniqueInput[]
    update?: AdminLastVisitUpdateWithWhereUniqueWithoutAdminInput | AdminLastVisitUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminLastVisitUpdateManyWithWhereWithoutAdminInput | AdminLastVisitUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminLastVisitScalarWhereInput | AdminLastVisitScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutInitiatorInput, GroupBookingInvitationUncheckedCreateWithoutInitiatorInput> | GroupBookingInvitationCreateWithoutInitiatorInput[] | GroupBookingInvitationUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutInitiatorInput | GroupBookingInvitationCreateOrConnectWithoutInitiatorInput[]
    upsert?: GroupBookingInvitationUpsertWithWhereUniqueWithoutInitiatorInput | GroupBookingInvitationUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: GroupBookingInvitationCreateManyInitiatorInputEnvelope
    set?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    disconnect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    delete?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    update?: GroupBookingInvitationUpdateWithWhereUniqueWithoutInitiatorInput | GroupBookingInvitationUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: GroupBookingInvitationUpdateManyWithWhereWithoutInitiatorInput | GroupBookingInvitationUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: GroupBookingInvitationScalarWhereInput | GroupBookingInvitationScalarWhereInput[]
  }

  export type CarUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
    connectOrCreate?: CarCreateOrConnectWithoutUserInput
    upsert?: CarUpsertWithoutUserInput
    disconnect?: CarWhereInput | boolean
    delete?: CarWhereInput | boolean
    connect?: CarWhereUniqueInput
    update?: XOR<XOR<CarUpdateToOneWithWhereWithoutUserInput, CarUpdateWithoutUserInput>, CarUncheckedUpdateWithoutUserInput>
  }

  export type ChatMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput> | ChatMemberCreateWithoutUserInput[] | ChatMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutUserInput | ChatMemberCreateOrConnectWithoutUserInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutUserInput | ChatMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMemberCreateManyUserInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutUserInput | ChatMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutUserInput | ChatMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutGivenByNestedInput = {
    create?: XOR<FeedbackCreateWithoutGivenByInput, FeedbackUncheckedCreateWithoutGivenByInput> | FeedbackCreateWithoutGivenByInput[] | FeedbackUncheckedCreateWithoutGivenByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutGivenByInput | FeedbackCreateOrConnectWithoutGivenByInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutGivenByInput | FeedbackUpsertWithWhereUniqueWithoutGivenByInput[]
    createMany?: FeedbackCreateManyGivenByInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutGivenByInput | FeedbackUpdateWithWhereUniqueWithoutGivenByInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutGivenByInput | FeedbackUpdateManyWithWhereWithoutGivenByInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput = {
    create?: XOR<FeedbackCreateWithoutReceivedByInput, FeedbackUncheckedCreateWithoutReceivedByInput> | FeedbackCreateWithoutReceivedByInput[] | FeedbackUncheckedCreateWithoutReceivedByInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutReceivedByInput | FeedbackCreateOrConnectWithoutReceivedByInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutReceivedByInput | FeedbackUpsertWithWhereUniqueWithoutReceivedByInput[]
    createMany?: FeedbackCreateManyReceivedByInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutReceivedByInput | FeedbackUpdateWithWhereUniqueWithoutReceivedByInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutReceivedByInput | FeedbackUpdateManyWithWhereWithoutReceivedByInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput> | OfferCreateWithoutUserInput[] | OfferUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutUserInput | OfferCreateOrConnectWithoutUserInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutUserInput | OfferUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OfferCreateManyUserInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutUserInput | OfferUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutUserInput | OfferUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type PromoCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PromoCodeCreateWithoutUserInput, PromoCodeUncheckedCreateWithoutUserInput> | PromoCodeCreateWithoutUserInput[] | PromoCodeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PromoCodeCreateOrConnectWithoutUserInput | PromoCodeCreateOrConnectWithoutUserInput[]
    upsert?: PromoCodeUpsertWithWhereUniqueWithoutUserInput | PromoCodeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PromoCodeCreateManyUserInputEnvelope
    set?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    disconnect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    delete?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    connect?: PromoCodeWhereUniqueInput | PromoCodeWhereUniqueInput[]
    update?: PromoCodeUpdateWithWhereUniqueWithoutUserInput | PromoCodeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PromoCodeUpdateManyWithWhereWithoutUserInput | PromoCodeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateOneWithoutRefereeNestedInput = {
    create?: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutRefereeInput
    upsert?: ReferralUpsertWithoutRefereeInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutRefereeInput, ReferralUpdateWithoutRefereeInput>, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type RideUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<RideCreateWithoutDriverInput, RideUncheckedCreateWithoutDriverInput> | RideCreateWithoutDriverInput[] | RideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDriverInput | RideCreateOrConnectWithoutDriverInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutDriverInput | RideUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: RideCreateManyDriverInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutDriverInput | RideUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: RideUpdateManyWithWhereWithoutDriverInput | RideUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RideCommentCreateWithoutUserInput, RideCommentUncheckedCreateWithoutUserInput> | RideCommentCreateWithoutUserInput[] | RideCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutUserInput | RideCommentCreateOrConnectWithoutUserInput[]
    upsert?: RideCommentUpsertWithWhereUniqueWithoutUserInput | RideCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RideCommentCreateManyUserInputEnvelope
    set?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    disconnect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    delete?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    update?: RideCommentUpdateWithWhereUniqueWithoutUserInput | RideCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RideCommentUpdateManyWithWhereWithoutUserInput | RideCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
  }

  export type RideInterestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RideInterestCreateWithoutUserInput, RideInterestUncheckedCreateWithoutUserInput> | RideInterestCreateWithoutUserInput[] | RideInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutUserInput | RideInterestCreateOrConnectWithoutUserInput[]
    upsert?: RideInterestUpsertWithWhereUniqueWithoutUserInput | RideInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RideInterestCreateManyUserInputEnvelope
    set?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    disconnect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    delete?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    update?: RideInterestUpdateWithWhereUniqueWithoutUserInput | RideInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RideInterestUpdateManyWithWhereWithoutUserInput | RideInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RideInterestScalarWhereInput | RideInterestScalarWhereInput[]
  }

  export type SavedRouteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedRouteCreateWithoutUserInput, SavedRouteUncheckedCreateWithoutUserInput> | SavedRouteCreateWithoutUserInput[] | SavedRouteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedRouteCreateOrConnectWithoutUserInput | SavedRouteCreateOrConnectWithoutUserInput[]
    upsert?: SavedRouteUpsertWithWhereUniqueWithoutUserInput | SavedRouteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedRouteCreateManyUserInputEnvelope
    set?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    disconnect?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    delete?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    connect?: SavedRouteWhereUniqueInput | SavedRouteWhereUniqueInput[]
    update?: SavedRouteUpdateWithWhereUniqueWithoutUserInput | SavedRouteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedRouteUpdateManyWithWhereWithoutUserInput | SavedRouteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedRouteScalarWhereInput | SavedRouteScalarWhereInput[]
  }

  export type ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<ScheduledRideCreateWithoutDriverInput, ScheduledRideUncheckedCreateWithoutDriverInput> | ScheduledRideCreateWithoutDriverInput[] | ScheduledRideUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: ScheduledRideCreateOrConnectWithoutDriverInput | ScheduledRideCreateOrConnectWithoutDriverInput[]
    upsert?: ScheduledRideUpsertWithWhereUniqueWithoutDriverInput | ScheduledRideUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: ScheduledRideCreateManyDriverInputEnvelope
    set?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    disconnect?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    delete?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    connect?: ScheduledRideWhereUniqueInput | ScheduledRideWhereUniqueInput[]
    update?: ScheduledRideUpdateWithWhereUniqueWithoutDriverInput | ScheduledRideUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: ScheduledRideUpdateManyWithWhereWithoutDriverInput | ScheduledRideUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: ScheduledRideScalarWhereInput | ScheduledRideScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserStatsCreateOrConnectWithoutUserInput
    upsert?: UserStatsUpsertWithoutUserInput
    disconnect?: UserStatsWhereInput | boolean
    delete?: UserStatsWhereInput | boolean
    connect?: UserStatsWhereUniqueInput
    update?: XOR<XOR<UserStatsUpdateToOneWithWhereWithoutUserInput, UserStatsUpdateWithoutUserInput>, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutCarInput = {
    create?: XOR<UserCreateWithoutCarInput, UserUncheckedCreateWithoutCarInput>
    connectOrCreate?: UserCreateOrConnectWithoutCarInput
    connect?: UserWhereUniqueInput
  }

  export type CarLicenseHistoryCreateNestedManyWithoutCarInput = {
    create?: XOR<CarLicenseHistoryCreateWithoutCarInput, CarLicenseHistoryUncheckedCreateWithoutCarInput> | CarLicenseHistoryCreateWithoutCarInput[] | CarLicenseHistoryUncheckedCreateWithoutCarInput[]
    connectOrCreate?: CarLicenseHistoryCreateOrConnectWithoutCarInput | CarLicenseHistoryCreateOrConnectWithoutCarInput[]
    createMany?: CarLicenseHistoryCreateManyCarInputEnvelope
    connect?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
  }

  export type RideCreateNestedManyWithoutCarInput = {
    create?: XOR<RideCreateWithoutCarInput, RideUncheckedCreateWithoutCarInput> | RideCreateWithoutCarInput[] | RideUncheckedCreateWithoutCarInput[]
    connectOrCreate?: RideCreateOrConnectWithoutCarInput | RideCreateOrConnectWithoutCarInput[]
    createMany?: RideCreateManyCarInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type CarLicenseHistoryUncheckedCreateNestedManyWithoutCarInput = {
    create?: XOR<CarLicenseHistoryCreateWithoutCarInput, CarLicenseHistoryUncheckedCreateWithoutCarInput> | CarLicenseHistoryCreateWithoutCarInput[] | CarLicenseHistoryUncheckedCreateWithoutCarInput[]
    connectOrCreate?: CarLicenseHistoryCreateOrConnectWithoutCarInput | CarLicenseHistoryCreateOrConnectWithoutCarInput[]
    createMany?: CarLicenseHistoryCreateManyCarInputEnvelope
    connect?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
  }

  export type RideUncheckedCreateNestedManyWithoutCarInput = {
    create?: XOR<RideCreateWithoutCarInput, RideUncheckedCreateWithoutCarInput> | RideCreateWithoutCarInput[] | RideUncheckedCreateWithoutCarInput[]
    connectOrCreate?: RideCreateOrConnectWithoutCarInput | RideCreateOrConnectWithoutCarInput[]
    createMany?: RideCreateManyCarInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCarNestedInput = {
    create?: XOR<UserCreateWithoutCarInput, UserUncheckedCreateWithoutCarInput>
    connectOrCreate?: UserCreateOrConnectWithoutCarInput
    upsert?: UserUpsertWithoutCarInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCarInput, UserUpdateWithoutCarInput>, UserUncheckedUpdateWithoutCarInput>
  }

  export type CarLicenseHistoryUpdateManyWithoutCarNestedInput = {
    create?: XOR<CarLicenseHistoryCreateWithoutCarInput, CarLicenseHistoryUncheckedCreateWithoutCarInput> | CarLicenseHistoryCreateWithoutCarInput[] | CarLicenseHistoryUncheckedCreateWithoutCarInput[]
    connectOrCreate?: CarLicenseHistoryCreateOrConnectWithoutCarInput | CarLicenseHistoryCreateOrConnectWithoutCarInput[]
    upsert?: CarLicenseHistoryUpsertWithWhereUniqueWithoutCarInput | CarLicenseHistoryUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: CarLicenseHistoryCreateManyCarInputEnvelope
    set?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    disconnect?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    delete?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    connect?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    update?: CarLicenseHistoryUpdateWithWhereUniqueWithoutCarInput | CarLicenseHistoryUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: CarLicenseHistoryUpdateManyWithWhereWithoutCarInput | CarLicenseHistoryUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: CarLicenseHistoryScalarWhereInput | CarLicenseHistoryScalarWhereInput[]
  }

  export type RideUpdateManyWithoutCarNestedInput = {
    create?: XOR<RideCreateWithoutCarInput, RideUncheckedCreateWithoutCarInput> | RideCreateWithoutCarInput[] | RideUncheckedCreateWithoutCarInput[]
    connectOrCreate?: RideCreateOrConnectWithoutCarInput | RideCreateOrConnectWithoutCarInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutCarInput | RideUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: RideCreateManyCarInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutCarInput | RideUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: RideUpdateManyWithWhereWithoutCarInput | RideUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type CarLicenseHistoryUncheckedUpdateManyWithoutCarNestedInput = {
    create?: XOR<CarLicenseHistoryCreateWithoutCarInput, CarLicenseHistoryUncheckedCreateWithoutCarInput> | CarLicenseHistoryCreateWithoutCarInput[] | CarLicenseHistoryUncheckedCreateWithoutCarInput[]
    connectOrCreate?: CarLicenseHistoryCreateOrConnectWithoutCarInput | CarLicenseHistoryCreateOrConnectWithoutCarInput[]
    upsert?: CarLicenseHistoryUpsertWithWhereUniqueWithoutCarInput | CarLicenseHistoryUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: CarLicenseHistoryCreateManyCarInputEnvelope
    set?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    disconnect?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    delete?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    connect?: CarLicenseHistoryWhereUniqueInput | CarLicenseHistoryWhereUniqueInput[]
    update?: CarLicenseHistoryUpdateWithWhereUniqueWithoutCarInput | CarLicenseHistoryUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: CarLicenseHistoryUpdateManyWithWhereWithoutCarInput | CarLicenseHistoryUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: CarLicenseHistoryScalarWhereInput | CarLicenseHistoryScalarWhereInput[]
  }

  export type RideUncheckedUpdateManyWithoutCarNestedInput = {
    create?: XOR<RideCreateWithoutCarInput, RideUncheckedCreateWithoutCarInput> | RideCreateWithoutCarInput[] | RideUncheckedCreateWithoutCarInput[]
    connectOrCreate?: RideCreateOrConnectWithoutCarInput | RideCreateOrConnectWithoutCarInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutCarInput | RideUpsertWithWhereUniqueWithoutCarInput[]
    createMany?: RideCreateManyCarInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutCarInput | RideUpdateWithWhereUniqueWithoutCarInput[]
    updateMany?: RideUpdateManyWithWhereWithoutCarInput | RideUpdateManyWithWhereWithoutCarInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type CarCreateNestedOneWithoutLicenseHistoryInput = {
    create?: XOR<CarCreateWithoutLicenseHistoryInput, CarUncheckedCreateWithoutLicenseHistoryInput>
    connectOrCreate?: CarCreateOrConnectWithoutLicenseHistoryInput
    connect?: CarWhereUniqueInput
  }

  export type CarUpdateOneRequiredWithoutLicenseHistoryNestedInput = {
    create?: XOR<CarCreateWithoutLicenseHistoryInput, CarUncheckedCreateWithoutLicenseHistoryInput>
    connectOrCreate?: CarCreateOrConnectWithoutLicenseHistoryInput
    upsert?: CarUpsertWithoutLicenseHistoryInput
    connect?: CarWhereUniqueInput
    update?: XOR<XOR<CarUpdateToOneWithWhereWithoutLicenseHistoryInput, CarUpdateWithoutLicenseHistoryInput>, CarUncheckedUpdateWithoutLicenseHistoryInput>
  }

  export type BookingCreateNestedManyWithoutRideInput = {
    create?: XOR<BookingCreateWithoutRideInput, BookingUncheckedCreateWithoutRideInput> | BookingCreateWithoutRideInput[] | BookingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRideInput | BookingCreateOrConnectWithoutRideInput[]
    createMany?: BookingCreateManyRideInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ChatCreateNestedOneWithoutRideInput = {
    create?: XOR<ChatCreateWithoutRideInput, ChatUncheckedCreateWithoutRideInput>
    connectOrCreate?: ChatCreateOrConnectWithoutRideInput
    connect?: ChatWhereUniqueInput
  }

  export type FeedbackCreateNestedManyWithoutRideInput = {
    create?: XOR<FeedbackCreateWithoutRideInput, FeedbackUncheckedCreateWithoutRideInput> | FeedbackCreateWithoutRideInput[] | FeedbackUncheckedCreateWithoutRideInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRideInput | FeedbackCreateOrConnectWithoutRideInput[]
    createMany?: FeedbackCreateManyRideInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type OfferCreateNestedManyWithoutRideInput = {
    create?: XOR<OfferCreateWithoutRideInput, OfferUncheckedCreateWithoutRideInput> | OfferCreateWithoutRideInput[] | OfferUncheckedCreateWithoutRideInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRideInput | OfferCreateOrConnectWithoutRideInput[]
    createMany?: OfferCreateManyRideInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutRideInput = {
    create?: XOR<ReportCreateWithoutRideInput, ReportUncheckedCreateWithoutRideInput> | ReportCreateWithoutRideInput[] | ReportUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRideInput | ReportCreateOrConnectWithoutRideInput[]
    createMany?: ReportCreateManyRideInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type CarCreateNestedOneWithoutRidesInput = {
    create?: XOR<CarCreateWithoutRidesInput, CarUncheckedCreateWithoutRidesInput>
    connectOrCreate?: CarCreateOrConnectWithoutRidesInput
    connect?: CarWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRidesInput = {
    create?: XOR<UserCreateWithoutRidesInput, UserUncheckedCreateWithoutRidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRidesInput
    connect?: UserWhereUniqueInput
  }

  export type RideCommentCreateNestedManyWithoutRideInput = {
    create?: XOR<RideCommentCreateWithoutRideInput, RideCommentUncheckedCreateWithoutRideInput> | RideCommentCreateWithoutRideInput[] | RideCommentUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutRideInput | RideCommentCreateOrConnectWithoutRideInput[]
    createMany?: RideCommentCreateManyRideInputEnvelope
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
  }

  export type ScheduledRideCreateNestedOneWithoutCreatedRidesInput = {
    create?: XOR<ScheduledRideCreateWithoutCreatedRidesInput, ScheduledRideUncheckedCreateWithoutCreatedRidesInput>
    connectOrCreate?: ScheduledRideCreateOrConnectWithoutCreatedRidesInput
    connect?: ScheduledRideWhereUniqueInput
  }

  export type RideInterestCreateNestedManyWithoutRideInput = {
    create?: XOR<RideInterestCreateWithoutRideInput, RideInterestUncheckedCreateWithoutRideInput> | RideInterestCreateWithoutRideInput[] | RideInterestUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutRideInput | RideInterestCreateOrConnectWithoutRideInput[]
    createMany?: RideInterestCreateManyRideInputEnvelope
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
  }

  export type GroupBookingInvitationCreateNestedManyWithoutRideInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutRideInput, GroupBookingInvitationUncheckedCreateWithoutRideInput> | GroupBookingInvitationCreateWithoutRideInput[] | GroupBookingInvitationUncheckedCreateWithoutRideInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutRideInput | GroupBookingInvitationCreateOrConnectWithoutRideInput[]
    createMany?: GroupBookingInvitationCreateManyRideInputEnvelope
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<BookingCreateWithoutRideInput, BookingUncheckedCreateWithoutRideInput> | BookingCreateWithoutRideInput[] | BookingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRideInput | BookingCreateOrConnectWithoutRideInput[]
    createMany?: BookingCreateManyRideInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedOneWithoutRideInput = {
    create?: XOR<ChatCreateWithoutRideInput, ChatUncheckedCreateWithoutRideInput>
    connectOrCreate?: ChatCreateOrConnectWithoutRideInput
    connect?: ChatWhereUniqueInput
  }

  export type FeedbackUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<FeedbackCreateWithoutRideInput, FeedbackUncheckedCreateWithoutRideInput> | FeedbackCreateWithoutRideInput[] | FeedbackUncheckedCreateWithoutRideInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRideInput | FeedbackCreateOrConnectWithoutRideInput[]
    createMany?: FeedbackCreateManyRideInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type OfferUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<OfferCreateWithoutRideInput, OfferUncheckedCreateWithoutRideInput> | OfferCreateWithoutRideInput[] | OfferUncheckedCreateWithoutRideInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRideInput | OfferCreateOrConnectWithoutRideInput[]
    createMany?: OfferCreateManyRideInputEnvelope
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<ReportCreateWithoutRideInput, ReportUncheckedCreateWithoutRideInput> | ReportCreateWithoutRideInput[] | ReportUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRideInput | ReportCreateOrConnectWithoutRideInput[]
    createMany?: ReportCreateManyRideInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type RideCommentUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<RideCommentCreateWithoutRideInput, RideCommentUncheckedCreateWithoutRideInput> | RideCommentCreateWithoutRideInput[] | RideCommentUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutRideInput | RideCommentCreateOrConnectWithoutRideInput[]
    createMany?: RideCommentCreateManyRideInputEnvelope
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
  }

  export type RideInterestUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<RideInterestCreateWithoutRideInput, RideInterestUncheckedCreateWithoutRideInput> | RideInterestCreateWithoutRideInput[] | RideInterestUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutRideInput | RideInterestCreateOrConnectWithoutRideInput[]
    createMany?: RideInterestCreateManyRideInputEnvelope
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
  }

  export type GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutRideInput, GroupBookingInvitationUncheckedCreateWithoutRideInput> | GroupBookingInvitationCreateWithoutRideInput[] | GroupBookingInvitationUncheckedCreateWithoutRideInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutRideInput | GroupBookingInvitationCreateOrConnectWithoutRideInput[]
    createMany?: GroupBookingInvitationCreateManyRideInputEnvelope
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRideStatusFieldUpdateOperationsInput = {
    set?: $Enums.RideStatus
  }

  export type BookingUpdateManyWithoutRideNestedInput = {
    create?: XOR<BookingCreateWithoutRideInput, BookingUncheckedCreateWithoutRideInput> | BookingCreateWithoutRideInput[] | BookingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRideInput | BookingCreateOrConnectWithoutRideInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRideInput | BookingUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: BookingCreateManyRideInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRideInput | BookingUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRideInput | BookingUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ChatUpdateOneWithoutRideNestedInput = {
    create?: XOR<ChatCreateWithoutRideInput, ChatUncheckedCreateWithoutRideInput>
    connectOrCreate?: ChatCreateOrConnectWithoutRideInput
    upsert?: ChatUpsertWithoutRideInput
    disconnect?: ChatWhereInput | boolean
    delete?: ChatWhereInput | boolean
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutRideInput, ChatUpdateWithoutRideInput>, ChatUncheckedUpdateWithoutRideInput>
  }

  export type FeedbackUpdateManyWithoutRideNestedInput = {
    create?: XOR<FeedbackCreateWithoutRideInput, FeedbackUncheckedCreateWithoutRideInput> | FeedbackCreateWithoutRideInput[] | FeedbackUncheckedCreateWithoutRideInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRideInput | FeedbackCreateOrConnectWithoutRideInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutRideInput | FeedbackUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: FeedbackCreateManyRideInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutRideInput | FeedbackUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutRideInput | FeedbackUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type OfferUpdateManyWithoutRideNestedInput = {
    create?: XOR<OfferCreateWithoutRideInput, OfferUncheckedCreateWithoutRideInput> | OfferCreateWithoutRideInput[] | OfferUncheckedCreateWithoutRideInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRideInput | OfferCreateOrConnectWithoutRideInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutRideInput | OfferUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: OfferCreateManyRideInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutRideInput | OfferUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutRideInput | OfferUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutRideNestedInput = {
    create?: XOR<ReportCreateWithoutRideInput, ReportUncheckedCreateWithoutRideInput> | ReportCreateWithoutRideInput[] | ReportUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRideInput | ReportCreateOrConnectWithoutRideInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutRideInput | ReportUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: ReportCreateManyRideInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutRideInput | ReportUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutRideInput | ReportUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type CarUpdateOneWithoutRidesNestedInput = {
    create?: XOR<CarCreateWithoutRidesInput, CarUncheckedCreateWithoutRidesInput>
    connectOrCreate?: CarCreateOrConnectWithoutRidesInput
    upsert?: CarUpsertWithoutRidesInput
    disconnect?: CarWhereInput | boolean
    delete?: CarWhereInput | boolean
    connect?: CarWhereUniqueInput
    update?: XOR<XOR<CarUpdateToOneWithWhereWithoutRidesInput, CarUpdateWithoutRidesInput>, CarUncheckedUpdateWithoutRidesInput>
  }

  export type UserUpdateOneRequiredWithoutRidesNestedInput = {
    create?: XOR<UserCreateWithoutRidesInput, UserUncheckedCreateWithoutRidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRidesInput
    upsert?: UserUpsertWithoutRidesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRidesInput, UserUpdateWithoutRidesInput>, UserUncheckedUpdateWithoutRidesInput>
  }

  export type RideCommentUpdateManyWithoutRideNestedInput = {
    create?: XOR<RideCommentCreateWithoutRideInput, RideCommentUncheckedCreateWithoutRideInput> | RideCommentCreateWithoutRideInput[] | RideCommentUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutRideInput | RideCommentCreateOrConnectWithoutRideInput[]
    upsert?: RideCommentUpsertWithWhereUniqueWithoutRideInput | RideCommentUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: RideCommentCreateManyRideInputEnvelope
    set?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    disconnect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    delete?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    update?: RideCommentUpdateWithWhereUniqueWithoutRideInput | RideCommentUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: RideCommentUpdateManyWithWhereWithoutRideInput | RideCommentUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
  }

  export type ScheduledRideUpdateOneWithoutCreatedRidesNestedInput = {
    create?: XOR<ScheduledRideCreateWithoutCreatedRidesInput, ScheduledRideUncheckedCreateWithoutCreatedRidesInput>
    connectOrCreate?: ScheduledRideCreateOrConnectWithoutCreatedRidesInput
    upsert?: ScheduledRideUpsertWithoutCreatedRidesInput
    disconnect?: ScheduledRideWhereInput | boolean
    delete?: ScheduledRideWhereInput | boolean
    connect?: ScheduledRideWhereUniqueInput
    update?: XOR<XOR<ScheduledRideUpdateToOneWithWhereWithoutCreatedRidesInput, ScheduledRideUpdateWithoutCreatedRidesInput>, ScheduledRideUncheckedUpdateWithoutCreatedRidesInput>
  }

  export type RideInterestUpdateManyWithoutRideNestedInput = {
    create?: XOR<RideInterestCreateWithoutRideInput, RideInterestUncheckedCreateWithoutRideInput> | RideInterestCreateWithoutRideInput[] | RideInterestUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutRideInput | RideInterestCreateOrConnectWithoutRideInput[]
    upsert?: RideInterestUpsertWithWhereUniqueWithoutRideInput | RideInterestUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: RideInterestCreateManyRideInputEnvelope
    set?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    disconnect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    delete?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    update?: RideInterestUpdateWithWhereUniqueWithoutRideInput | RideInterestUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: RideInterestUpdateManyWithWhereWithoutRideInput | RideInterestUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: RideInterestScalarWhereInput | RideInterestScalarWhereInput[]
  }

  export type GroupBookingInvitationUpdateManyWithoutRideNestedInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutRideInput, GroupBookingInvitationUncheckedCreateWithoutRideInput> | GroupBookingInvitationCreateWithoutRideInput[] | GroupBookingInvitationUncheckedCreateWithoutRideInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutRideInput | GroupBookingInvitationCreateOrConnectWithoutRideInput[]
    upsert?: GroupBookingInvitationUpsertWithWhereUniqueWithoutRideInput | GroupBookingInvitationUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: GroupBookingInvitationCreateManyRideInputEnvelope
    set?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    disconnect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    delete?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    update?: GroupBookingInvitationUpdateWithWhereUniqueWithoutRideInput | GroupBookingInvitationUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: GroupBookingInvitationUpdateManyWithWhereWithoutRideInput | GroupBookingInvitationUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: GroupBookingInvitationScalarWhereInput | GroupBookingInvitationScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<BookingCreateWithoutRideInput, BookingUncheckedCreateWithoutRideInput> | BookingCreateWithoutRideInput[] | BookingUncheckedCreateWithoutRideInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRideInput | BookingCreateOrConnectWithoutRideInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRideInput | BookingUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: BookingCreateManyRideInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRideInput | BookingUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRideInput | BookingUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ChatUncheckedUpdateOneWithoutRideNestedInput = {
    create?: XOR<ChatCreateWithoutRideInput, ChatUncheckedCreateWithoutRideInput>
    connectOrCreate?: ChatCreateOrConnectWithoutRideInput
    upsert?: ChatUpsertWithoutRideInput
    disconnect?: ChatWhereInput | boolean
    delete?: ChatWhereInput | boolean
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutRideInput, ChatUpdateWithoutRideInput>, ChatUncheckedUpdateWithoutRideInput>
  }

  export type FeedbackUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<FeedbackCreateWithoutRideInput, FeedbackUncheckedCreateWithoutRideInput> | FeedbackCreateWithoutRideInput[] | FeedbackUncheckedCreateWithoutRideInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutRideInput | FeedbackCreateOrConnectWithoutRideInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutRideInput | FeedbackUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: FeedbackCreateManyRideInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutRideInput | FeedbackUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutRideInput | FeedbackUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type OfferUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<OfferCreateWithoutRideInput, OfferUncheckedCreateWithoutRideInput> | OfferCreateWithoutRideInput[] | OfferUncheckedCreateWithoutRideInput[]
    connectOrCreate?: OfferCreateOrConnectWithoutRideInput | OfferCreateOrConnectWithoutRideInput[]
    upsert?: OfferUpsertWithWhereUniqueWithoutRideInput | OfferUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: OfferCreateManyRideInputEnvelope
    set?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    disconnect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    delete?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    connect?: OfferWhereUniqueInput | OfferWhereUniqueInput[]
    update?: OfferUpdateWithWhereUniqueWithoutRideInput | OfferUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: OfferUpdateManyWithWhereWithoutRideInput | OfferUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: OfferScalarWhereInput | OfferScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<ReportCreateWithoutRideInput, ReportUncheckedCreateWithoutRideInput> | ReportCreateWithoutRideInput[] | ReportUncheckedCreateWithoutRideInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutRideInput | ReportCreateOrConnectWithoutRideInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutRideInput | ReportUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: ReportCreateManyRideInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutRideInput | ReportUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutRideInput | ReportUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type RideCommentUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<RideCommentCreateWithoutRideInput, RideCommentUncheckedCreateWithoutRideInput> | RideCommentCreateWithoutRideInput[] | RideCommentUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutRideInput | RideCommentCreateOrConnectWithoutRideInput[]
    upsert?: RideCommentUpsertWithWhereUniqueWithoutRideInput | RideCommentUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: RideCommentCreateManyRideInputEnvelope
    set?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    disconnect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    delete?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    update?: RideCommentUpdateWithWhereUniqueWithoutRideInput | RideCommentUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: RideCommentUpdateManyWithWhereWithoutRideInput | RideCommentUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
  }

  export type RideInterestUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<RideInterestCreateWithoutRideInput, RideInterestUncheckedCreateWithoutRideInput> | RideInterestCreateWithoutRideInput[] | RideInterestUncheckedCreateWithoutRideInput[]
    connectOrCreate?: RideInterestCreateOrConnectWithoutRideInput | RideInterestCreateOrConnectWithoutRideInput[]
    upsert?: RideInterestUpsertWithWhereUniqueWithoutRideInput | RideInterestUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: RideInterestCreateManyRideInputEnvelope
    set?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    disconnect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    delete?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    connect?: RideInterestWhereUniqueInput | RideInterestWhereUniqueInput[]
    update?: RideInterestUpdateWithWhereUniqueWithoutRideInput | RideInterestUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: RideInterestUpdateManyWithWhereWithoutRideInput | RideInterestUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: RideInterestScalarWhereInput | RideInterestScalarWhereInput[]
  }

  export type GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutRideInput, GroupBookingInvitationUncheckedCreateWithoutRideInput> | GroupBookingInvitationCreateWithoutRideInput[] | GroupBookingInvitationUncheckedCreateWithoutRideInput[]
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutRideInput | GroupBookingInvitationCreateOrConnectWithoutRideInput[]
    upsert?: GroupBookingInvitationUpsertWithWhereUniqueWithoutRideInput | GroupBookingInvitationUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: GroupBookingInvitationCreateManyRideInputEnvelope
    set?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    disconnect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    delete?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    connect?: GroupBookingInvitationWhereUniqueInput | GroupBookingInvitationWhereUniqueInput[]
    update?: GroupBookingInvitationUpdateWithWhereUniqueWithoutRideInput | GroupBookingInvitationUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: GroupBookingInvitationUpdateManyWithWhereWithoutRideInput | GroupBookingInvitationUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: GroupBookingInvitationScalarWhereInput | GroupBookingInvitationScalarWhereInput[]
  }

  export type RideCreateNestedOneWithoutInterestsInput = {
    create?: XOR<RideCreateWithoutInterestsInput, RideUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: RideCreateOrConnectWithoutInterestsInput
    connect?: RideWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInterestsInput = {
    create?: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestsInput
    connect?: UserWhereUniqueInput
  }

  export type RideUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<RideCreateWithoutInterestsInput, RideUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: RideCreateOrConnectWithoutInterestsInput
    upsert?: RideUpsertWithoutInterestsInput
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutInterestsInput, RideUpdateWithoutInterestsInput>, RideUncheckedUpdateWithoutInterestsInput>
  }

  export type UserUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterestsInput
    upsert?: UserUpsertWithoutInterestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterestsInput, UserUpdateWithoutInterestsInput>, UserUncheckedUpdateWithoutInterestsInput>
  }

  export type GroupBookingInvitationCreateNestedOneWithoutBookingsInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutBookingsInput, GroupBookingInvitationUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutBookingsInput
    connect?: GroupBookingInvitationWhereUniqueInput
  }

  export type RideCreateNestedOneWithoutBookingsInput = {
    create?: XOR<RideCreateWithoutBookingsInput, RideUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RideCreateOrConnectWithoutBookingsInput
    connect?: RideWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ChatMemberCreateNestedOneWithoutBookingInput = {
    create?: XOR<ChatMemberCreateWithoutBookingInput, ChatMemberUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ChatMemberCreateOrConnectWithoutBookingInput
    connect?: ChatMemberWhereUniqueInput
  }

  export type ChatMemberUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<ChatMemberCreateWithoutBookingInput, ChatMemberUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ChatMemberCreateOrConnectWithoutBookingInput
    connect?: ChatMemberWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type GroupBookingInvitationUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<GroupBookingInvitationCreateWithoutBookingsInput, GroupBookingInvitationUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: GroupBookingInvitationCreateOrConnectWithoutBookingsInput
    upsert?: GroupBookingInvitationUpsertWithoutBookingsInput
    disconnect?: GroupBookingInvitationWhereInput | boolean
    delete?: GroupBookingInvitationWhereInput | boolean
    connect?: GroupBookingInvitationWhereUniqueInput
    update?: XOR<XOR<GroupBookingInvitationUpdateToOneWithWhereWithoutBookingsInput, GroupBookingInvitationUpdateWithoutBookingsInput>, GroupBookingInvitationUncheckedUpdateWithoutBookingsInput>
  }

  export type RideUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<RideCreateWithoutBookingsInput, RideUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RideCreateOrConnectWithoutBookingsInput
    upsert?: RideUpsertWithoutBookingsInput
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutBookingsInput, RideUpdateWithoutBookingsInput>, RideUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type ChatMemberUpdateOneWithoutBookingNestedInput = {
    create?: XOR<ChatMemberCreateWithoutBookingInput, ChatMemberUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ChatMemberCreateOrConnectWithoutBookingInput
    upsert?: ChatMemberUpsertWithoutBookingInput
    disconnect?: ChatMemberWhereInput | boolean
    delete?: ChatMemberWhereInput | boolean
    connect?: ChatMemberWhereUniqueInput
    update?: XOR<XOR<ChatMemberUpdateToOneWithWhereWithoutBookingInput, ChatMemberUpdateWithoutBookingInput>, ChatMemberUncheckedUpdateWithoutBookingInput>
  }

  export type ChatMemberUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<ChatMemberCreateWithoutBookingInput, ChatMemberUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ChatMemberCreateOrConnectWithoutBookingInput
    upsert?: ChatMemberUpsertWithoutBookingInput
    disconnect?: ChatMemberWhereInput | boolean
    delete?: ChatMemberWhereInput | boolean
    connect?: ChatMemberWhereUniqueInput
    update?: XOR<XOR<ChatMemberUpdateToOneWithWhereWithoutBookingInput, ChatMemberUpdateWithoutBookingInput>, ChatMemberUncheckedUpdateWithoutBookingInput>
  }

  export type RideCreateNestedOneWithoutOffersInput = {
    create?: XOR<RideCreateWithoutOffersInput, RideUncheckedCreateWithoutOffersInput>
    connectOrCreate?: RideCreateOrConnectWithoutOffersInput
    connect?: RideWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOffersInput = {
    create?: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOfferStatusFieldUpdateOperationsInput = {
    set?: $Enums.OfferStatus
  }

  export type RideUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<RideCreateWithoutOffersInput, RideUncheckedCreateWithoutOffersInput>
    connectOrCreate?: RideCreateOrConnectWithoutOffersInput
    upsert?: RideUpsertWithoutOffersInput
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutOffersInput, RideUpdateWithoutOffersInput>, RideUncheckedUpdateWithoutOffersInput>
  }

  export type UserUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOffersInput
    upsert?: UserUpsertWithoutOffersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOffersInput, UserUpdateWithoutOffersInput>, UserUncheckedUpdateWithoutOffersInput>
  }

  export type RideCreateNestedOneWithoutChatInput = {
    create?: XOR<RideCreateWithoutChatInput, RideUncheckedCreateWithoutChatInput>
    connectOrCreate?: RideCreateOrConnectWithoutChatInput
    connect?: RideWhereUniqueInput
  }

  export type ChatMemberCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChatMemberUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type RideUpdateOneWithoutChatNestedInput = {
    create?: XOR<RideCreateWithoutChatInput, RideUncheckedCreateWithoutChatInput>
    connectOrCreate?: RideCreateOrConnectWithoutChatInput
    upsert?: RideUpsertWithoutChatInput
    disconnect?: RideWhereInput | boolean
    delete?: RideWhereInput | boolean
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutChatInput, RideUpdateWithoutChatInput>, RideUncheckedUpdateWithoutChatInput>
  }

  export type ChatMemberUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutChatInput | ChatMemberUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutChatInput | ChatMemberUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutChatInput | ChatMemberUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChatMemberUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput> | ChatMemberCreateWithoutChatInput[] | ChatMemberUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMemberCreateOrConnectWithoutChatInput | ChatMemberCreateOrConnectWithoutChatInput[]
    upsert?: ChatMemberUpsertWithWhereUniqueWithoutChatInput | ChatMemberUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMemberCreateManyChatInputEnvelope
    set?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    disconnect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    delete?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    connect?: ChatMemberWhereUniqueInput | ChatMemberWhereUniqueInput[]
    update?: ChatMemberUpdateWithWhereUniqueWithoutChatInput | ChatMemberUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMemberUpdateManyWithWhereWithoutChatInput | ChatMemberUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput> | MessageCreateWithoutChatInput[] | MessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChatInput | MessageCreateOrConnectWithoutChatInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChatInput | MessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: MessageCreateManyChatInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChatInput | MessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChatInput | MessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutChatMemberInput = {
    create?: XOR<BookingCreateWithoutChatMemberInput, BookingUncheckedCreateWithoutChatMemberInput>
    connectOrCreate?: BookingCreateOrConnectWithoutChatMemberInput
    connect?: BookingWhereUniqueInput
  }

  export type ChatCreateNestedOneWithoutMembersInput = {
    create?: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMembersInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatsInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingUpdateOneWithoutChatMemberNestedInput = {
    create?: XOR<BookingCreateWithoutChatMemberInput, BookingUncheckedCreateWithoutChatMemberInput>
    connectOrCreate?: BookingCreateOrConnectWithoutChatMemberInput
    upsert?: BookingUpsertWithoutChatMemberInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutChatMemberInput, BookingUpdateWithoutChatMemberInput>, BookingUncheckedUpdateWithoutChatMemberInput>
  }

  export type ChatUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMembersInput
    upsert?: ChatUpsertWithoutMembersInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMembersInput, ChatUpdateWithoutMembersInput>, ChatUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    upsert?: UserUpsertWithoutChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatsInput, UserUpdateWithoutChatsInput>, UserUncheckedUpdateWithoutChatsInput>
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutFeedbacksGivenInput = {
    create?: XOR<UserCreateWithoutFeedbacksGivenInput, UserUncheckedCreateWithoutFeedbacksGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFeedbacksReceivedInput = {
    create?: XOR<UserCreateWithoutFeedbacksReceivedInput, UserUncheckedCreateWithoutFeedbacksReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type RideCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<RideCreateWithoutFeedbacksInput, RideUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: RideCreateOrConnectWithoutFeedbacksInput
    connect?: RideWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutFeedbacksGivenNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksGivenInput, UserUncheckedCreateWithoutFeedbacksGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksGivenInput
    upsert?: UserUpsertWithoutFeedbacksGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksGivenInput, UserUpdateWithoutFeedbacksGivenInput>, UserUncheckedUpdateWithoutFeedbacksGivenInput>
  }

  export type UserUpdateOneRequiredWithoutFeedbacksReceivedNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksReceivedInput, UserUncheckedCreateWithoutFeedbacksReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksReceivedInput
    upsert?: UserUpsertWithoutFeedbacksReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksReceivedInput, UserUpdateWithoutFeedbacksReceivedInput>, UserUncheckedUpdateWithoutFeedbacksReceivedInput>
  }

  export type RideUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<RideCreateWithoutFeedbacksInput, RideUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: RideCreateOrConnectWithoutFeedbacksInput
    upsert?: RideUpsertWithoutFeedbacksInput
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutFeedbacksInput, RideUpdateWithoutFeedbacksInput>, RideUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type BadgeCreateNestedOneWithoutUsersInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    upsert?: BadgeUpsertWithoutUsersInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutUsersInput, BadgeUpdateWithoutUsersInput>, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserCreateNestedOneWithoutReferralReceivedInput = {
    create?: XOR<UserCreateWithoutReferralReceivedInput, UserUncheckedCreateWithoutReferralReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferralsMadeInput = {
    create?: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferralReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReferralReceivedInput, UserUncheckedCreateWithoutReferralReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralReceivedInput
    upsert?: UserUpsertWithoutReferralReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralReceivedInput, UserUpdateWithoutReferralReceivedInput>, UserUncheckedUpdateWithoutReferralReceivedInput>
  }

  export type UserUpdateOneRequiredWithoutReferralsMadeNestedInput = {
    create?: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsMadeInput
    upsert?: UserUpsertWithoutReferralsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsMadeInput, UserUpdateWithoutReferralsMadeInput>, UserUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type UserCreateNestedOneWithoutStatsInput = {
    create?: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatsInput
    upsert?: UserUpsertWithoutStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatsInput, UserUpdateWithoutStatsInput>, UserUncheckedUpdateWithoutStatsInput>
  }

  export type UserCreateNestedOneWithoutPromoCodesInput = {
    create?: XOR<UserCreateWithoutPromoCodesInput, UserUncheckedCreateWithoutPromoCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromoCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPromoCodesNestedInput = {
    create?: XOR<UserCreateWithoutPromoCodesInput, UserUncheckedCreateWithoutPromoCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPromoCodesInput
    upsert?: UserUpsertWithoutPromoCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPromoCodesInput, UserUpdateWithoutPromoCodesInput>, UserUncheckedUpdateWithoutPromoCodesInput>
  }

  export type UserCreateNestedOneWithoutReportsReceivedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsMadeInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type RideCreateNestedOneWithoutReportsInput = {
    create?: XOR<RideCreateWithoutReportsInput, RideUncheckedCreateWithoutReportsInput>
    connectOrCreate?: RideCreateOrConnectWithoutReportsInput
    connect?: RideWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type UserUpdateOneRequiredWithoutReportsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    upsert?: UserUpsertWithoutReportsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsReceivedInput, UserUpdateWithoutReportsReceivedInput>, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type UserUpdateOneRequiredWithoutReportsMadeNestedInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    upsert?: UserUpsertWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsMadeInput, UserUpdateWithoutReportsMadeInput>, UserUncheckedUpdateWithoutReportsMadeInput>
  }

  export type RideUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<RideCreateWithoutReportsInput, RideUncheckedCreateWithoutReportsInput>
    connectOrCreate?: RideCreateOrConnectWithoutReportsInput
    upsert?: RideUpsertWithoutReportsInput
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutReportsInput, RideUpdateWithoutReportsInput>, RideUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutLastVisitsInput = {
    create?: XOR<UserCreateWithoutLastVisitsInput, UserUncheckedCreateWithoutLastVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLastVisitsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLastVisitsNestedInput = {
    create?: XOR<UserCreateWithoutLastVisitsInput, UserUncheckedCreateWithoutLastVisitsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLastVisitsInput
    upsert?: UserUpsertWithoutLastVisitsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLastVisitsInput, UserUpdateWithoutLastVisitsInput>, UserUncheckedUpdateWithoutLastVisitsInput>
  }

  export type UserCreateNestedOneWithoutSavedRoutesInput = {
    create?: XOR<UserCreateWithoutSavedRoutesInput, UserUncheckedCreateWithoutSavedRoutesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedRoutesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedRoutesNestedInput = {
    create?: XOR<UserCreateWithoutSavedRoutesInput, UserUncheckedCreateWithoutSavedRoutesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedRoutesInput
    upsert?: UserUpsertWithoutSavedRoutesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedRoutesInput, UserUpdateWithoutSavedRoutesInput>, UserUncheckedUpdateWithoutSavedRoutesInput>
  }

  export type ScheduledRideCreatedaysOfWeekInput = {
    set: number[]
  }

  export type UserCreateNestedOneWithoutScheduledRidesInput = {
    create?: XOR<UserCreateWithoutScheduledRidesInput, UserUncheckedCreateWithoutScheduledRidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledRidesInput
    connect?: UserWhereUniqueInput
  }

  export type RideCreateNestedManyWithoutScheduledRideInput = {
    create?: XOR<RideCreateWithoutScheduledRideInput, RideUncheckedCreateWithoutScheduledRideInput> | RideCreateWithoutScheduledRideInput[] | RideUncheckedCreateWithoutScheduledRideInput[]
    connectOrCreate?: RideCreateOrConnectWithoutScheduledRideInput | RideCreateOrConnectWithoutScheduledRideInput[]
    createMany?: RideCreateManyScheduledRideInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideUncheckedCreateNestedManyWithoutScheduledRideInput = {
    create?: XOR<RideCreateWithoutScheduledRideInput, RideUncheckedCreateWithoutScheduledRideInput> | RideCreateWithoutScheduledRideInput[] | RideUncheckedCreateWithoutScheduledRideInput[]
    connectOrCreate?: RideCreateOrConnectWithoutScheduledRideInput | RideCreateOrConnectWithoutScheduledRideInput[]
    createMany?: RideCreateManyScheduledRideInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type ScheduledRideUpdatedaysOfWeekInput = {
    set?: number[]
    push?: number | number[]
  }

  export type UserUpdateOneRequiredWithoutScheduledRidesNestedInput = {
    create?: XOR<UserCreateWithoutScheduledRidesInput, UserUncheckedCreateWithoutScheduledRidesInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledRidesInput
    upsert?: UserUpsertWithoutScheduledRidesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduledRidesInput, UserUpdateWithoutScheduledRidesInput>, UserUncheckedUpdateWithoutScheduledRidesInput>
  }

  export type RideUpdateManyWithoutScheduledRideNestedInput = {
    create?: XOR<RideCreateWithoutScheduledRideInput, RideUncheckedCreateWithoutScheduledRideInput> | RideCreateWithoutScheduledRideInput[] | RideUncheckedCreateWithoutScheduledRideInput[]
    connectOrCreate?: RideCreateOrConnectWithoutScheduledRideInput | RideCreateOrConnectWithoutScheduledRideInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutScheduledRideInput | RideUpsertWithWhereUniqueWithoutScheduledRideInput[]
    createMany?: RideCreateManyScheduledRideInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutScheduledRideInput | RideUpdateWithWhereUniqueWithoutScheduledRideInput[]
    updateMany?: RideUpdateManyWithWhereWithoutScheduledRideInput | RideUpdateManyWithWhereWithoutScheduledRideInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideUncheckedUpdateManyWithoutScheduledRideNestedInput = {
    create?: XOR<RideCreateWithoutScheduledRideInput, RideUncheckedCreateWithoutScheduledRideInput> | RideCreateWithoutScheduledRideInput[] | RideUncheckedCreateWithoutScheduledRideInput[]
    connectOrCreate?: RideCreateOrConnectWithoutScheduledRideInput | RideCreateOrConnectWithoutScheduledRideInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutScheduledRideInput | RideUpsertWithWhereUniqueWithoutScheduledRideInput[]
    createMany?: RideCreateManyScheduledRideInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutScheduledRideInput | RideUpdateWithWhereUniqueWithoutScheduledRideInput[]
    updateMany?: RideUpdateManyWithWhereWithoutScheduledRideInput | RideUpdateManyWithWhereWithoutScheduledRideInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<RideCommentCreateWithoutRepliesInput, RideCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: RideCommentCreateOrConnectWithoutRepliesInput
    connect?: RideCommentWhereUniqueInput
  }

  export type RideCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<RideCommentCreateWithoutParentInput, RideCommentUncheckedCreateWithoutParentInput> | RideCommentCreateWithoutParentInput[] | RideCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutParentInput | RideCommentCreateOrConnectWithoutParentInput[]
    createMany?: RideCommentCreateManyParentInputEnvelope
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
  }

  export type RideCreateNestedOneWithoutCommentsInput = {
    create?: XOR<RideCreateWithoutCommentsInput, RideUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: RideCreateOrConnectWithoutCommentsInput
    connect?: RideWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type RideCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<RideCommentCreateWithoutParentInput, RideCommentUncheckedCreateWithoutParentInput> | RideCommentCreateWithoutParentInput[] | RideCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutParentInput | RideCommentCreateOrConnectWithoutParentInput[]
    createMany?: RideCommentCreateManyParentInputEnvelope
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
  }

  export type RideCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<RideCommentCreateWithoutRepliesInput, RideCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: RideCommentCreateOrConnectWithoutRepliesInput
    upsert?: RideCommentUpsertWithoutRepliesInput
    disconnect?: RideCommentWhereInput | boolean
    delete?: RideCommentWhereInput | boolean
    connect?: RideCommentWhereUniqueInput
    update?: XOR<XOR<RideCommentUpdateToOneWithWhereWithoutRepliesInput, RideCommentUpdateWithoutRepliesInput>, RideCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type RideCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<RideCommentCreateWithoutParentInput, RideCommentUncheckedCreateWithoutParentInput> | RideCommentCreateWithoutParentInput[] | RideCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutParentInput | RideCommentCreateOrConnectWithoutParentInput[]
    upsert?: RideCommentUpsertWithWhereUniqueWithoutParentInput | RideCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RideCommentCreateManyParentInputEnvelope
    set?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    disconnect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    delete?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    update?: RideCommentUpdateWithWhereUniqueWithoutParentInput | RideCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RideCommentUpdateManyWithWhereWithoutParentInput | RideCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
  }

  export type RideUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<RideCreateWithoutCommentsInput, RideUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: RideCreateOrConnectWithoutCommentsInput
    upsert?: RideUpsertWithoutCommentsInput
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutCommentsInput, RideUpdateWithoutCommentsInput>, RideUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type RideCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<RideCommentCreateWithoutParentInput, RideCommentUncheckedCreateWithoutParentInput> | RideCommentCreateWithoutParentInput[] | RideCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideCommentCreateOrConnectWithoutParentInput | RideCommentCreateOrConnectWithoutParentInput[]
    upsert?: RideCommentUpsertWithWhereUniqueWithoutParentInput | RideCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RideCommentCreateManyParentInputEnvelope
    set?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    disconnect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    delete?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    connect?: RideCommentWhereUniqueInput | RideCommentWhereUniqueInput[]
    update?: RideCommentUpdateWithWhereUniqueWithoutParentInput | RideCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RideCommentUpdateManyWithWhereWithoutParentInput | RideCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutInvitationInput = {
    create?: XOR<BookingCreateWithoutInvitationInput, BookingUncheckedCreateWithoutInvitationInput> | BookingCreateWithoutInvitationInput[] | BookingUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutInvitationInput | BookingCreateOrConnectWithoutInvitationInput[]
    createMany?: BookingCreateManyInvitationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type RideCreateNestedOneWithoutGroupInvitationsInput = {
    create?: XOR<RideCreateWithoutGroupInvitationsInput, RideUncheckedCreateWithoutGroupInvitationsInput>
    connectOrCreate?: RideCreateOrConnectWithoutGroupInvitationsInput
    connect?: RideWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInitiatedInvitationsInput = {
    create?: XOR<UserCreateWithoutInitiatedInvitationsInput, UserUncheckedCreateWithoutInitiatedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutInvitationInput = {
    create?: XOR<BookingCreateWithoutInvitationInput, BookingUncheckedCreateWithoutInvitationInput> | BookingCreateWithoutInvitationInput[] | BookingUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutInvitationInput | BookingCreateOrConnectWithoutInvitationInput[]
    createMany?: BookingCreateManyInvitationInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<BookingCreateWithoutInvitationInput, BookingUncheckedCreateWithoutInvitationInput> | BookingCreateWithoutInvitationInput[] | BookingUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutInvitationInput | BookingCreateOrConnectWithoutInvitationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutInvitationInput | BookingUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: BookingCreateManyInvitationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutInvitationInput | BookingUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutInvitationInput | BookingUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type RideUpdateOneRequiredWithoutGroupInvitationsNestedInput = {
    create?: XOR<RideCreateWithoutGroupInvitationsInput, RideUncheckedCreateWithoutGroupInvitationsInput>
    connectOrCreate?: RideCreateOrConnectWithoutGroupInvitationsInput
    upsert?: RideUpsertWithoutGroupInvitationsInput
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutGroupInvitationsInput, RideUpdateWithoutGroupInvitationsInput>, RideUncheckedUpdateWithoutGroupInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutInitiatedInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInitiatedInvitationsInput, UserUncheckedCreateWithoutInitiatedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInitiatedInvitationsInput
    upsert?: UserUpsertWithoutInitiatedInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInitiatedInvitationsInput, UserUpdateWithoutInitiatedInvitationsInput>, UserUncheckedUpdateWithoutInitiatedInvitationsInput>
  }

  export type BookingUncheckedUpdateManyWithoutInvitationNestedInput = {
    create?: XOR<BookingCreateWithoutInvitationInput, BookingUncheckedCreateWithoutInvitationInput> | BookingCreateWithoutInvitationInput[] | BookingUncheckedCreateWithoutInvitationInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutInvitationInput | BookingCreateOrConnectWithoutInvitationInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutInvitationInput | BookingUpsertWithWhereUniqueWithoutInvitationInput[]
    createMany?: BookingCreateManyInvitationInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutInvitationInput | BookingUpdateWithWhereUniqueWithoutInvitationInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutInvitationInput | BookingUpdateManyWithWhereWithoutInvitationInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumRideStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusFilter<$PrismaModel> | $Enums.RideStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumRideStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusWithAggregatesFilter<$PrismaModel> | $Enums.RideStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRideStatusFilter<$PrismaModel>
    _max?: NestedEnumRideStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type AdminLastVisitCreateWithoutAdminInput = {
    id?: string
    resource: string
    lastVisitedAt?: Date | string
  }

  export type AdminLastVisitUncheckedCreateWithoutAdminInput = {
    id?: string
    resource: string
    lastVisitedAt?: Date | string
  }

  export type AdminLastVisitCreateOrConnectWithoutAdminInput = {
    where: AdminLastVisitWhereUniqueInput
    create: XOR<AdminLastVisitCreateWithoutAdminInput, AdminLastVisitUncheckedCreateWithoutAdminInput>
  }

  export type AdminLastVisitCreateManyAdminInputEnvelope = {
    data: AdminLastVisitCreateManyAdminInput | AdminLastVisitCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitation?: GroupBookingInvitationCreateNestedOneWithoutBookingsInput
    ride: RideCreateNestedOneWithoutBookingsInput
    chatMember?: ChatMemberCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: string
    rideId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitationId?: string | null
    chatMember?: ChatMemberUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupBookingInvitationCreateWithoutInitiatorInput = {
    id?: string
    seats: number
    expiresAt: Date | string
    status?: string
    bookings?: BookingCreateNestedManyWithoutInvitationInput
    ride: RideCreateNestedOneWithoutGroupInvitationsInput
  }

  export type GroupBookingInvitationUncheckedCreateWithoutInitiatorInput = {
    id?: string
    rideId: string
    seats: number
    expiresAt: Date | string
    status?: string
    bookings?: BookingUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type GroupBookingInvitationCreateOrConnectWithoutInitiatorInput = {
    where: GroupBookingInvitationWhereUniqueInput
    create: XOR<GroupBookingInvitationCreateWithoutInitiatorInput, GroupBookingInvitationUncheckedCreateWithoutInitiatorInput>
  }

  export type GroupBookingInvitationCreateManyInitiatorInputEnvelope = {
    data: GroupBookingInvitationCreateManyInitiatorInput | GroupBookingInvitationCreateManyInitiatorInput[]
    skipDuplicates?: boolean
  }

  export type CarCreateWithoutUserInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    licenseHistory?: CarLicenseHistoryCreateNestedManyWithoutCarInput
    rides?: RideCreateNestedManyWithoutCarInput
  }

  export type CarUncheckedCreateWithoutUserInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    licenseHistory?: CarLicenseHistoryUncheckedCreateNestedManyWithoutCarInput
    rides?: RideUncheckedCreateNestedManyWithoutCarInput
  }

  export type CarCreateOrConnectWithoutUserInput = {
    where: CarWhereUniqueInput
    create: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
  }

  export type ChatMemberCreateWithoutUserInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    createdAt?: Date | string
    booking?: BookingCreateNestedOneWithoutChatMemberInput
    chat: ChatCreateNestedOneWithoutMembersInput
  }

  export type ChatMemberUncheckedCreateWithoutUserInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    chatId: string
    bookingId?: string | null
    createdAt?: Date | string
  }

  export type ChatMemberCreateOrConnectWithoutUserInput = {
    where: ChatMemberWhereUniqueInput
    create: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatMemberCreateManyUserInputEnvelope = {
    data: ChatMemberCreateManyUserInput | ChatMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutGivenByInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
    receivedBy: UserCreateNestedOneWithoutFeedbacksReceivedInput
    ride: RideCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateWithoutGivenByInput = {
    id?: string
    rating: number
    comment?: string | null
    rideId: string
    receivedById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type FeedbackCreateOrConnectWithoutGivenByInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutGivenByInput, FeedbackUncheckedCreateWithoutGivenByInput>
  }

  export type FeedbackCreateManyGivenByInputEnvelope = {
    data: FeedbackCreateManyGivenByInput | FeedbackCreateManyGivenByInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutReceivedByInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
    givenBy: UserCreateNestedOneWithoutFeedbacksGivenInput
    ride: RideCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateWithoutReceivedByInput = {
    id?: string
    rating: number
    comment?: string | null
    rideId: string
    givenById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type FeedbackCreateOrConnectWithoutReceivedByInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutReceivedByInput, FeedbackUncheckedCreateWithoutReceivedByInput>
  }

  export type FeedbackCreateManyReceivedByInputEnvelope = {
    data: FeedbackCreateManyReceivedByInput | FeedbackCreateManyReceivedByInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutUserInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    type?: string
    chatId: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    relatedId?: string | null
    createdAt?: Date | string
    bookingStatus?: string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    relatedId?: string | null
    createdAt?: Date | string
    bookingStatus?: string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutUserInput = {
    id?: string
    price: number
    createdAt?: Date | string
    status?: $Enums.OfferStatus
    ride: RideCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateWithoutUserInput = {
    id?: string
    price: number
    rideId: string
    createdAt?: Date | string
    status?: $Enums.OfferStatus
  }

  export type OfferCreateOrConnectWithoutUserInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput>
  }

  export type OfferCreateManyUserInputEnvelope = {
    data: OfferCreateManyUserInput | OfferCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PromoCodeCreateWithoutUserInput = {
    id?: string
    code: string
    isUsed?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PromoCodeUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    isUsed?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PromoCodeCreateOrConnectWithoutUserInput = {
    where: PromoCodeWhereUniqueInput
    create: XOR<PromoCodeCreateWithoutUserInput, PromoCodeUncheckedCreateWithoutUserInput>
  }

  export type PromoCodeCreateManyUserInputEnvelope = {
    data: PromoCodeCreateManyUserInput | PromoCodeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutRefereeInput = {
    id?: string
    code: string
    bonusGiven?: boolean
    createdAt?: Date | string
    referrer: UserCreateNestedOneWithoutReferralsMadeInput
  }

  export type ReferralUncheckedCreateWithoutRefereeInput = {
    id?: string
    code: string
    referrerId: string
    bonusGiven?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutRefereeInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    code: string
    bonusGiven?: boolean
    createdAt?: Date | string
    referee: UserCreateNestedOneWithoutReferralReceivedInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    code: string
    refereeId: string
    bonusGiven?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReportedUserInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    ride: RideCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedUserInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    rideId: string
    reporterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportCreateManyReportedUserInputEnvelope = {
    data: ReportCreateManyReportedUserInput | ReportCreateManyReportedUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReporterInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
    ride: RideCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReporterInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    rideId: string
    reportedUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReporterInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportCreateManyReporterInputEnvelope = {
    data: ReportCreateManyReporterInput | ReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type RideCreateWithoutDriverInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutDriverInput = {
    id?: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutDriverInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutDriverInput, RideUncheckedCreateWithoutDriverInput>
  }

  export type RideCreateManyDriverInputEnvelope = {
    data: RideCreateManyDriverInput | RideCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type RideCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    parent?: RideCommentCreateNestedOneWithoutRepliesInput
    replies?: RideCommentCreateNestedManyWithoutParentInput
    ride: RideCreateNestedOneWithoutCommentsInput
  }

  export type RideCommentUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    rideId: string
    parentId?: string | null
    replies?: RideCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type RideCommentCreateOrConnectWithoutUserInput = {
    where: RideCommentWhereUniqueInput
    create: XOR<RideCommentCreateWithoutUserInput, RideCommentUncheckedCreateWithoutUserInput>
  }

  export type RideCommentCreateManyUserInputEnvelope = {
    data: RideCommentCreateManyUserInput | RideCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RideInterestCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    ride: RideCreateNestedOneWithoutInterestsInput
  }

  export type RideInterestUncheckedCreateWithoutUserInput = {
    id?: string
    rideId: string
    createdAt?: Date | string
  }

  export type RideInterestCreateOrConnectWithoutUserInput = {
    where: RideInterestWhereUniqueInput
    create: XOR<RideInterestCreateWithoutUserInput, RideInterestUncheckedCreateWithoutUserInput>
  }

  export type RideInterestCreateManyUserInputEnvelope = {
    data: RideInterestCreateManyUserInput | RideInterestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SavedRouteCreateWithoutUserInput = {
    id?: string
    name: string
    icon?: string | null
    polyline?: string | null
    originAddress: string
    originLat: number
    originLng: number
    originCity?: string | null
    originSuburb?: string | null
    destinationAddress: string
    destinationLat: number
    destinationLng: number
    destinationCity?: string | null
    destinationSuburb?: string | null
    createdAt?: Date | string
  }

  export type SavedRouteUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    icon?: string | null
    polyline?: string | null
    originAddress: string
    originLat: number
    originLng: number
    originCity?: string | null
    originSuburb?: string | null
    destinationAddress: string
    destinationLat: number
    destinationLng: number
    destinationCity?: string | null
    destinationSuburb?: string | null
    createdAt?: Date | string
  }

  export type SavedRouteCreateOrConnectWithoutUserInput = {
    where: SavedRouteWhereUniqueInput
    create: XOR<SavedRouteCreateWithoutUserInput, SavedRouteUncheckedCreateWithoutUserInput>
  }

  export type SavedRouteCreateManyUserInputEnvelope = {
    data: SavedRouteCreateManyUserInput | SavedRouteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledRideCreateWithoutDriverInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
    createdRides?: RideCreateNestedManyWithoutScheduledRideInput
  }

  export type ScheduledRideUncheckedCreateWithoutDriverInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
    createdRides?: RideUncheckedCreateNestedManyWithoutScheduledRideInput
  }

  export type ScheduledRideCreateOrConnectWithoutDriverInput = {
    where: ScheduledRideWhereUniqueInput
    create: XOR<ScheduledRideCreateWithoutDriverInput, ScheduledRideUncheckedCreateWithoutDriverInput>
  }

  export type ScheduledRideCreateManyDriverInputEnvelope = {
    data: ScheduledRideCreateManyDriverInput | ScheduledRideCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badgeId: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserStatsCreateWithoutUserInput = {
    id?: string
    onTimeStarts?: number
    onTimeArrivals?: number
    totalChatMessages?: number
    fastResponses?: number
    totalBookingsToAccept?: number
    acceptedBookings?: number
    totalCancellations?: number
    totalRidesAsDriver?: number
    totalRidesAsPassenger?: number
    completedFreeRidesAsDriver?: number
    fastResponseOpportunities?: number
    fastResponseSuccesses?: number
  }

  export type UserStatsUncheckedCreateWithoutUserInput = {
    id?: string
    onTimeStarts?: number
    onTimeArrivals?: number
    totalChatMessages?: number
    fastResponses?: number
    totalBookingsToAccept?: number
    acceptedBookings?: number
    totalCancellations?: number
    totalRidesAsDriver?: number
    totalRidesAsPassenger?: number
    completedFreeRidesAsDriver?: number
    fastResponseOpportunities?: number
    fastResponseSuccesses?: number
  }

  export type UserStatsCreateOrConnectWithoutUserInput = {
    where: UserStatsWhereUniqueInput
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
  }

  export type AdminLastVisitUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminLastVisitWhereUniqueInput
    update: XOR<AdminLastVisitUpdateWithoutAdminInput, AdminLastVisitUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminLastVisitCreateWithoutAdminInput, AdminLastVisitUncheckedCreateWithoutAdminInput>
  }

  export type AdminLastVisitUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminLastVisitWhereUniqueInput
    data: XOR<AdminLastVisitUpdateWithoutAdminInput, AdminLastVisitUncheckedUpdateWithoutAdminInput>
  }

  export type AdminLastVisitUpdateManyWithWhereWithoutAdminInput = {
    where: AdminLastVisitScalarWhereInput
    data: XOR<AdminLastVisitUpdateManyMutationInput, AdminLastVisitUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminLastVisitScalarWhereInput = {
    AND?: AdminLastVisitScalarWhereInput | AdminLastVisitScalarWhereInput[]
    OR?: AdminLastVisitScalarWhereInput[]
    NOT?: AdminLastVisitScalarWhereInput | AdminLastVisitScalarWhereInput[]
    id?: StringFilter<"AdminLastVisit"> | string
    adminId?: StringFilter<"AdminLastVisit"> | string
    resource?: StringFilter<"AdminLastVisit"> | string
    lastVisitedAt?: DateTimeFilter<"AdminLastVisit"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    rideId?: StringFilter<"Booking"> | string
    userId?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    invitationId?: StringNullableFilter<"Booking"> | string | null
  }

  export type GroupBookingInvitationUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: GroupBookingInvitationWhereUniqueInput
    update: XOR<GroupBookingInvitationUpdateWithoutInitiatorInput, GroupBookingInvitationUncheckedUpdateWithoutInitiatorInput>
    create: XOR<GroupBookingInvitationCreateWithoutInitiatorInput, GroupBookingInvitationUncheckedCreateWithoutInitiatorInput>
  }

  export type GroupBookingInvitationUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: GroupBookingInvitationWhereUniqueInput
    data: XOR<GroupBookingInvitationUpdateWithoutInitiatorInput, GroupBookingInvitationUncheckedUpdateWithoutInitiatorInput>
  }

  export type GroupBookingInvitationUpdateManyWithWhereWithoutInitiatorInput = {
    where: GroupBookingInvitationScalarWhereInput
    data: XOR<GroupBookingInvitationUpdateManyMutationInput, GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type GroupBookingInvitationScalarWhereInput = {
    AND?: GroupBookingInvitationScalarWhereInput | GroupBookingInvitationScalarWhereInput[]
    OR?: GroupBookingInvitationScalarWhereInput[]
    NOT?: GroupBookingInvitationScalarWhereInput | GroupBookingInvitationScalarWhereInput[]
    id?: StringFilter<"GroupBookingInvitation"> | string
    rideId?: StringFilter<"GroupBookingInvitation"> | string
    initiatorId?: StringFilter<"GroupBookingInvitation"> | string
    seats?: IntFilter<"GroupBookingInvitation"> | number
    expiresAt?: DateTimeFilter<"GroupBookingInvitation"> | Date | string
    status?: StringFilter<"GroupBookingInvitation"> | string
  }

  export type CarUpsertWithoutUserInput = {
    update: XOR<CarUpdateWithoutUserInput, CarUncheckedUpdateWithoutUserInput>
    create: XOR<CarCreateWithoutUserInput, CarUncheckedCreateWithoutUserInput>
    where?: CarWhereInput
  }

  export type CarUpdateToOneWithWhereWithoutUserInput = {
    where?: CarWhereInput
    data: XOR<CarUpdateWithoutUserInput, CarUncheckedUpdateWithoutUserInput>
  }

  export type CarUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    licenseHistory?: CarLicenseHistoryUpdateManyWithoutCarNestedInput
    rides?: RideUpdateManyWithoutCarNestedInput
  }

  export type CarUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    licenseHistory?: CarLicenseHistoryUncheckedUpdateManyWithoutCarNestedInput
    rides?: RideUncheckedUpdateManyWithoutCarNestedInput
  }

  export type ChatMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatMemberWhereUniqueInput
    update: XOR<ChatMemberUpdateWithoutUserInput, ChatMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ChatMemberCreateWithoutUserInput, ChatMemberUncheckedCreateWithoutUserInput>
  }

  export type ChatMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatMemberWhereUniqueInput
    data: XOR<ChatMemberUpdateWithoutUserInput, ChatMemberUncheckedUpdateWithoutUserInput>
  }

  export type ChatMemberUpdateManyWithWhereWithoutUserInput = {
    where: ChatMemberScalarWhereInput
    data: XOR<ChatMemberUpdateManyMutationInput, ChatMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatMemberScalarWhereInput = {
    AND?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
    OR?: ChatMemberScalarWhereInput[]
    NOT?: ChatMemberScalarWhereInput | ChatMemberScalarWhereInput[]
    id?: StringFilter<"ChatMember"> | string
    hasStarted?: BoolFilter<"ChatMember"> | boolean
    hasEnded?: BoolFilter<"ChatMember"> | boolean
    chatId?: StringFilter<"ChatMember"> | string
    userId?: StringFilter<"ChatMember"> | string
    bookingId?: StringNullableFilter<"ChatMember"> | string | null
    createdAt?: DateTimeFilter<"ChatMember"> | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutGivenByInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutGivenByInput, FeedbackUncheckedUpdateWithoutGivenByInput>
    create: XOR<FeedbackCreateWithoutGivenByInput, FeedbackUncheckedCreateWithoutGivenByInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutGivenByInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutGivenByInput, FeedbackUncheckedUpdateWithoutGivenByInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutGivenByInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutGivenByInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter<"Feedback"> | string
    rating?: IntFilter<"Feedback"> | number
    comment?: StringNullableFilter<"Feedback"> | string | null
    rideId?: StringFilter<"Feedback"> | string
    givenById?: StringFilter<"Feedback"> | string
    receivedById?: StringFilter<"Feedback"> | string
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    arrivalOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
    startOnTime?: BoolNullableFilter<"Feedback"> | boolean | null
  }

  export type FeedbackUpsertWithWhereUniqueWithoutReceivedByInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutReceivedByInput, FeedbackUncheckedUpdateWithoutReceivedByInput>
    create: XOR<FeedbackCreateWithoutReceivedByInput, FeedbackUncheckedCreateWithoutReceivedByInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutReceivedByInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutReceivedByInput, FeedbackUncheckedUpdateWithoutReceivedByInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutReceivedByInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutReceivedByInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    chatId?: StringFilter<"Message"> | string
    userId?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    relatedId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    bookingStatus?: StringNullableFilter<"Notification"> | string | null
  }

  export type OfferUpsertWithWhereUniqueWithoutUserInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutUserInput, OfferUncheckedUpdateWithoutUserInput>
    create: XOR<OfferCreateWithoutUserInput, OfferUncheckedCreateWithoutUserInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutUserInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutUserInput, OfferUncheckedUpdateWithoutUserInput>
  }

  export type OfferUpdateManyWithWhereWithoutUserInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutUserInput>
  }

  export type OfferScalarWhereInput = {
    AND?: OfferScalarWhereInput | OfferScalarWhereInput[]
    OR?: OfferScalarWhereInput[]
    NOT?: OfferScalarWhereInput | OfferScalarWhereInput[]
    id?: StringFilter<"Offer"> | string
    price?: FloatFilter<"Offer"> | number
    rideId?: StringFilter<"Offer"> | string
    userId?: StringFilter<"Offer"> | string
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
  }

  export type PromoCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: PromoCodeWhereUniqueInput
    update: XOR<PromoCodeUpdateWithoutUserInput, PromoCodeUncheckedUpdateWithoutUserInput>
    create: XOR<PromoCodeCreateWithoutUserInput, PromoCodeUncheckedCreateWithoutUserInput>
  }

  export type PromoCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: PromoCodeWhereUniqueInput
    data: XOR<PromoCodeUpdateWithoutUserInput, PromoCodeUncheckedUpdateWithoutUserInput>
  }

  export type PromoCodeUpdateManyWithWhereWithoutUserInput = {
    where: PromoCodeScalarWhereInput
    data: XOR<PromoCodeUpdateManyMutationInput, PromoCodeUncheckedUpdateManyWithoutUserInput>
  }

  export type PromoCodeScalarWhereInput = {
    AND?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    OR?: PromoCodeScalarWhereInput[]
    NOT?: PromoCodeScalarWhereInput | PromoCodeScalarWhereInput[]
    id?: StringFilter<"PromoCode"> | string
    code?: StringFilter<"PromoCode"> | string
    userId?: StringFilter<"PromoCode"> | string
    isUsed?: BoolFilter<"PromoCode"> | boolean
    createdAt?: DateTimeFilter<"PromoCode"> | Date | string
    expiresAt?: DateTimeFilter<"PromoCode"> | Date | string
  }

  export type ReferralUpsertWithoutRefereeInput = {
    update: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
    create: XOR<ReferralCreateWithoutRefereeInput, ReferralUncheckedCreateWithoutRefereeInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutRefereeInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutRefereeInput, ReferralUncheckedUpdateWithoutRefereeInput>
  }

  export type ReferralUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referrer?: UserUpdateOneRequiredWithoutReferralsMadeNestedInput
  }

  export type ReferralUncheckedUpdateWithoutRefereeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    code?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    refereeId?: StringFilter<"Referral"> | string
    bonusGiven?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedUserInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    reason?: StringFilter<"Report"> | string
    comment?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    rideId?: StringFilter<"Report"> | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
  }

  export type ReportUpdateManyWithWhereWithoutReporterInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type RideUpsertWithWhereUniqueWithoutDriverInput = {
    where: RideWhereUniqueInput
    update: XOR<RideUpdateWithoutDriverInput, RideUncheckedUpdateWithoutDriverInput>
    create: XOR<RideCreateWithoutDriverInput, RideUncheckedCreateWithoutDriverInput>
  }

  export type RideUpdateWithWhereUniqueWithoutDriverInput = {
    where: RideWhereUniqueInput
    data: XOR<RideUpdateWithoutDriverInput, RideUncheckedUpdateWithoutDriverInput>
  }

  export type RideUpdateManyWithWhereWithoutDriverInput = {
    where: RideScalarWhereInput
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyWithoutDriverInput>
  }

  export type RideScalarWhereInput = {
    AND?: RideScalarWhereInput | RideScalarWhereInput[]
    OR?: RideScalarWhereInput[]
    NOT?: RideScalarWhereInput | RideScalarWhereInput[]
    id?: StringFilter<"Ride"> | string
    driverId?: StringFilter<"Ride"> | string
    carId?: StringNullableFilter<"Ride"> | string | null
    carInfo?: StringNullableFilter<"Ride"> | string | null
    serviceType?: StringNullableFilter<"Ride"> | string | null
    seats?: IntFilter<"Ride"> | number
    price?: FloatFilter<"Ride"> | number
    receiptPrice?: FloatNullableFilter<"Ride"> | number | null
    renterScreenshotUrl?: StringNullableFilter<"Ride"> | string | null
    additionalInfo?: StringNullableFilter<"Ride"> | string | null
    createdAt?: DateTimeFilter<"Ride"> | Date | string
    startedAt?: DateTimeNullableFilter<"Ride"> | Date | string | null
    arrivedAt?: DateTimeNullableFilter<"Ride"> | Date | string | null
    time?: DateTimeFilter<"Ride"> | Date | string
    isTimeArranged?: BoolFilter<"Ride"> | boolean
    etaMinutes?: IntNullableFilter<"Ride"> | number | null
    destination?: StringFilter<"Ride"> | string
    origin?: StringFilter<"Ride"> | string
    fromCity?: StringFilter<"Ride"> | string
    fromSuburb?: StringFilter<"Ride"> | string
    toCity?: StringFilter<"Ride"> | string
    toSuburb?: StringFilter<"Ride"> | string
    fromCityNorm?: StringNullableFilter<"Ride"> | string | null
    fromSuburbNorm?: StringNullableFilter<"Ride"> | string | null
    toCityNorm?: StringNullableFilter<"Ride"> | string | null
    toSuburbNorm?: StringNullableFilter<"Ride"> | string | null
    rideType?: StringFilter<"Ride"> | string
    isRequest?: BoolFilter<"Ride"> | boolean
    isVerified?: BoolFilter<"Ride"> | boolean
    isAnonymous?: BoolFilter<"Ride"> | boolean
    status?: EnumRideStatusFilter<"Ride"> | $Enums.RideStatus
    allowedGender?: StringFilter<"Ride"> | string
    destinationLat?: FloatFilter<"Ride"> | number
    destinationLng?: FloatFilter<"Ride"> | number
    originLat?: FloatFilter<"Ride"> | number
    originLng?: FloatFilter<"Ride"> | number
    polyline?: StringNullableFilter<"Ride"> | string | null
    scheduledRideId?: StringNullableFilter<"Ride"> | string | null
  }

  export type RideCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: RideCommentWhereUniqueInput
    update: XOR<RideCommentUpdateWithoutUserInput, RideCommentUncheckedUpdateWithoutUserInput>
    create: XOR<RideCommentCreateWithoutUserInput, RideCommentUncheckedCreateWithoutUserInput>
  }

  export type RideCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: RideCommentWhereUniqueInput
    data: XOR<RideCommentUpdateWithoutUserInput, RideCommentUncheckedUpdateWithoutUserInput>
  }

  export type RideCommentUpdateManyWithWhereWithoutUserInput = {
    where: RideCommentScalarWhereInput
    data: XOR<RideCommentUpdateManyMutationInput, RideCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type RideCommentScalarWhereInput = {
    AND?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
    OR?: RideCommentScalarWhereInput[]
    NOT?: RideCommentScalarWhereInput | RideCommentScalarWhereInput[]
    id?: StringFilter<"RideComment"> | string
    content?: StringFilter<"RideComment"> | string
    createdAt?: DateTimeFilter<"RideComment"> | Date | string
    rideId?: StringFilter<"RideComment"> | string
    userId?: StringFilter<"RideComment"> | string
    parentId?: StringNullableFilter<"RideComment"> | string | null
  }

  export type RideInterestUpsertWithWhereUniqueWithoutUserInput = {
    where: RideInterestWhereUniqueInput
    update: XOR<RideInterestUpdateWithoutUserInput, RideInterestUncheckedUpdateWithoutUserInput>
    create: XOR<RideInterestCreateWithoutUserInput, RideInterestUncheckedCreateWithoutUserInput>
  }

  export type RideInterestUpdateWithWhereUniqueWithoutUserInput = {
    where: RideInterestWhereUniqueInput
    data: XOR<RideInterestUpdateWithoutUserInput, RideInterestUncheckedUpdateWithoutUserInput>
  }

  export type RideInterestUpdateManyWithWhereWithoutUserInput = {
    where: RideInterestScalarWhereInput
    data: XOR<RideInterestUpdateManyMutationInput, RideInterestUncheckedUpdateManyWithoutUserInput>
  }

  export type RideInterestScalarWhereInput = {
    AND?: RideInterestScalarWhereInput | RideInterestScalarWhereInput[]
    OR?: RideInterestScalarWhereInput[]
    NOT?: RideInterestScalarWhereInput | RideInterestScalarWhereInput[]
    id?: StringFilter<"RideInterest"> | string
    rideId?: StringFilter<"RideInterest"> | string
    userId?: StringFilter<"RideInterest"> | string
    createdAt?: DateTimeFilter<"RideInterest"> | Date | string
  }

  export type SavedRouteUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedRouteWhereUniqueInput
    update: XOR<SavedRouteUpdateWithoutUserInput, SavedRouteUncheckedUpdateWithoutUserInput>
    create: XOR<SavedRouteCreateWithoutUserInput, SavedRouteUncheckedCreateWithoutUserInput>
  }

  export type SavedRouteUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedRouteWhereUniqueInput
    data: XOR<SavedRouteUpdateWithoutUserInput, SavedRouteUncheckedUpdateWithoutUserInput>
  }

  export type SavedRouteUpdateManyWithWhereWithoutUserInput = {
    where: SavedRouteScalarWhereInput
    data: XOR<SavedRouteUpdateManyMutationInput, SavedRouteUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedRouteScalarWhereInput = {
    AND?: SavedRouteScalarWhereInput | SavedRouteScalarWhereInput[]
    OR?: SavedRouteScalarWhereInput[]
    NOT?: SavedRouteScalarWhereInput | SavedRouteScalarWhereInput[]
    id?: StringFilter<"SavedRoute"> | string
    name?: StringFilter<"SavedRoute"> | string
    icon?: StringNullableFilter<"SavedRoute"> | string | null
    polyline?: StringNullableFilter<"SavedRoute"> | string | null
    originAddress?: StringFilter<"SavedRoute"> | string
    originLat?: FloatFilter<"SavedRoute"> | number
    originLng?: FloatFilter<"SavedRoute"> | number
    originCity?: StringNullableFilter<"SavedRoute"> | string | null
    originSuburb?: StringNullableFilter<"SavedRoute"> | string | null
    destinationAddress?: StringFilter<"SavedRoute"> | string
    destinationLat?: FloatFilter<"SavedRoute"> | number
    destinationLng?: FloatFilter<"SavedRoute"> | number
    destinationCity?: StringNullableFilter<"SavedRoute"> | string | null
    destinationSuburb?: StringNullableFilter<"SavedRoute"> | string | null
    userId?: StringFilter<"SavedRoute"> | string
    createdAt?: DateTimeFilter<"SavedRoute"> | Date | string
  }

  export type ScheduledRideUpsertWithWhereUniqueWithoutDriverInput = {
    where: ScheduledRideWhereUniqueInput
    update: XOR<ScheduledRideUpdateWithoutDriverInput, ScheduledRideUncheckedUpdateWithoutDriverInput>
    create: XOR<ScheduledRideCreateWithoutDriverInput, ScheduledRideUncheckedCreateWithoutDriverInput>
  }

  export type ScheduledRideUpdateWithWhereUniqueWithoutDriverInput = {
    where: ScheduledRideWhereUniqueInput
    data: XOR<ScheduledRideUpdateWithoutDriverInput, ScheduledRideUncheckedUpdateWithoutDriverInput>
  }

  export type ScheduledRideUpdateManyWithWhereWithoutDriverInput = {
    where: ScheduledRideScalarWhereInput
    data: XOR<ScheduledRideUpdateManyMutationInput, ScheduledRideUncheckedUpdateManyWithoutDriverInput>
  }

  export type ScheduledRideScalarWhereInput = {
    AND?: ScheduledRideScalarWhereInput | ScheduledRideScalarWhereInput[]
    OR?: ScheduledRideScalarWhereInput[]
    NOT?: ScheduledRideScalarWhereInput | ScheduledRideScalarWhereInput[]
    id?: StringFilter<"ScheduledRide"> | string
    origin?: StringFilter<"ScheduledRide"> | string
    destination?: StringFilter<"ScheduledRide"> | string
    fromCity?: StringFilter<"ScheduledRide"> | string
    toCity?: StringFilter<"ScheduledRide"> | string
    originLat?: FloatFilter<"ScheduledRide"> | number
    originLng?: FloatFilter<"ScheduledRide"> | number
    destinationLat?: FloatFilter<"ScheduledRide"> | number
    destinationLng?: FloatFilter<"ScheduledRide"> | number
    seats?: IntFilter<"ScheduledRide"> | number
    price?: FloatFilter<"ScheduledRide"> | number
    scheduleTime?: StringFilter<"ScheduledRide"> | string
    daysOfWeek?: IntNullableListFilter<"ScheduledRide">
    isActive?: BoolFilter<"ScheduledRide"> | boolean
    driverId?: StringFilter<"ScheduledRide"> | string
    createdAt?: DateTimeFilter<"ScheduledRide"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledRide"> | Date | string
    fromSuburb?: StringNullableFilter<"ScheduledRide"> | string | null
    toSuburb?: StringNullableFilter<"ScheduledRide"> | string | null
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: StringFilter<"UserBadge"> | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    earnedAt?: DateTimeNullableFilter<"UserBadge"> | Date | string | null
    lostAt?: DateTimeNullableFilter<"UserBadge"> | Date | string | null
    progress?: FloatFilter<"UserBadge"> | number
  }

  export type UserStatsUpsertWithoutUserInput = {
    update: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
    create: XOR<UserStatsCreateWithoutUserInput, UserStatsUncheckedCreateWithoutUserInput>
    where?: UserStatsWhereInput
  }

  export type UserStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserStatsWhereInput
    data: XOR<UserStatsUpdateWithoutUserInput, UserStatsUncheckedUpdateWithoutUserInput>
  }

  export type UserStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    onTimeStarts?: IntFieldUpdateOperationsInput | number
    onTimeArrivals?: IntFieldUpdateOperationsInput | number
    totalChatMessages?: IntFieldUpdateOperationsInput | number
    fastResponses?: IntFieldUpdateOperationsInput | number
    totalBookingsToAccept?: IntFieldUpdateOperationsInput | number
    acceptedBookings?: IntFieldUpdateOperationsInput | number
    totalCancellations?: IntFieldUpdateOperationsInput | number
    totalRidesAsDriver?: IntFieldUpdateOperationsInput | number
    totalRidesAsPassenger?: IntFieldUpdateOperationsInput | number
    completedFreeRidesAsDriver?: IntFieldUpdateOperationsInput | number
    fastResponseOpportunities?: IntFieldUpdateOperationsInput | number
    fastResponseSuccesses?: IntFieldUpdateOperationsInput | number
  }

  export type UserStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    onTimeStarts?: IntFieldUpdateOperationsInput | number
    onTimeArrivals?: IntFieldUpdateOperationsInput | number
    totalChatMessages?: IntFieldUpdateOperationsInput | number
    fastResponses?: IntFieldUpdateOperationsInput | number
    totalBookingsToAccept?: IntFieldUpdateOperationsInput | number
    acceptedBookings?: IntFieldUpdateOperationsInput | number
    totalCancellations?: IntFieldUpdateOperationsInput | number
    totalRidesAsDriver?: IntFieldUpdateOperationsInput | number
    totalRidesAsPassenger?: IntFieldUpdateOperationsInput | number
    completedFreeRidesAsDriver?: IntFieldUpdateOperationsInput | number
    fastResponseOpportunities?: IntFieldUpdateOperationsInput | number
    fastResponseSuccesses?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutCarInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCarInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCarInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCarInput, UserUncheckedCreateWithoutCarInput>
  }

  export type CarLicenseHistoryCreateWithoutCarInput = {
    id?: string
    photoUrl: string
    status?: $Enums.VerificationStatus
    notes?: string | null
    createdAt?: Date | string
  }

  export type CarLicenseHistoryUncheckedCreateWithoutCarInput = {
    id?: string
    photoUrl: string
    status?: $Enums.VerificationStatus
    notes?: string | null
    createdAt?: Date | string
  }

  export type CarLicenseHistoryCreateOrConnectWithoutCarInput = {
    where: CarLicenseHistoryWhereUniqueInput
    create: XOR<CarLicenseHistoryCreateWithoutCarInput, CarLicenseHistoryUncheckedCreateWithoutCarInput>
  }

  export type CarLicenseHistoryCreateManyCarInputEnvelope = {
    data: CarLicenseHistoryCreateManyCarInput | CarLicenseHistoryCreateManyCarInput[]
    skipDuplicates?: boolean
  }

  export type RideCreateWithoutCarInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutCarInput = {
    id?: string
    driverId: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutCarInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutCarInput, RideUncheckedCreateWithoutCarInput>
  }

  export type RideCreateManyCarInputEnvelope = {
    data: RideCreateManyCarInput | RideCreateManyCarInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCarInput = {
    update: XOR<UserUpdateWithoutCarInput, UserUncheckedUpdateWithoutCarInput>
    create: XOR<UserCreateWithoutCarInput, UserUncheckedCreateWithoutCarInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCarInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCarInput, UserUncheckedUpdateWithoutCarInput>
  }

  export type UserUpdateWithoutCarInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCarInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CarLicenseHistoryUpsertWithWhereUniqueWithoutCarInput = {
    where: CarLicenseHistoryWhereUniqueInput
    update: XOR<CarLicenseHistoryUpdateWithoutCarInput, CarLicenseHistoryUncheckedUpdateWithoutCarInput>
    create: XOR<CarLicenseHistoryCreateWithoutCarInput, CarLicenseHistoryUncheckedCreateWithoutCarInput>
  }

  export type CarLicenseHistoryUpdateWithWhereUniqueWithoutCarInput = {
    where: CarLicenseHistoryWhereUniqueInput
    data: XOR<CarLicenseHistoryUpdateWithoutCarInput, CarLicenseHistoryUncheckedUpdateWithoutCarInput>
  }

  export type CarLicenseHistoryUpdateManyWithWhereWithoutCarInput = {
    where: CarLicenseHistoryScalarWhereInput
    data: XOR<CarLicenseHistoryUpdateManyMutationInput, CarLicenseHistoryUncheckedUpdateManyWithoutCarInput>
  }

  export type CarLicenseHistoryScalarWhereInput = {
    AND?: CarLicenseHistoryScalarWhereInput | CarLicenseHistoryScalarWhereInput[]
    OR?: CarLicenseHistoryScalarWhereInput[]
    NOT?: CarLicenseHistoryScalarWhereInput | CarLicenseHistoryScalarWhereInput[]
    id?: StringFilter<"CarLicenseHistory"> | string
    photoUrl?: StringFilter<"CarLicenseHistory"> | string
    status?: EnumVerificationStatusFilter<"CarLicenseHistory"> | $Enums.VerificationStatus
    notes?: StringNullableFilter<"CarLicenseHistory"> | string | null
    createdAt?: DateTimeFilter<"CarLicenseHistory"> | Date | string
    carId?: StringFilter<"CarLicenseHistory"> | string
  }

  export type RideUpsertWithWhereUniqueWithoutCarInput = {
    where: RideWhereUniqueInput
    update: XOR<RideUpdateWithoutCarInput, RideUncheckedUpdateWithoutCarInput>
    create: XOR<RideCreateWithoutCarInput, RideUncheckedCreateWithoutCarInput>
  }

  export type RideUpdateWithWhereUniqueWithoutCarInput = {
    where: RideWhereUniqueInput
    data: XOR<RideUpdateWithoutCarInput, RideUncheckedUpdateWithoutCarInput>
  }

  export type RideUpdateManyWithWhereWithoutCarInput = {
    where: RideScalarWhereInput
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyWithoutCarInput>
  }

  export type CarCreateWithoutLicenseHistoryInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    user: UserCreateNestedOneWithoutCarInput
    rides?: RideCreateNestedManyWithoutCarInput
  }

  export type CarUncheckedCreateWithoutLicenseHistoryInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    userId: string
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    rides?: RideUncheckedCreateNestedManyWithoutCarInput
  }

  export type CarCreateOrConnectWithoutLicenseHistoryInput = {
    where: CarWhereUniqueInput
    create: XOR<CarCreateWithoutLicenseHistoryInput, CarUncheckedCreateWithoutLicenseHistoryInput>
  }

  export type CarUpsertWithoutLicenseHistoryInput = {
    update: XOR<CarUpdateWithoutLicenseHistoryInput, CarUncheckedUpdateWithoutLicenseHistoryInput>
    create: XOR<CarCreateWithoutLicenseHistoryInput, CarUncheckedCreateWithoutLicenseHistoryInput>
    where?: CarWhereInput
  }

  export type CarUpdateToOneWithWhereWithoutLicenseHistoryInput = {
    where?: CarWhereInput
    data: XOR<CarUpdateWithoutLicenseHistoryInput, CarUncheckedUpdateWithoutLicenseHistoryInput>
  }

  export type CarUpdateWithoutLicenseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCarNestedInput
    rides?: RideUpdateManyWithoutCarNestedInput
  }

  export type CarUncheckedUpdateWithoutLicenseHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rides?: RideUncheckedUpdateManyWithoutCarNestedInput
  }

  export type BookingCreateWithoutRideInput = {
    id?: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitation?: GroupBookingInvitationCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    chatMember?: ChatMemberCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutRideInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitationId?: string | null
    chatMember?: ChatMemberUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutRideInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutRideInput, BookingUncheckedCreateWithoutRideInput>
  }

  export type BookingCreateManyRideInputEnvelope = {
    data: BookingCreateManyRideInput | BookingCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutRideInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    members?: ChatMemberCreateNestedManyWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutRideInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    members?: ChatMemberUncheckedCreateNestedManyWithoutChatInput
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutRideInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutRideInput, ChatUncheckedCreateWithoutRideInput>
  }

  export type FeedbackCreateWithoutRideInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
    givenBy: UserCreateNestedOneWithoutFeedbacksGivenInput
    receivedBy: UserCreateNestedOneWithoutFeedbacksReceivedInput
  }

  export type FeedbackUncheckedCreateWithoutRideInput = {
    id?: string
    rating: number
    comment?: string | null
    givenById: string
    receivedById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type FeedbackCreateOrConnectWithoutRideInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutRideInput, FeedbackUncheckedCreateWithoutRideInput>
  }

  export type FeedbackCreateManyRideInputEnvelope = {
    data: FeedbackCreateManyRideInput | FeedbackCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type OfferCreateWithoutRideInput = {
    id?: string
    price: number
    createdAt?: Date | string
    status?: $Enums.OfferStatus
    user: UserCreateNestedOneWithoutOffersInput
  }

  export type OfferUncheckedCreateWithoutRideInput = {
    id?: string
    price: number
    userId: string
    createdAt?: Date | string
    status?: $Enums.OfferStatus
  }

  export type OfferCreateOrConnectWithoutRideInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutRideInput, OfferUncheckedCreateWithoutRideInput>
  }

  export type OfferCreateManyRideInputEnvelope = {
    data: OfferCreateManyRideInput | OfferCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutRideInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
    reporter: UserCreateNestedOneWithoutReportsMadeInput
  }

  export type ReportUncheckedCreateWithoutRideInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    reporterId: string
    reportedUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutRideInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutRideInput, ReportUncheckedCreateWithoutRideInput>
  }

  export type ReportCreateManyRideInputEnvelope = {
    data: ReportCreateManyRideInput | ReportCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type CarCreateWithoutRidesInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    user: UserCreateNestedOneWithoutCarInput
    licenseHistory?: CarLicenseHistoryCreateNestedManyWithoutCarInput
  }

  export type CarUncheckedCreateWithoutRidesInput = {
    id?: string
    brand: string
    model: string
    year: number
    color: string
    plate: string
    licensePhoto?: string | null
    isVerified?: boolean
    userId: string
    createdAt?: Date | string
    verificationStatus?: $Enums.VerificationStatus
    licenseExpiryDate?: Date | string | null
    licenseHistory?: CarLicenseHistoryUncheckedCreateNestedManyWithoutCarInput
  }

  export type CarCreateOrConnectWithoutRidesInput = {
    where: CarWhereUniqueInput
    create: XOR<CarCreateWithoutRidesInput, CarUncheckedCreateWithoutRidesInput>
  }

  export type UserCreateWithoutRidesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRidesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRidesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRidesInput, UserUncheckedCreateWithoutRidesInput>
  }

  export type RideCommentCreateWithoutRideInput = {
    id?: string
    content: string
    createdAt?: Date | string
    parent?: RideCommentCreateNestedOneWithoutRepliesInput
    replies?: RideCommentCreateNestedManyWithoutParentInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type RideCommentUncheckedCreateWithoutRideInput = {
    id?: string
    content: string
    createdAt?: Date | string
    userId: string
    parentId?: string | null
    replies?: RideCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type RideCommentCreateOrConnectWithoutRideInput = {
    where: RideCommentWhereUniqueInput
    create: XOR<RideCommentCreateWithoutRideInput, RideCommentUncheckedCreateWithoutRideInput>
  }

  export type RideCommentCreateManyRideInputEnvelope = {
    data: RideCommentCreateManyRideInput | RideCommentCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledRideCreateWithoutCreatedRidesInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
    driver: UserCreateNestedOneWithoutScheduledRidesInput
  }

  export type ScheduledRideUncheckedCreateWithoutCreatedRidesInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    driverId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
  }

  export type ScheduledRideCreateOrConnectWithoutCreatedRidesInput = {
    where: ScheduledRideWhereUniqueInput
    create: XOR<ScheduledRideCreateWithoutCreatedRidesInput, ScheduledRideUncheckedCreateWithoutCreatedRidesInput>
  }

  export type RideInterestCreateWithoutRideInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInterestsInput
  }

  export type RideInterestUncheckedCreateWithoutRideInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type RideInterestCreateOrConnectWithoutRideInput = {
    where: RideInterestWhereUniqueInput
    create: XOR<RideInterestCreateWithoutRideInput, RideInterestUncheckedCreateWithoutRideInput>
  }

  export type RideInterestCreateManyRideInputEnvelope = {
    data: RideInterestCreateManyRideInput | RideInterestCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type GroupBookingInvitationCreateWithoutRideInput = {
    id?: string
    seats: number
    expiresAt: Date | string
    status?: string
    bookings?: BookingCreateNestedManyWithoutInvitationInput
    initiator: UserCreateNestedOneWithoutInitiatedInvitationsInput
  }

  export type GroupBookingInvitationUncheckedCreateWithoutRideInput = {
    id?: string
    initiatorId: string
    seats: number
    expiresAt: Date | string
    status?: string
    bookings?: BookingUncheckedCreateNestedManyWithoutInvitationInput
  }

  export type GroupBookingInvitationCreateOrConnectWithoutRideInput = {
    where: GroupBookingInvitationWhereUniqueInput
    create: XOR<GroupBookingInvitationCreateWithoutRideInput, GroupBookingInvitationUncheckedCreateWithoutRideInput>
  }

  export type GroupBookingInvitationCreateManyRideInputEnvelope = {
    data: GroupBookingInvitationCreateManyRideInput | GroupBookingInvitationCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutRideInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutRideInput, BookingUncheckedUpdateWithoutRideInput>
    create: XOR<BookingCreateWithoutRideInput, BookingUncheckedCreateWithoutRideInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutRideInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutRideInput, BookingUncheckedUpdateWithoutRideInput>
  }

  export type BookingUpdateManyWithWhereWithoutRideInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutRideInput>
  }

  export type ChatUpsertWithoutRideInput = {
    update: XOR<ChatUpdateWithoutRideInput, ChatUncheckedUpdateWithoutRideInput>
    create: XOR<ChatCreateWithoutRideInput, ChatUncheckedCreateWithoutRideInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutRideInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutRideInput, ChatUncheckedUpdateWithoutRideInput>
  }

  export type ChatUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUpdateManyWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUncheckedUpdateManyWithoutChatNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type FeedbackUpsertWithWhereUniqueWithoutRideInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutRideInput, FeedbackUncheckedUpdateWithoutRideInput>
    create: XOR<FeedbackCreateWithoutRideInput, FeedbackUncheckedCreateWithoutRideInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutRideInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutRideInput, FeedbackUncheckedUpdateWithoutRideInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutRideInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutRideInput>
  }

  export type OfferUpsertWithWhereUniqueWithoutRideInput = {
    where: OfferWhereUniqueInput
    update: XOR<OfferUpdateWithoutRideInput, OfferUncheckedUpdateWithoutRideInput>
    create: XOR<OfferCreateWithoutRideInput, OfferUncheckedCreateWithoutRideInput>
  }

  export type OfferUpdateWithWhereUniqueWithoutRideInput = {
    where: OfferWhereUniqueInput
    data: XOR<OfferUpdateWithoutRideInput, OfferUncheckedUpdateWithoutRideInput>
  }

  export type OfferUpdateManyWithWhereWithoutRideInput = {
    where: OfferScalarWhereInput
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyWithoutRideInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutRideInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutRideInput, ReportUncheckedUpdateWithoutRideInput>
    create: XOR<ReportCreateWithoutRideInput, ReportUncheckedCreateWithoutRideInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutRideInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutRideInput, ReportUncheckedUpdateWithoutRideInput>
  }

  export type ReportUpdateManyWithWhereWithoutRideInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutRideInput>
  }

  export type CarUpsertWithoutRidesInput = {
    update: XOR<CarUpdateWithoutRidesInput, CarUncheckedUpdateWithoutRidesInput>
    create: XOR<CarCreateWithoutRidesInput, CarUncheckedCreateWithoutRidesInput>
    where?: CarWhereInput
  }

  export type CarUpdateToOneWithWhereWithoutRidesInput = {
    where?: CarWhereInput
    data: XOR<CarUpdateWithoutRidesInput, CarUncheckedUpdateWithoutRidesInput>
  }

  export type CarUpdateWithoutRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutCarNestedInput
    licenseHistory?: CarLicenseHistoryUpdateManyWithoutCarNestedInput
  }

  export type CarUncheckedUpdateWithoutRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    plate?: StringFieldUpdateOperationsInput | string
    licensePhoto?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    licenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    licenseHistory?: CarLicenseHistoryUncheckedUpdateManyWithoutCarNestedInput
  }

  export type UserUpsertWithoutRidesInput = {
    update: XOR<UserUpdateWithoutRidesInput, UserUncheckedUpdateWithoutRidesInput>
    create: XOR<UserCreateWithoutRidesInput, UserUncheckedCreateWithoutRidesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRidesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRidesInput, UserUncheckedUpdateWithoutRidesInput>
  }

  export type UserUpdateWithoutRidesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRidesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RideCommentUpsertWithWhereUniqueWithoutRideInput = {
    where: RideCommentWhereUniqueInput
    update: XOR<RideCommentUpdateWithoutRideInput, RideCommentUncheckedUpdateWithoutRideInput>
    create: XOR<RideCommentCreateWithoutRideInput, RideCommentUncheckedCreateWithoutRideInput>
  }

  export type RideCommentUpdateWithWhereUniqueWithoutRideInput = {
    where: RideCommentWhereUniqueInput
    data: XOR<RideCommentUpdateWithoutRideInput, RideCommentUncheckedUpdateWithoutRideInput>
  }

  export type RideCommentUpdateManyWithWhereWithoutRideInput = {
    where: RideCommentScalarWhereInput
    data: XOR<RideCommentUpdateManyMutationInput, RideCommentUncheckedUpdateManyWithoutRideInput>
  }

  export type ScheduledRideUpsertWithoutCreatedRidesInput = {
    update: XOR<ScheduledRideUpdateWithoutCreatedRidesInput, ScheduledRideUncheckedUpdateWithoutCreatedRidesInput>
    create: XOR<ScheduledRideCreateWithoutCreatedRidesInput, ScheduledRideUncheckedCreateWithoutCreatedRidesInput>
    where?: ScheduledRideWhereInput
  }

  export type ScheduledRideUpdateToOneWithWhereWithoutCreatedRidesInput = {
    where?: ScheduledRideWhereInput
    data: XOR<ScheduledRideUpdateWithoutCreatedRidesInput, ScheduledRideUncheckedUpdateWithoutCreatedRidesInput>
  }

  export type ScheduledRideUpdateWithoutCreatedRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    driver?: UserUpdateOneRequiredWithoutScheduledRidesNestedInput
  }

  export type ScheduledRideUncheckedUpdateWithoutCreatedRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    driverId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideInterestUpsertWithWhereUniqueWithoutRideInput = {
    where: RideInterestWhereUniqueInput
    update: XOR<RideInterestUpdateWithoutRideInput, RideInterestUncheckedUpdateWithoutRideInput>
    create: XOR<RideInterestCreateWithoutRideInput, RideInterestUncheckedCreateWithoutRideInput>
  }

  export type RideInterestUpdateWithWhereUniqueWithoutRideInput = {
    where: RideInterestWhereUniqueInput
    data: XOR<RideInterestUpdateWithoutRideInput, RideInterestUncheckedUpdateWithoutRideInput>
  }

  export type RideInterestUpdateManyWithWhereWithoutRideInput = {
    where: RideInterestScalarWhereInput
    data: XOR<RideInterestUpdateManyMutationInput, RideInterestUncheckedUpdateManyWithoutRideInput>
  }

  export type GroupBookingInvitationUpsertWithWhereUniqueWithoutRideInput = {
    where: GroupBookingInvitationWhereUniqueInput
    update: XOR<GroupBookingInvitationUpdateWithoutRideInput, GroupBookingInvitationUncheckedUpdateWithoutRideInput>
    create: XOR<GroupBookingInvitationCreateWithoutRideInput, GroupBookingInvitationUncheckedCreateWithoutRideInput>
  }

  export type GroupBookingInvitationUpdateWithWhereUniqueWithoutRideInput = {
    where: GroupBookingInvitationWhereUniqueInput
    data: XOR<GroupBookingInvitationUpdateWithoutRideInput, GroupBookingInvitationUncheckedUpdateWithoutRideInput>
  }

  export type GroupBookingInvitationUpdateManyWithWhereWithoutRideInput = {
    where: GroupBookingInvitationScalarWhereInput
    data: XOR<GroupBookingInvitationUpdateManyMutationInput, GroupBookingInvitationUncheckedUpdateManyWithoutRideInput>
  }

  export type RideCreateWithoutInterestsInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutInterestsInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutInterestsInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutInterestsInput, RideUncheckedCreateWithoutInterestsInput>
  }

  export type UserCreateWithoutInterestsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterestsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
  }

  export type RideUpsertWithoutInterestsInput = {
    update: XOR<RideUpdateWithoutInterestsInput, RideUncheckedUpdateWithoutInterestsInput>
    create: XOR<RideCreateWithoutInterestsInput, RideUncheckedCreateWithoutInterestsInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutInterestsInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutInterestsInput, RideUncheckedUpdateWithoutInterestsInput>
  }

  export type RideUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type UserUpsertWithoutInterestsInput = {
    update: XOR<UserUpdateWithoutInterestsInput, UserUncheckedUpdateWithoutInterestsInput>
    create: XOR<UserCreateWithoutInterestsInput, UserUncheckedCreateWithoutInterestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterestsInput, UserUncheckedUpdateWithoutInterestsInput>
  }

  export type UserUpdateWithoutInterestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type GroupBookingInvitationCreateWithoutBookingsInput = {
    id?: string
    seats: number
    expiresAt: Date | string
    status?: string
    ride: RideCreateNestedOneWithoutGroupInvitationsInput
    initiator: UserCreateNestedOneWithoutInitiatedInvitationsInput
  }

  export type GroupBookingInvitationUncheckedCreateWithoutBookingsInput = {
    id?: string
    rideId: string
    initiatorId: string
    seats: number
    expiresAt: Date | string
    status?: string
  }

  export type GroupBookingInvitationCreateOrConnectWithoutBookingsInput = {
    where: GroupBookingInvitationWhereUniqueInput
    create: XOR<GroupBookingInvitationCreateWithoutBookingsInput, GroupBookingInvitationUncheckedCreateWithoutBookingsInput>
  }

  export type RideCreateWithoutBookingsInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutBookingsInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutBookingsInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutBookingsInput, RideUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type ChatMemberCreateWithoutBookingInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutChatsInput
  }

  export type ChatMemberUncheckedCreateWithoutBookingInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    chatId: string
    userId: string
    createdAt?: Date | string
  }

  export type ChatMemberCreateOrConnectWithoutBookingInput = {
    where: ChatMemberWhereUniqueInput
    create: XOR<ChatMemberCreateWithoutBookingInput, ChatMemberUncheckedCreateWithoutBookingInput>
  }

  export type GroupBookingInvitationUpsertWithoutBookingsInput = {
    update: XOR<GroupBookingInvitationUpdateWithoutBookingsInput, GroupBookingInvitationUncheckedUpdateWithoutBookingsInput>
    create: XOR<GroupBookingInvitationCreateWithoutBookingsInput, GroupBookingInvitationUncheckedCreateWithoutBookingsInput>
    where?: GroupBookingInvitationWhereInput
  }

  export type GroupBookingInvitationUpdateToOneWithWhereWithoutBookingsInput = {
    where?: GroupBookingInvitationWhereInput
    data: XOR<GroupBookingInvitationUpdateWithoutBookingsInput, GroupBookingInvitationUncheckedUpdateWithoutBookingsInput>
  }

  export type GroupBookingInvitationUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    ride?: RideUpdateOneRequiredWithoutGroupInvitationsNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedInvitationsNestedInput
  }

  export type GroupBookingInvitationUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RideUpsertWithoutBookingsInput = {
    update: XOR<RideUpdateWithoutBookingsInput, RideUncheckedUpdateWithoutBookingsInput>
    create: XOR<RideCreateWithoutBookingsInput, RideUncheckedCreateWithoutBookingsInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutBookingsInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutBookingsInput, RideUncheckedUpdateWithoutBookingsInput>
  }

  export type RideUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ChatMemberUpsertWithoutBookingInput = {
    update: XOR<ChatMemberUpdateWithoutBookingInput, ChatMemberUncheckedUpdateWithoutBookingInput>
    create: XOR<ChatMemberCreateWithoutBookingInput, ChatMemberUncheckedCreateWithoutBookingInput>
    where?: ChatMemberWhereInput
  }

  export type ChatMemberUpdateToOneWithWhereWithoutBookingInput = {
    where?: ChatMemberWhereInput
    data: XOR<ChatMemberUpdateWithoutBookingInput, ChatMemberUncheckedUpdateWithoutBookingInput>
  }

  export type ChatMemberUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatMemberUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCreateWithoutOffersInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutOffersInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutOffersInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutOffersInput, RideUncheckedCreateWithoutOffersInput>
  }

  export type UserCreateWithoutOffersInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOffersInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOffersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
  }

  export type RideUpsertWithoutOffersInput = {
    update: XOR<RideUpdateWithoutOffersInput, RideUncheckedUpdateWithoutOffersInput>
    create: XOR<RideCreateWithoutOffersInput, RideUncheckedCreateWithoutOffersInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutOffersInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutOffersInput, RideUncheckedUpdateWithoutOffersInput>
  }

  export type RideUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type UserUpsertWithoutOffersInput = {
    update: XOR<UserUpdateWithoutOffersInput, UserUncheckedUpdateWithoutOffersInput>
    create: XOR<UserCreateWithoutOffersInput, UserUncheckedCreateWithoutOffersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOffersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOffersInput, UserUncheckedUpdateWithoutOffersInput>
  }

  export type UserUpdateWithoutOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOffersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RideCreateWithoutChatInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutChatInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutChatInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutChatInput, RideUncheckedCreateWithoutChatInput>
  }

  export type ChatMemberCreateWithoutChatInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    createdAt?: Date | string
    booking?: BookingCreateNestedOneWithoutChatMemberInput
    user: UserCreateNestedOneWithoutChatsInput
  }

  export type ChatMemberUncheckedCreateWithoutChatInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    userId: string
    bookingId?: string | null
    createdAt?: Date | string
  }

  export type ChatMemberCreateOrConnectWithoutChatInput = {
    where: ChatMemberWhereUniqueInput
    create: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput>
  }

  export type ChatMemberCreateManyChatInputEnvelope = {
    data: ChatMemberCreateManyChatInput | ChatMemberCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutChatInput = {
    id?: string
    content: string
    type?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutChatInput = {
    id?: string
    content: string
    type?: string
    userId: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutChatInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageCreateManyChatInputEnvelope = {
    data: MessageCreateManyChatInput | MessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type RideUpsertWithoutChatInput = {
    update: XOR<RideUpdateWithoutChatInput, RideUncheckedUpdateWithoutChatInput>
    create: XOR<RideCreateWithoutChatInput, RideUncheckedCreateWithoutChatInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutChatInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutChatInput, RideUncheckedUpdateWithoutChatInput>
  }

  export type RideUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type ChatMemberUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatMemberWhereUniqueInput
    update: XOR<ChatMemberUpdateWithoutChatInput, ChatMemberUncheckedUpdateWithoutChatInput>
    create: XOR<ChatMemberCreateWithoutChatInput, ChatMemberUncheckedCreateWithoutChatInput>
  }

  export type ChatMemberUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatMemberWhereUniqueInput
    data: XOR<ChatMemberUpdateWithoutChatInput, ChatMemberUncheckedUpdateWithoutChatInput>
  }

  export type ChatMemberUpdateManyWithWhereWithoutChatInput = {
    where: ChatMemberScalarWhereInput
    data: XOR<ChatMemberUpdateManyMutationInput, ChatMemberUncheckedUpdateManyWithoutChatInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
    create: XOR<MessageCreateWithoutChatInput, MessageUncheckedCreateWithoutChatInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChatInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChatInput, MessageUncheckedUpdateWithoutChatInput>
  }

  export type MessageUpdateManyWithWhereWithoutChatInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChatInput>
  }

  export type BookingCreateWithoutChatMemberInput = {
    id?: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitation?: GroupBookingInvitationCreateNestedOneWithoutBookingsInput
    ride: RideCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutChatMemberInput = {
    id?: string
    rideId: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitationId?: string | null
  }

  export type BookingCreateOrConnectWithoutChatMemberInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutChatMemberInput, BookingUncheckedCreateWithoutChatMemberInput>
  }

  export type ChatCreateWithoutMembersInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    ride?: RideCreateNestedOneWithoutChatInput
    messages?: MessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMembersInput = {
    id?: string
    rideId?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutMembersInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutChatsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
  }

  export type BookingUpsertWithoutChatMemberInput = {
    update: XOR<BookingUpdateWithoutChatMemberInput, BookingUncheckedUpdateWithoutChatMemberInput>
    create: XOR<BookingCreateWithoutChatMemberInput, BookingUncheckedCreateWithoutChatMemberInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutChatMemberInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutChatMemberInput, BookingUncheckedUpdateWithoutChatMemberInput>
  }

  export type BookingUpdateWithoutChatMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitation?: GroupBookingInvitationUpdateOneWithoutBookingsNestedInput
    ride?: RideUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutChatMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatUpsertWithoutMembersInput = {
    update: XOR<ChatUpdateWithoutMembersInput, ChatUncheckedUpdateWithoutMembersInput>
    create: XOR<ChatCreateWithoutMembersInput, ChatUncheckedCreateWithoutMembersInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMembersInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMembersInput, ChatUncheckedUpdateWithoutMembersInput>
  }

  export type ChatUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: RideUpdateOneWithoutChatNestedInput
    messages?: MessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type UserUpsertWithoutChatsInput = {
    update: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateWithoutChatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    ride?: RideCreateNestedOneWithoutChatInput
    members?: ChatMemberCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    rideId?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    members?: ChatMemberUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: RideUpdateOneWithoutChatNestedInput
    members?: ChatMemberUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ChatMemberUncheckedUpdateManyWithoutChatNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedbacksGivenInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksGivenInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksGivenInput, UserUncheckedCreateWithoutFeedbacksGivenInput>
  }

  export type UserCreateWithoutFeedbacksReceivedInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedbacksReceivedInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedbacksReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksReceivedInput, UserUncheckedCreateWithoutFeedbacksReceivedInput>
  }

  export type RideCreateWithoutFeedbacksInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutFeedbacksInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutFeedbacksInput, RideUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserUpsertWithoutFeedbacksGivenInput = {
    update: XOR<UserUpdateWithoutFeedbacksGivenInput, UserUncheckedUpdateWithoutFeedbacksGivenInput>
    create: XOR<UserCreateWithoutFeedbacksGivenInput, UserUncheckedCreateWithoutFeedbacksGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksGivenInput, UserUncheckedUpdateWithoutFeedbacksGivenInput>
  }

  export type UserUpdateWithoutFeedbacksGivenInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksGivenInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutFeedbacksReceivedInput = {
    update: XOR<UserUpdateWithoutFeedbacksReceivedInput, UserUncheckedUpdateWithoutFeedbacksReceivedInput>
    create: XOR<UserCreateWithoutFeedbacksReceivedInput, UserUncheckedCreateWithoutFeedbacksReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksReceivedInput, UserUncheckedUpdateWithoutFeedbacksReceivedInput>
  }

  export type UserUpdateWithoutFeedbacksReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RideUpsertWithoutFeedbacksInput = {
    update: XOR<RideUpdateWithoutFeedbacksInput, RideUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<RideCreateWithoutFeedbacksInput, RideUncheckedCreateWithoutFeedbacksInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutFeedbacksInput, RideUncheckedUpdateWithoutFeedbacksInput>
  }

  export type RideUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    id?: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type BadgeCreateWithoutUsersInput = {
    id?: string
    name: string
    icon: string
    createdAt?: Date | string
    description: string
    threshold: number
  }

  export type BadgeUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    icon: string
    createdAt?: Date | string
    description: string
    threshold: number
  }

  export type BadgeCreateOrConnectWithoutUsersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutBadgesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeUpsertWithoutUsersInput = {
    update: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutUsersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type BadgeUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
  }

  export type BadgeUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    threshold?: FloatFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutReferralReceivedInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralReceivedInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralReceivedInput, UserUncheckedCreateWithoutReferralReceivedInput>
  }

  export type UserCreateWithoutReferralsMadeInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsMadeInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
  }

  export type UserUpsertWithoutReferralReceivedInput = {
    update: XOR<UserUpdateWithoutReferralReceivedInput, UserUncheckedUpdateWithoutReferralReceivedInput>
    create: XOR<UserCreateWithoutReferralReceivedInput, UserUncheckedCreateWithoutReferralReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralReceivedInput, UserUncheckedUpdateWithoutReferralReceivedInput>
  }

  export type UserUpdateWithoutReferralReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutReferralsMadeInput = {
    update: XOR<UserUpdateWithoutReferralsMadeInput, UserUncheckedUpdateWithoutReferralsMadeInput>
    create: XOR<UserCreateWithoutReferralsMadeInput, UserUncheckedCreateWithoutReferralsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsMadeInput, UserUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type UserUpdateWithoutReferralsMadeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsMadeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutStatsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStatsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
  }

  export type UserUpsertWithoutStatsInput = {
    update: XOR<UserUpdateWithoutStatsInput, UserUncheckedUpdateWithoutStatsInput>
    create: XOR<UserCreateWithoutStatsInput, UserUncheckedCreateWithoutStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatsInput, UserUncheckedUpdateWithoutStatsInput>
  }

  export type UserUpdateWithoutStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStatsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPromoCodesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPromoCodesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPromoCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPromoCodesInput, UserUncheckedCreateWithoutPromoCodesInput>
  }

  export type UserUpsertWithoutPromoCodesInput = {
    update: XOR<UserUpdateWithoutPromoCodesInput, UserUncheckedUpdateWithoutPromoCodesInput>
    create: XOR<UserCreateWithoutPromoCodesInput, UserUncheckedCreateWithoutPromoCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPromoCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPromoCodesInput, UserUncheckedUpdateWithoutPromoCodesInput>
  }

  export type UserUpdateWithoutPromoCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPromoCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutReportsReceivedInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsReceivedInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
  }

  export type UserCreateWithoutReportsMadeInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsMadeInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
  }

  export type RideCreateWithoutReportsInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutReportsInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutReportsInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutReportsInput, RideUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutReportsReceivedInput = {
    update: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type UserUpdateWithoutReportsReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsReceivedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutReportsMadeInput = {
    update: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
  }

  export type UserUpdateWithoutReportsMadeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsMadeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RideUpsertWithoutReportsInput = {
    update: XOR<RideUpdateWithoutReportsInput, RideUncheckedUpdateWithoutReportsInput>
    create: XOR<RideCreateWithoutReportsInput, RideUncheckedCreateWithoutReportsInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutReportsInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutReportsInput, RideUncheckedUpdateWithoutReportsInput>
  }

  export type RideUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type UserCreateWithoutLastVisitsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLastVisitsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLastVisitsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLastVisitsInput, UserUncheckedCreateWithoutLastVisitsInput>
  }

  export type UserUpsertWithoutLastVisitsInput = {
    update: XOR<UserUpdateWithoutLastVisitsInput, UserUncheckedUpdateWithoutLastVisitsInput>
    create: XOR<UserCreateWithoutLastVisitsInput, UserUncheckedCreateWithoutLastVisitsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLastVisitsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLastVisitsInput, UserUncheckedUpdateWithoutLastVisitsInput>
  }

  export type UserUpdateWithoutLastVisitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLastVisitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSavedRoutesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedRoutesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedRoutesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedRoutesInput, UserUncheckedCreateWithoutSavedRoutesInput>
  }

  export type UserUpsertWithoutSavedRoutesInput = {
    update: XOR<UserUpdateWithoutSavedRoutesInput, UserUncheckedUpdateWithoutSavedRoutesInput>
    create: XOR<UserCreateWithoutSavedRoutesInput, UserUncheckedCreateWithoutSavedRoutesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedRoutesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedRoutesInput, UserUncheckedUpdateWithoutSavedRoutesInput>
  }

  export type UserUpdateWithoutSavedRoutesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedRoutesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutScheduledRidesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScheduledRidesInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScheduledRidesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduledRidesInput, UserUncheckedCreateWithoutScheduledRidesInput>
  }

  export type RideCreateWithoutScheduledRideInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutScheduledRideInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutScheduledRideInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutScheduledRideInput, RideUncheckedCreateWithoutScheduledRideInput>
  }

  export type RideCreateManyScheduledRideInputEnvelope = {
    data: RideCreateManyScheduledRideInput | RideCreateManyScheduledRideInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutScheduledRidesInput = {
    update: XOR<UserUpdateWithoutScheduledRidesInput, UserUncheckedUpdateWithoutScheduledRidesInput>
    create: XOR<UserCreateWithoutScheduledRidesInput, UserUncheckedCreateWithoutScheduledRidesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduledRidesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduledRidesInput, UserUncheckedUpdateWithoutScheduledRidesInput>
  }

  export type UserUpdateWithoutScheduledRidesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduledRidesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RideUpsertWithWhereUniqueWithoutScheduledRideInput = {
    where: RideWhereUniqueInput
    update: XOR<RideUpdateWithoutScheduledRideInput, RideUncheckedUpdateWithoutScheduledRideInput>
    create: XOR<RideCreateWithoutScheduledRideInput, RideUncheckedCreateWithoutScheduledRideInput>
  }

  export type RideUpdateWithWhereUniqueWithoutScheduledRideInput = {
    where: RideWhereUniqueInput
    data: XOR<RideUpdateWithoutScheduledRideInput, RideUncheckedUpdateWithoutScheduledRideInput>
  }

  export type RideUpdateManyWithWhereWithoutScheduledRideInput = {
    where: RideScalarWhereInput
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyWithoutScheduledRideInput>
  }

  export type RideCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    parent?: RideCommentCreateNestedOneWithoutRepliesInput
    ride: RideCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type RideCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    rideId: string
    userId: string
    parentId?: string | null
  }

  export type RideCommentCreateOrConnectWithoutRepliesInput = {
    where: RideCommentWhereUniqueInput
    create: XOR<RideCommentCreateWithoutRepliesInput, RideCommentUncheckedCreateWithoutRepliesInput>
  }

  export type RideCommentCreateWithoutParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    replies?: RideCommentCreateNestedManyWithoutParentInput
    ride: RideCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type RideCommentUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    rideId: string
    userId: string
    replies?: RideCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type RideCommentCreateOrConnectWithoutParentInput = {
    where: RideCommentWhereUniqueInput
    create: XOR<RideCommentCreateWithoutParentInput, RideCommentUncheckedCreateWithoutParentInput>
  }

  export type RideCommentCreateManyParentInputEnvelope = {
    data: RideCommentCreateManyParentInput | RideCommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type RideCreateWithoutCommentsInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutCommentsInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
    groupInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutCommentsInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutCommentsInput, RideUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationCreateNestedManyWithoutInitiatorInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    initiatedInvitations?: GroupBookingInvitationUncheckedCreateNestedManyWithoutInitiatorInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type RideCommentUpsertWithoutRepliesInput = {
    update: XOR<RideCommentUpdateWithoutRepliesInput, RideCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<RideCommentCreateWithoutRepliesInput, RideCommentUncheckedCreateWithoutRepliesInput>
    where?: RideCommentWhereInput
  }

  export type RideCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: RideCommentWhereInput
    data: XOR<RideCommentUpdateWithoutRepliesInput, RideCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type RideCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RideCommentUpdateOneWithoutRepliesNestedInput
    ride?: RideUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type RideCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: RideCommentWhereUniqueInput
    update: XOR<RideCommentUpdateWithoutParentInput, RideCommentUncheckedUpdateWithoutParentInput>
    create: XOR<RideCommentCreateWithoutParentInput, RideCommentUncheckedCreateWithoutParentInput>
  }

  export type RideCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: RideCommentWhereUniqueInput
    data: XOR<RideCommentUpdateWithoutParentInput, RideCommentUncheckedUpdateWithoutParentInput>
  }

  export type RideCommentUpdateManyWithWhereWithoutParentInput = {
    where: RideCommentScalarWhereInput
    data: XOR<RideCommentUpdateManyMutationInput, RideCommentUncheckedUpdateManyWithoutParentInput>
  }

  export type RideUpsertWithoutCommentsInput = {
    update: XOR<RideUpdateWithoutCommentsInput, RideUncheckedUpdateWithoutCommentsInput>
    create: XOR<RideCreateWithoutCommentsInput, RideUncheckedCreateWithoutCommentsInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutCommentsInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutCommentsInput, RideUncheckedUpdateWithoutCommentsInput>
  }

  export type RideUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUpdateManyWithoutInitiatorNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    initiatedInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type BookingCreateWithoutInvitationInput = {
    id?: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    ride: RideCreateNestedOneWithoutBookingsInput
    user: UserCreateNestedOneWithoutBookingsInput
    chatMember?: ChatMemberCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutInvitationInput = {
    id?: string
    rideId: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    chatMember?: ChatMemberUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutInvitationInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutInvitationInput, BookingUncheckedCreateWithoutInvitationInput>
  }

  export type BookingCreateManyInvitationInputEnvelope = {
    data: BookingCreateManyInvitationInput | BookingCreateManyInvitationInput[]
    skipDuplicates?: boolean
  }

  export type RideCreateWithoutGroupInvitationsInput = {
    id?: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    bookings?: BookingCreateNestedManyWithoutRideInput
    chat?: ChatCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackCreateNestedManyWithoutRideInput
    offers?: OfferCreateNestedManyWithoutRideInput
    reports?: ReportCreateNestedManyWithoutRideInput
    car?: CarCreateNestedOneWithoutRidesInput
    driver: UserCreateNestedOneWithoutRidesInput
    comments?: RideCommentCreateNestedManyWithoutRideInput
    scheduledRide?: ScheduledRideCreateNestedOneWithoutCreatedRidesInput
    interests?: RideInterestCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutGroupInvitationsInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutRideInput
    chat?: ChatUncheckedCreateNestedOneWithoutRideInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutRideInput
    offers?: OfferUncheckedCreateNestedManyWithoutRideInput
    reports?: ReportUncheckedCreateNestedManyWithoutRideInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutRideInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutGroupInvitationsInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutGroupInvitationsInput, RideUncheckedCreateWithoutGroupInvitationsInput>
  }

  export type UserCreateWithoutInitiatedInvitationsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitCreateNestedManyWithoutAdminInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    car?: CarCreateNestedOneWithoutUserInput
    chats?: ChatMemberCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackCreateNestedManyWithoutReceivedByInput
    messages?: MessageCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    offers?: OfferCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeCreateNestedManyWithoutUserInput
    referralReceived?: ReferralCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    rides?: RideCreateNestedManyWithoutDriverInput
    comments?: RideCommentCreateNestedManyWithoutUserInput
    interests?: RideInterestCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideCreateNestedManyWithoutDriverInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    stats?: UserStatsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInitiatedInvitationsInput = {
    name: string
    email: string
    phone: string
    createdAt?: Date | string
    gender?: string | null
    isVerified?: boolean
    password: string
    updatedAt?: Date | string
    id?: string
    birthDate?: Date | string | null
    city?: string | null
    completedRides?: number
    genderPreference?: string
    rideSearchWindowDays?: number
    isPremium?: boolean
    joinDate?: Date | string
    profileImage?: string | null
    rating?: number
    currentLat?: number | null
    currentLng?: number | null
    drivingLicenseUrl?: string | null
    idBackImageUrl?: string | null
    idFrontImageUrl?: string | null
    autoRenew?: boolean
    darkMode?: boolean
    hasSeenOnboarding?: boolean
    idVerificationStatus?: $Enums.VerificationStatus
    nextFreeRideAt?: Date | string | null
    passwordResetExpires?: Date | string | null
    passwordResetToken?: string | null
    preferredLanguage?: string
    premiumEndDate?: Date | string | null
    premiumStartDate?: Date | string | null
    referralCode?: string | null
    profileImageLocked?: boolean
    role?: string
    emailVerificationExpires?: Date | string | null
    emailVerificationToken?: string | null
    isEmailVerified?: boolean
    hasUsedFreeTrial?: boolean
    isEligibleForReward?: boolean
    referralsCount?: number
    driverLicenseExpiryDate?: Date | string | null
    homeAddress?: string | null
    homeLat?: number | null
    homeLng?: number | null
    workAddress?: string | null
    workLat?: number | null
    workLng?: number | null
    lastVisits?: AdminLastVisitUncheckedCreateNestedManyWithoutAdminInput
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    car?: CarUncheckedCreateNestedOneWithoutUserInput
    chats?: ChatMemberUncheckedCreateNestedManyWithoutUserInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutGivenByInput
    feedbacksReceived?: FeedbackUncheckedCreateNestedManyWithoutReceivedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    offers?: OfferUncheckedCreateNestedManyWithoutUserInput
    promoCodes?: PromoCodeUncheckedCreateNestedManyWithoutUserInput
    referralReceived?: ReferralUncheckedCreateNestedOneWithoutRefereeInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    rides?: RideUncheckedCreateNestedManyWithoutDriverInput
    comments?: RideCommentUncheckedCreateNestedManyWithoutUserInput
    interests?: RideInterestUncheckedCreateNestedManyWithoutUserInput
    savedRoutes?: SavedRouteUncheckedCreateNestedManyWithoutUserInput
    scheduledRides?: ScheduledRideUncheckedCreateNestedManyWithoutDriverInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    stats?: UserStatsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInitiatedInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInitiatedInvitationsInput, UserUncheckedCreateWithoutInitiatedInvitationsInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutInvitationInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutInvitationInput, BookingUncheckedUpdateWithoutInvitationInput>
    create: XOR<BookingCreateWithoutInvitationInput, BookingUncheckedCreateWithoutInvitationInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutInvitationInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutInvitationInput, BookingUncheckedUpdateWithoutInvitationInput>
  }

  export type BookingUpdateManyWithWhereWithoutInvitationInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutInvitationInput>
  }

  export type RideUpsertWithoutGroupInvitationsInput = {
    update: XOR<RideUpdateWithoutGroupInvitationsInput, RideUncheckedUpdateWithoutGroupInvitationsInput>
    create: XOR<RideCreateWithoutGroupInvitationsInput, RideUncheckedCreateWithoutGroupInvitationsInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutGroupInvitationsInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutGroupInvitationsInput, RideUncheckedUpdateWithoutGroupInvitationsInput>
  }

  export type RideUpdateWithoutGroupInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutGroupInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
  }

  export type UserUpsertWithoutInitiatedInvitationsInput = {
    update: XOR<UserUpdateWithoutInitiatedInvitationsInput, UserUncheckedUpdateWithoutInitiatedInvitationsInput>
    create: XOR<UserCreateWithoutInitiatedInvitationsInput, UserUncheckedCreateWithoutInitiatedInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInitiatedInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInitiatedInvitationsInput, UserUncheckedUpdateWithoutInitiatedInvitationsInput>
  }

  export type UserUpdateWithoutInitiatedInvitationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUpdateManyWithoutAdminNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    car?: CarUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    offers?: OfferUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    rides?: RideUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUpdateManyWithoutUserNestedInput
    interests?: RideInterestUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    stats?: UserStatsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInitiatedInvitationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    completedRides?: IntFieldUpdateOperationsInput | number
    genderPreference?: StringFieldUpdateOperationsInput | string
    rideSearchWindowDays?: IntFieldUpdateOperationsInput | number
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: FloatFieldUpdateOperationsInput | number
    currentLat?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLng?: NullableFloatFieldUpdateOperationsInput | number | null
    drivingLicenseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idBackImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    idFrontImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    autoRenew?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    hasSeenOnboarding?: BoolFieldUpdateOperationsInput | boolean
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    nextFreeRideAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    premiumEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    profileImageLocked?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    emailVerificationExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    hasUsedFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    isEligibleForReward?: BoolFieldUpdateOperationsInput | boolean
    referralsCount?: IntFieldUpdateOperationsInput | number
    driverLicenseExpiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homeAddress?: NullableStringFieldUpdateOperationsInput | string | null
    homeLat?: NullableFloatFieldUpdateOperationsInput | number | null
    homeLng?: NullableFloatFieldUpdateOperationsInput | number | null
    workAddress?: NullableStringFieldUpdateOperationsInput | string | null
    workLat?: NullableFloatFieldUpdateOperationsInput | number | null
    workLng?: NullableFloatFieldUpdateOperationsInput | number | null
    lastVisits?: AdminLastVisitUncheckedUpdateManyWithoutAdminNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    car?: CarUncheckedUpdateOneWithoutUserNestedInput
    chats?: ChatMemberUncheckedUpdateManyWithoutUserNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutGivenByNestedInput
    feedbacksReceived?: FeedbackUncheckedUpdateManyWithoutReceivedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    offers?: OfferUncheckedUpdateManyWithoutUserNestedInput
    promoCodes?: PromoCodeUncheckedUpdateManyWithoutUserNestedInput
    referralReceived?: ReferralUncheckedUpdateOneWithoutRefereeNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    rides?: RideUncheckedUpdateManyWithoutDriverNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutUserNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutUserNestedInput
    savedRoutes?: SavedRouteUncheckedUpdateManyWithoutUserNestedInput
    scheduledRides?: ScheduledRideUncheckedUpdateManyWithoutDriverNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    stats?: UserStatsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type AdminLastVisitCreateManyAdminInput = {
    id?: string
    resource: string
    lastVisitedAt?: Date | string
  }

  export type BookingCreateManyUserInput = {
    id?: string
    rideId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitationId?: string | null
  }

  export type GroupBookingInvitationCreateManyInitiatorInput = {
    id?: string
    rideId: string
    seats: number
    expiresAt: Date | string
    status?: string
  }

  export type ChatMemberCreateManyUserInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    chatId: string
    bookingId?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateManyGivenByInput = {
    id?: string
    rating: number
    comment?: string | null
    rideId: string
    receivedById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type FeedbackCreateManyReceivedByInput = {
    id?: string
    rating: number
    comment?: string | null
    rideId: string
    givenById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type MessageCreateManyUserInput = {
    id?: string
    content: string
    type?: string
    chatId: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    isRead?: boolean
    relatedId?: string | null
    createdAt?: Date | string
    bookingStatus?: string | null
  }

  export type OfferCreateManyUserInput = {
    id?: string
    price: number
    rideId: string
    createdAt?: Date | string
    status?: $Enums.OfferStatus
  }

  export type PromoCodeCreateManyUserInput = {
    id?: string
    code: string
    isUsed?: boolean
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    code: string
    refereeId: string
    bonusGiven?: boolean
    createdAt?: Date | string
  }

  export type ReportCreateManyReportedUserInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    rideId: string
    reporterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyReporterInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    rideId: string
    reportedUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideCreateManyDriverInput = {
    id?: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
  }

  export type RideCommentCreateManyUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    rideId: string
    parentId?: string | null
  }

  export type RideInterestCreateManyUserInput = {
    id?: string
    rideId: string
    createdAt?: Date | string
  }

  export type SavedRouteCreateManyUserInput = {
    id?: string
    name: string
    icon?: string | null
    polyline?: string | null
    originAddress: string
    originLat: number
    originLng: number
    originCity?: string | null
    originSuburb?: string | null
    destinationAddress: string
    destinationLat: number
    destinationLng: number
    destinationCity?: string | null
    destinationSuburb?: string | null
    createdAt?: Date | string
  }

  export type ScheduledRideCreateManyDriverInput = {
    id?: string
    origin: string
    destination: string
    fromCity: string
    toCity: string
    originLat: number
    originLng: number
    destinationLat: number
    destinationLng: number
    seats: number
    price: number
    scheduleTime: string
    daysOfWeek?: ScheduledRideCreatedaysOfWeekInput | number[]
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromSuburb?: string | null
    toSuburb?: string | null
  }

  export type UserBadgeCreateManyUserInput = {
    id?: string
    badgeId: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
  }

  export type AdminLastVisitUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    lastVisitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLastVisitUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    lastVisitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminLastVisitUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    lastVisitedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitation?: GroupBookingInvitationUpdateOneWithoutBookingsNestedInput
    ride?: RideUpdateOneRequiredWithoutBookingsNestedInput
    chatMember?: ChatMemberUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
    chatMember?: ChatMemberUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupBookingInvitationUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUpdateManyWithoutInvitationNestedInput
    ride?: RideUpdateOneRequiredWithoutGroupInvitationsNestedInput
  }

  export type GroupBookingInvitationUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type GroupBookingInvitationUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutChatMemberNestedInput
    chat?: ChatUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ChatMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    chatId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutGivenByInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    receivedBy?: UserUpdateOneRequiredWithoutFeedbacksReceivedNestedInput
    ride?: RideUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutGivenByInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeedbackUncheckedUpdateManyWithoutGivenByInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeedbackUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenBy?: UserUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    ride?: RideUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: StringFieldUpdateOperationsInput | string
    givenById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeedbackUncheckedUpdateManyWithoutReceivedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: StringFieldUpdateOperationsInput | string
    givenById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingStatus?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OfferUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    ride?: RideUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rideId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
  }

  export type OfferUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    rideId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
  }

  export type PromoCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referee?: UserUpdateOneRequiredWithoutReferralReceivedNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    refereeId?: StringFieldUpdateOperationsInput | string
    bonusGiven?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    ride?: RideUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    rideId?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    rideId?: StringFieldUpdateOperationsInput | string
    reporterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
    ride?: RideUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    rideId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    rideId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RideCommentUpdateOneWithoutRepliesNestedInput
    replies?: RideCommentUpdateManyWithoutParentNestedInput
    ride?: RideUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type RideCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: RideCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RideCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideInterestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: RideUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type RideInterestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideInterestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedRouteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    originCity?: NullableStringFieldUpdateOperationsInput | string | null
    originSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    destinationAddress?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    destinationCity?: NullableStringFieldUpdateOperationsInput | string | null
    destinationSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedRouteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    originCity?: NullableStringFieldUpdateOperationsInput | string | null
    originSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    destinationAddress?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    destinationCity?: NullableStringFieldUpdateOperationsInput | string | null
    destinationSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedRouteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    originAddress?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    originCity?: NullableStringFieldUpdateOperationsInput | string | null
    originSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    destinationAddress?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    destinationCity?: NullableStringFieldUpdateOperationsInput | string | null
    destinationSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledRideUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdRides?: RideUpdateManyWithoutScheduledRideNestedInput
  }

  export type ScheduledRideUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    createdRides?: RideUncheckedUpdateManyWithoutScheduledRideNestedInput
  }

  export type ScheduledRideUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    scheduleTime?: StringFieldUpdateOperationsInput | string
    daysOfWeek?: ScheduledRideUpdatedaysOfWeekInput | number[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromSuburb?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type CarLicenseHistoryCreateManyCarInput = {
    id?: string
    photoUrl: string
    status?: $Enums.VerificationStatus
    notes?: string | null
    createdAt?: Date | string
  }

  export type RideCreateManyCarInput = {
    id?: string
    driverId: string
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
    scheduledRideId?: string | null
  }

  export type CarLicenseHistoryUpdateWithoutCarInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarLicenseHistoryUncheckedUpdateWithoutCarInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CarLicenseHistoryUncheckedUpdateManyWithoutCarInput = {
    id?: StringFieldUpdateOperationsInput | string
    photoUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideUpdateWithoutCarInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    scheduledRide?: ScheduledRideUpdateOneWithoutCreatedRidesNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutCarInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateManyWithoutCarInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledRideId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateManyRideInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
    invitationId?: string | null
  }

  export type FeedbackCreateManyRideInput = {
    id?: string
    rating: number
    comment?: string | null
    givenById: string
    receivedById: string
    createdAt?: Date | string
    arrivalOnTime?: boolean | null
    startOnTime?: boolean | null
  }

  export type OfferCreateManyRideInput = {
    id?: string
    price: number
    userId: string
    createdAt?: Date | string
    status?: $Enums.OfferStatus
  }

  export type ReportCreateManyRideInput = {
    id?: string
    reason: string
    comment?: string | null
    status?: $Enums.ReportStatus
    reporterId: string
    reportedUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideCommentCreateManyRideInput = {
    id?: string
    content: string
    createdAt?: Date | string
    userId: string
    parentId?: string | null
  }

  export type RideInterestCreateManyRideInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type GroupBookingInvitationCreateManyRideInput = {
    id?: string
    initiatorId: string
    seats: number
    expiresAt: Date | string
    status?: string
  }

  export type BookingUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitation?: GroupBookingInvitationUpdateOneWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    chatMember?: ChatMemberUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
    chatMember?: ChatMemberUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    invitationId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeedbackUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    givenBy?: UserUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    receivedBy?: UserUpdateOneRequiredWithoutFeedbacksReceivedNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    givenById?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FeedbackUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    givenById?: StringFieldUpdateOperationsInput | string
    receivedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startOnTime?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type OfferUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    user?: UserUpdateOneRequiredWithoutOffersNestedInput
  }

  export type OfferUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
  }

  export type OfferUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
  }

  export type ReportUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
  }

  export type ReportUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCommentUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RideCommentUpdateOneWithoutRepliesNestedInput
    replies?: RideCommentUpdateManyWithoutParentNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type RideCommentUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: RideCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RideCommentUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideInterestUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type RideInterestUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideInterestUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupBookingInvitationUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUpdateManyWithoutInvitationNestedInput
    initiator?: UserUpdateOneRequiredWithoutInitiatedInvitationsNestedInput
  }

  export type GroupBookingInvitationUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutInvitationNestedInput
  }

  export type GroupBookingInvitationUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    seats?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMemberCreateManyChatInput = {
    id?: string
    hasStarted?: boolean
    hasEnded?: boolean
    userId: string
    bookingId?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManyChatInput = {
    id?: string
    content: string
    type?: string
    userId: string
    createdAt?: Date | string
  }

  export type ChatMemberUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutChatMemberNestedInput
    user?: UserUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatMemberUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMemberUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    hasStarted?: BoolFieldUpdateOperationsInput | boolean
    hasEnded?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyBadgeInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    earnedAt?: Date | string | null
    lostAt?: Date | string | null
    progress?: number
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    earnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lostAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: FloatFieldUpdateOperationsInput | number
  }

  export type RideCreateManyScheduledRideInput = {
    id?: string
    driverId: string
    carId?: string | null
    carInfo?: string | null
    serviceType?: string | null
    seats: number
    price: number
    receiptPrice?: number | null
    renterScreenshotUrl?: string | null
    additionalInfo?: string | null
    createdAt?: Date | string
    startedAt?: Date | string | null
    arrivedAt?: Date | string | null
    time: Date | string
    isTimeArranged?: boolean
    etaMinutes?: number | null
    destination: string
    origin: string
    fromCity: string
    fromSuburb: string
    toCity: string
    toSuburb: string
    fromCityNorm?: string | null
    fromSuburbNorm?: string | null
    toCityNorm?: string | null
    toSuburbNorm?: string | null
    rideType: string
    isRequest?: boolean
    isVerified?: boolean
    isAnonymous?: boolean
    status?: $Enums.RideStatus
    allowedGender?: string
    destinationLat: number
    destinationLng: number
    originLat: number
    originLng: number
    polyline?: string | null
  }

  export type RideUpdateWithoutScheduledRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUpdateManyWithoutRideNestedInput
    chat?: ChatUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUpdateManyWithoutRideNestedInput
    offers?: OfferUpdateManyWithoutRideNestedInput
    reports?: ReportUpdateManyWithoutRideNestedInput
    car?: CarUpdateOneWithoutRidesNestedInput
    driver?: UserUpdateOneRequiredWithoutRidesNestedInput
    comments?: RideCommentUpdateManyWithoutRideNestedInput
    interests?: RideInterestUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutScheduledRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: BookingUncheckedUpdateManyWithoutRideNestedInput
    chat?: ChatUncheckedUpdateOneWithoutRideNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutRideNestedInput
    offers?: OfferUncheckedUpdateManyWithoutRideNestedInput
    reports?: ReportUncheckedUpdateManyWithoutRideNestedInput
    comments?: RideCommentUncheckedUpdateManyWithoutRideNestedInput
    interests?: RideInterestUncheckedUpdateManyWithoutRideNestedInput
    groupInvitations?: GroupBookingInvitationUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateManyWithoutScheduledRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    carId?: NullableStringFieldUpdateOperationsInput | string | null
    carInfo?: NullableStringFieldUpdateOperationsInput | string | null
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    seats?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    receiptPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    renterScreenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    isTimeArranged?: BoolFieldUpdateOperationsInput | boolean
    etaMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    fromCity?: StringFieldUpdateOperationsInput | string
    fromSuburb?: StringFieldUpdateOperationsInput | string
    toCity?: StringFieldUpdateOperationsInput | string
    toSuburb?: StringFieldUpdateOperationsInput | string
    fromCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    fromSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toCityNorm?: NullableStringFieldUpdateOperationsInput | string | null
    toSuburbNorm?: NullableStringFieldUpdateOperationsInput | string | null
    rideType?: StringFieldUpdateOperationsInput | string
    isRequest?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    allowedGender?: StringFieldUpdateOperationsInput | string
    destinationLat?: FloatFieldUpdateOperationsInput | number
    destinationLng?: FloatFieldUpdateOperationsInput | number
    originLat?: FloatFieldUpdateOperationsInput | number
    originLng?: FloatFieldUpdateOperationsInput | number
    polyline?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RideCommentCreateManyParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    rideId: string
    userId: string
  }

  export type RideCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: RideCommentUpdateManyWithoutParentNestedInput
    ride?: RideUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type RideCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    replies?: RideCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RideCommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingCreateManyInvitationInput = {
    id?: string
    rideId: string
    userId: string
    createdAt?: Date | string
    status?: $Enums.BookingStatus
  }

  export type BookingUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    ride?: RideUpdateOneRequiredWithoutBookingsNestedInput
    user?: UserUpdateOneRequiredWithoutBookingsNestedInput
    chatMember?: ChatMemberUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    chatMember?: ChatMemberUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rideId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarCountOutputTypeDefaultArgs instead
     */
    export type CarCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RideCountOutputTypeDefaultArgs instead
     */
    export type RideCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RideCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatCountOutputTypeDefaultArgs instead
     */
    export type ChatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeCountOutputTypeDefaultArgs instead
     */
    export type BadgeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledRideCountOutputTypeDefaultArgs instead
     */
    export type ScheduledRideCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledRideCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RideCommentCountOutputTypeDefaultArgs instead
     */
    export type RideCommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RideCommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupBookingInvitationCountOutputTypeDefaultArgs instead
     */
    export type GroupBookingInvitationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupBookingInvitationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarDefaultArgs instead
     */
    export type CarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CarLicenseHistoryDefaultArgs instead
     */
    export type CarLicenseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CarLicenseHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RideDefaultArgs instead
     */
    export type RideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RideInterestDefaultArgs instead
     */
    export type RideInterestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RideInterestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferDefaultArgs instead
     */
    export type OfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OfferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatDefaultArgs instead
     */
    export type ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatMemberDefaultArgs instead
     */
    export type ChatMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BadgeDefaultArgs instead
     */
    export type BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBadgeDefaultArgs instead
     */
    export type UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralDefaultArgs instead
     */
    export type ReferralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppConfigDefaultArgs instead
     */
    export type AppConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppConfigDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserStatsDefaultArgs instead
     */
    export type UserStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserStatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromoCodeDefaultArgs instead
     */
    export type PromoCodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromoCodeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminLastVisitDefaultArgs instead
     */
    export type AdminLastVisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminLastVisitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedRouteDefaultArgs instead
     */
    export type SavedRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduledRideDefaultArgs instead
     */
    export type ScheduledRideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduledRideDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RideCommentDefaultArgs instead
     */
    export type RideCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RideCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupBookingInvitationDefaultArgs instead
     */
    export type GroupBookingInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupBookingInvitationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use spatial_ref_sysDefaultArgs instead
     */
    export type spatial_ref_sysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = spatial_ref_sysDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}